[
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "Browse Posts by Topic",
    "section": "",
    "text": "Welcome to CosMx Scratch Space!\nThis repository is an exploratory resource to accelerate opensource analysis of CosMx® Spatial Molecular Imager (SMI) data. Contained here are writeups and vignettes addressing a variety of topics discussed when analyzing single-cell spatial data.\nIf you would like to see a blog post on a particular topic, submit an issue on our github page."
  },
  {
    "objectID": "about.html#data-formats",
    "href": "about.html#data-formats",
    "title": "Browse Posts by Topic",
    "section": "Data Formats",
    "text": "Data Formats\n\nFile structures for outputs of the AtoMx® export module\nCreating an anndata object from AtoMx® exported results for interactive viewer and python-based analysis\nMaking composite images from layered morphology 2D images\nComparing AtoMx® SIP flat files with the legacy format\nTool for aligning protein and RNA data\nGenerating an expression matrix from aligned RNA data"
  },
  {
    "objectID": "about.html#analysis-strategies",
    "href": "about.html#analysis-strategies",
    "title": "Browse Posts by Topic",
    "section": "Analysis Strategies",
    "text": "Analysis Strategies\n\nWhat is spatial data for?\nVignette: basics of CosMx® analysis in R (circa 2023, deprecated)\nVignette: basics of CosMx® analysis in R\nUsing Squidpy with AtoMx® SIP exports\nQC and normalization of RNA data\nFOV QC from single-cell gene expression in spatial dataset\nImpacts of background in CosMx® data\nBatch correction\nThe spatial algorithms zoo: recommended algorithms and efficient code\nA generally satisfying set of UMAP parameters for CosMx data\nQuick & comprehensive searches for interesting trends with “Everything vs. everything DE”\nApproaches to ligand-receptor analysis\nBig datasets: strategies for memory-efficient analysis\nlots without excessive file sizes\nFunctions for condensing FOVs and tissues to minimize whitespace\nCellular neighborhoods: a useful, simple and flexible analysis framework\nInSituDiff: Perturbation analysis of disease vs. control cellular neighborhoods\nInSituCor: Discovering modules of spatially correlated genes\nGuide to comparing data from different CosMx panels\nTips for using the AtoMx Spatial Discovery workflow"
  },
  {
    "objectID": "about.html#cell-typing",
    "href": "about.html#cell-typing",
    "title": "Browse Posts by Topic",
    "section": "Cell typing",
    "text": "Cell typing\n\nCell typing: what we’ve found to work\nCell typing: advanced strategies\nCreating reference profiles\nOn the use of marker genes\nHierarchical tree-style cell typing\nSmoothed marker genes for cell typing and visualization\nUsing marker gene driven metagene scores for granular hierarchical cell typing\nIntegrating spatial information and/or cell images into existing cell typing results\nCosMx SMI Cell Profiles\nIntegrated RNA + protein multiomic cell typing using HieraType"
  },
  {
    "objectID": "about.html#cell-segmentation",
    "href": "about.html#cell-segmentation",
    "title": "Browse Posts by Topic",
    "section": "Cell segmentation",
    "text": "Cell segmentation\n\nThe impact of segmentation error on differential expression analyses\nFastReseg: Evaluating cell segmentation error based on transcripional spatial profiles\nGuide to run transcript-based segmentation and refinement on CosMx data\nAdvancing cell segmentation in spatial omics: new models for diverse morphologies"
  },
  {
    "objectID": "about.html#data-visualization",
    "href": "about.html#data-visualization",
    "title": "Browse Posts by Topic",
    "section": "Data visualization",
    "text": "Data visualization\n\nPlotting spatial data\nVisualizing spatial data with Seurat\nNeighVizGallery: Visualization of cellular neighborhood in gallery mode\nFunctions for condensing FOVs and tissues to minimize whitespace\ncellPoly: Inferring cell polygons from transcript locations\n(For fun) Spatial transcriptomics plots in stained glass"
  },
  {
    "objectID": "about.html#viewing-cosmx-smi-data-with-napari",
    "href": "about.html#viewing-cosmx-smi-data-with-napari",
    "title": "Browse Posts by Topic",
    "section": "Viewing CosMx® SMI data with Napari",
    "text": "Viewing CosMx® SMI data with Napari\n\nIntro: using Napari to view and analyze CosMx data and creating napari-ready files from AtoMx exports\nNapari-CosMx plugin essentials\nProgrammatic stitching with napari-cosmx\nProgrammatic stitching of CosMx SMI protein with napari-cosmx\nExporting Zarr Stores to OME-TIFF\nAdvanced plugin tips: creating regions of interests to select cells\nAdvanced plugin tips: reproducibility of images and creating animations\nAligning H&E and CosMx Images in napari"
  },
  {
    "objectID": "about.html#tissue-specific-solutions",
    "href": "about.html#tissue-specific-solutions",
    "title": "Browse Posts by Topic",
    "section": "Tissue-specific solutions",
    "text": "Tissue-specific solutions\n\nA workflow for kidney samples: cell typing and glomerulus definitions\nScoring brain cells for distance to plaques"
  },
  {
    "objectID": "about.html#geomx-relevant-posts",
    "href": "about.html#geomx-relevant-posts",
    "title": "Browse Posts by Topic",
    "section": "GeoMx® relevant posts",
    "text": "GeoMx® relevant posts\n\nGeoMx® mask generation for marker-based single-cell application"
  },
  {
    "objectID": "assets/napari-cosmx releases/change_log.html",
    "href": "assets/napari-cosmx releases/change_log.html",
    "title": "Napari-CosMx plugin change log",
    "section": "",
    "text": "Released Nov. 6th, 2025\nAllows reading plexfiles from data exported in AtoMx(R) SIP version 2.0+ (csv) while still being backwards compatible (tsv).\n\n\n\n\n\nReleased Feb. 21st, 2025\nUpdated export-tiff package script\nUpdated protein stitch-expression package script to fit updated AtoMx SIP export format\n\n\n\n\n\nReleased Nov. 8th, 2024\nUpdated offsets to work with future SIP file formats while retaining legacy compatibility.\n\n\n\n\n\nReleased May 1st, 2024\nInitial release."
  },
  {
    "objectID": "assets/napari-cosmx releases/change_log.html#section",
    "href": "assets/napari-cosmx releases/change_log.html#section",
    "title": "Napari-CosMx plugin change log",
    "section": "",
    "text": "Released Nov. 6th, 2025\nAllows reading plexfiles from data exported in AtoMx(R) SIP version 2.0+ (csv) while still being backwards compatible (tsv)."
  },
  {
    "objectID": "assets/napari-cosmx releases/change_log.html#section-1",
    "href": "assets/napari-cosmx releases/change_log.html#section-1",
    "title": "Napari-CosMx plugin change log",
    "section": "",
    "text": "Released Feb. 21st, 2025\nUpdated export-tiff package script\nUpdated protein stitch-expression package script to fit updated AtoMx SIP export format"
  },
  {
    "objectID": "assets/napari-cosmx releases/change_log.html#section-2",
    "href": "assets/napari-cosmx releases/change_log.html#section-2",
    "title": "Napari-CosMx plugin change log",
    "section": "",
    "text": "Released Nov. 8th, 2024\nUpdated offsets to work with future SIP file formats while retaining legacy compatibility."
  },
  {
    "objectID": "assets/napari-cosmx releases/change_log.html#section-3",
    "href": "assets/napari-cosmx releases/change_log.html#section-3",
    "title": "Napari-CosMx plugin change log",
    "section": "",
    "text": "Released May 1st, 2024\nInitial release."
  },
  {
    "objectID": "posts/flat-file-exports/flat-files-compare.html",
    "href": "posts/flat-file-exports/flat-files-compare.html",
    "title": "Comparing AtoMx® SIP flat files with the legacy format",
    "section": "",
    "text": "There are different data formats and structures that can be exported from the AtoMx® Spatial Informatics Portal (SIP). These include the raw data (i.e., with CellStatsDir, RunSummary, and AnalysisResults folders), Seurat (with or without images), Tiledb, and “flat files”. The flat files get their name because they are in a human-readable and accessible format (i.e., comma separated files). These files, like Seurat files and Tiledb files, aren’t actually raw data but are processed data and can include additional analysis results (e.g., cell typing data).\nThe first use of the flat file format was about a year and a half ago when He et al. (2022) released the first public CosMx® SMI dataset, consisting of ~800k cells with 980 RNA targets from multiple tissues of NSCLC FFPE. Now there are additional public datasets that span two species (mouse, human), four tissues (lung, liver, brain, pancreas), and three levels of plex (1k, 6k, whole transcriptome). Because the flat files generated in AtoMx SIP differ from the flat files in these public data releases, I thought it might be helpful to show a comparison.\nSpecifically, in this post I compare the flat files created for Lung5_rep1 of the NSCLC dataset side-by-side with the updated (AtoMx 1.3.2) flat file format from an unrelated tissue. The specific values will be different since they are different datasets, of course, but the following side-by-sides show similarities and differences between the formats.\n\n1 FOV positions flat file\nWhen we compare the FOV positions between old and new, you can see that the column name ‘fov’ has been changed to ‘FOV’ and the newer format includes global positions of the FOVs in units of mm in addition to pixels.\n\nLegacyAtoMx SIP v1.3.2\n\n\n\n\n\nTable 1: Description of the legacy FOV positions file format. Δ = column name change between versions\n\n\n\n\n\n\n\n\n\n\nColumn Name\nType\nDescription\n\n\n\n\nfov\\(^{Δ}\\)\nInt\nThe field of view (FOV) number\n\n\nx_global_px\nfloat\nThe x location (in pixels) of the FOV relative to other FOVs\n\n\ny_global_px\nfloat\nThe y location (in pixels) of the FOV relative to other FOVs\n\n\n\n\n\n\nExample:\n  fov x_global_px y_global_px\n  1    3188.889    155216.7\n  2    8661.111    155216.7\n  3   14133.333    155216.7\n  4   19605.556    155216.7\n  5   25077.778    155216.7\n  6    3188.889    158866.7\n  7    8661.111    158866.7\n  8   14133.333    158866.7\n  9   19605.556    158866.7\n  10   25077.778    158866.7\n\n\n\n\n\nTable 2: Description of the baseline FOV file format for AtoMx SIP v1.3.2. Δ = column name change between versions; * = new column in 1.3.2 compared to legacy\n\n\n\n\n\n\n\n\n\n\nColumn Name\nType\nDescription\n\n\n\n\nFOV\\(^{Δ}\\)\nInt\nThe field of view (FOV) number\n\n\nx_global_px\nfloat\nThe x location (in pixels) of the FOV relative to other FOVs\n\n\ny_global_px\nfloat\nThe y location (in pixels) of the FOV relative to other FOVs\n\n\nx_global_mm\\(^{*}\\)\nfloat\nThe x location (in millimeters) of the FOV relative to other FOVs\n\n\ny_global_mm\\(^{*}\\)\nfloat\nThe y location (in millimeters) of the FOV relative to other FOVs\n\n\n\n\n\n\nFOV x_global_px y_global_px x_global_mm y_global_mm\n  1           0       29791   0.0000000    3.583410\n  2        4255       29791   0.5119157    3.583410\n  3        8511       29791   1.0238314    3.583410\n  4       12767       29791   1.5357471    3.583410\n  5       17023       29791   2.0476628    3.583410\n  6       21279       29791   2.5595785    3.583410\n  7       25535       29791   3.0714942    3.583410\n  8       29791       29791   3.5834099    3.583410\n  9           0       25535   0.0000000    3.071494\n  10        4255       25535   0.5119157    3.071494\n\n\n\n\n\n2 Expression Matrix\nFor expression matrices, we see that NegPrb(\\d+) is changed to Negative(\\d+) and the newer format has SystemControls.\n\nLegacyAtoMx SIP v1.3.2\n\n\n\n\n\nTable 3: Description of the legacy expression matrix file format. Δ = column name change between versions\n\n\n\n\n\n\n\n\n\n\nColumn Name\nType\nDescription\n\n\n\n\nfov\nInt\nThe field of view (FOV) number\n\n\ncell_ID\nInt\nUnique identifier for a single cell within a given FOV. To make a unique identifier for a cell within the whole sample use both the fov and cell_ID columns. All transcripts not assigned to a cell are show with a cell_ID value of 0.\n\n\n(Gene expression target)\nInt\nThe number of transcripts observed for a given gene target for a given cell.\n\n\n(Negative Probe; e.g. NegPrb1)\\(^{Δ}\\)\nInt\nNegative probes, which do not match any sequence within the transcriptome or genome. These can be used to assess background levels.\n\n\n\n\n\n\nExample:\nfov cell_ID AATK ... ZFP36 NegPrb3 ... NegPrb23\n  1       0   15 ...   184      12 ...       13\n  1       1    0 ...     0       0 ...        0\n  1       2    0 ...     1       0 ...        0\n  1       3    0 ...     0       0 ...        0\n  1       4    0 ...     0       0 ...        0\n  1       5    0 ...     0       0 ...        0\n  1       6    0 ...     0       0 ...        0\n  1       7    0 ...     1       0 ...        0\n  1       8    0 ...     0       0 ...        0\n  1       9    0 ...     0       0 ...        0\n\n\n\n\n\nTable 4: Description of the baseline expression matrix file format for AtoMx SIP v1.3.2. * = new column in 1.3.2 compared to legacy\n\n\n\n\n\n\n\n\n\n\nColumn Name\nType\nDescription\n\n\n\n\nfov\nInt\nThe field of view (FOV) number\n\n\ncell_ID\nInt\nUnique identifier for a single cell within a given FOV. To make a unique identifier for a cell within the whole sample use both the fov and cell_ID columns. All transcripts not assigned to a cell are show with a cell_ID value of 0.\n\n\n(Gene expression target)\nInt\nThe number of transcripts observed for a given gene target for a given cell.\n\n\n(Negative Probe, e.g., Negative1)\\(^{Δ}\\)\nInt\nNegative probes, which do not match any sequence within the transcriptome or genome. These can be used to assess background levels.\n\n\n(System Control)\\(^{*}\\)\nInt\nSystem Control codes are codes which do not have any physical probe associated with them.\n\n\n\n\n\n\n\n\n\n\n\nExample:\nfov cell_ID A1BG ... ZZZ3 Negative1 ... Negative9 SystemControl1 ... SystemControl99\n  1       1    0 ...    0         0 ...         0              0 ...               0\n  1       2    0 ...    0         0 ...         0              0 ...               0\n  1       3    0 ...    0         0 ...         0              0 ...               0\n  1       4    1 ...    0         0 ...         0              0 ...               0\n  1       5    0 ...    0         0 ...         0              0 ...               0\n  1       6    0 ...    0         0 ...         0              0 ...               0\n  1       7    0 ...    0         0 ...         0              0 ...               0\n  1       8    0 ...    0         0 ...         0              0 ...               0\n  1       9    1 ...    0         0 ...         0              0 ...               0\n  1      10    0 ...    0         0 ...         0              0 ...               0\n\n\n\n\n\n3 Metadata file\nThere are several differences to the metadata files between the legacy and current versions and I’ll highlight a few new additions below. One thing to note is that exported data from AtoMx SIP can have columns with analysis results in addition to the “baseline” columns.\nCell shape metrics – In the legacy version, basic cell shape was described with Area, Width, Height, and AspectRaio (Table 5). The new version of the metadata includes these plus four additional metrics that describe the cell shape (Table 6). These are perimeter, circularity, eccentricity, and solidity. Perimeter is simply the perimeter of the cell in pixels and the latter three are defined in Fu et al. (2024).\nSplitRatioToLocal – for cells that are adjacent to the FOV boundaries, the SplitRatioToLocal metric measures the cell area relative to the mean area of cells in the FOVs. For 0 &lt; SplitRatioToLocal &lt; 1, the cell is smaller than average and for SplitRatioToLocal &gt; 1 the cell is larger than average. Note that a value of 0 means the cell is not along the border.\nFOV-level metrics – there are some columns that are added as FOV-level metrics. For example, median_RNA provides the median RNA target probe expression across all cells within a given FOV.\n\nLegacy ColumnsAtoMx SIP v1.3.2\n\n\n\n\n\nTable 5: Description of the legacy metadata file format. Δ = column name change between versions; * = new column in 1.3.2 compared to legacy\n\n\n\n\n\n\n\n\n\n\nColumn Name\nType\nDescription\n\n\n\n\nfov\nInt\nThe field of view (FOV) number.\n\n\ncell_ID\nInt\nUnique identifier for a single cell within a given FOV. To make a unique identifier for a cell within the whole sample use both the fov and cell_ID columns.\n\n\nArea\nInt\nNumber of pixels assigned to a given cell.\n\n\nAspectRatio\nfloat\nWidth divided by height.\n\n\nCenterX_local_px\nInt\nThe x position of this cell within the FOV, measured in pixels. The pixel edge length is 120 nm. Thus, to convert to microns multiply the pixel value by 0.12028 \\(\\mu\\)m per pixel.\n\n\nCenterY_local_px\nInt\nSame as CenterX_local_px but for the y dimension.\n\n\nCenterX_global_px\nfloat\nSee CenterX_local_px description. The global positions describes the relative position of this cell within the large sample reference frame.\n\n\nCenterY_global_px\nfloat\nSame as CenterX_global_px but for the y dimension.\n\n\nWidth\nInt\nCell’s maximum length in x dimension (pixels).\n\n\nHeight\nInt\nCell’s maximum length in y dimension (pixels).\n\n\nMean.(IF)\nInt\nThe mean fluorescence intensity for a given cell.\n\n\nMax.(IF)\nInt\nThe max fluorescence intensity for a given cell.\n\n\n\n\n\n\nExample:\n'data.frame':   6 obs. of  20 variables:\n $ fov               : int  1 1 1 1 1 1\n $ cell_ID           : int  1 2 3 4 5 6\n $ Area              : int  1259 3723 2010 3358 1213 2647\n $ AspectRatio       : num  1.34 1.45 1.62 0.47 1 1.38\n $ CenterX_local_px  : int  1027 2904 4026 4230 4258 66\n $ CenterY_local_px  : int  3631 3618 3627 3597 3629 3622\n $ CenterX_global_px : num  4216 6093 7215 7419 7447 ...\n $ CenterY_global_px : num  158848 158835 158844 158814 158846 ...\n $ Width             : int  47 87 68 48 38 72\n $ Height            : int  35 60 42 102 38 52\n $ Mean.MembraneStain: int  3473 3895 2892 6189 8138 5713\n $ Max.MembraneStain : int  7354 13832 6048 16091 19281 12617\n $ Mean.PanCK        : int  715 18374 3265 485 549 1220\n $ Max.PanCK         : int  5755 53158 37522 964 874 5107\n $ Mean.CD45         : int  361 260 378 679 566 433\n $ Max.CD45          : int  845 1232 908 2322 1242 957\n $ Mean.CD3          : int  22 13 19 5 17 11\n $ Max.CD3           : int  731 686 654 582 674 547\n $ Mean.DAPI         : int  4979 1110 10482 6065 3311 4151\n $ Max.DAPI          : int  26374 13229 33824 39512 30136 19269\n\n\n\n\n\n\n\n\nNote\n\n\n\nIf analysis has been performed on AtoMx SIP prior to export, additional columns not presented here may be added to the metadata file. For example, if cell typing has been performed, there may be a column named RNA_nbclust_[GUID]_1_clusters containing the estimated cell type.\n\n\n\n\n\nTable 6: Description of the baseline metadata file format for AtoMx SIP v1.3.2. Δ = column name change between versions; * = new column in 1.3.2 compared to legacy\n\n\n\n\n\n\n\n\n\n\nColumn Name\nType\nDescription\n\n\n\n\nfov\nInt\nThe field of view (FOV) number.\n\n\nArea\nInt\nNumber of pixels assigned to a given cell.\n\n\nAspectRatio\nfloat\nWidth divided by height.\n\n\nCenterX_local_px\nInt\nThe x position of this cell within the FOV, measured in pixels. The pixel edge length is 120 nm. Thus, to convert to microns multiply the pixel value by 0.12028 \\(\\mu\\)m per pixel.\n\n\nCenterY_local_px\nInt\nSame as CenterX_local_px but for the y dimension.\n\n\nWidth\nInt\nCell’s maximum length in x dimension (pixels).\n\n\nHeight\nInt\nCell’s maximum length in y dimension (pixels).\n\n\nMean.(IF)\nInt\nThe mean fluorescence intensity for a given cell.\n\n\nMax.(IF)\nInt\nThe max fluorescence intensity for a given cell.\n\n\nSplitRatioToLocal\\(^{*}\\)\nfloat\nIf cell abuts the FOV border: the ratio of Area to mean cell area for that FOV. If cell does not border the FOV boundary: 0.\n\n\nNucArea\\(^{*}\\)\nInt\nNumber of pixels assigned to a given nucleus.\n\n\nNucAspectRatio\\(^{*}\\)\nfloat\nWidth divided by height of nucleus.\n\n\nCircularity\\(^{*}\\)\nfloat\nArea to perimeter ratio. 1 = circle; &lt; 1 less circular (Fu et al. 2024).\n\n\nEccentricity\\(^{*}\\)\nfloat\nA cell’s minor axis divided by its major axis (Fu et al. 2024).\n\n\nPerimeter\\(^{*}\\)\nInt\nThe perimeter of the cell (in pixels)\n\n\nSolidity\\(^{*}\\)\nfloat\nThe Area of the cell divided by its convex area. A measure of the “density” of a cell with values &lt; 1 indicating increased cell irregularity (Fu et al. 2024)\n\n\ncell_id\\(^{*}\\)\nstring\nA study-wide unique cell identifier. Combination of c(ell), slide_ID, fov, and cell_ID. Note that this is equivalent to cell_ID in napari-cosmx.\n\n\nassay_type\\(^{*}\\)\nstring\nThe assay type (Protein or RNA)\n\n\nversion\\(^{*}\\)\nstring\nThe version of the target decoding used.\n\n\nRun_Tissue_name\\(^{*}\\)\nstring\nThe name of the slide.\n\n\nPanel\\(^{*}\\)\nstring\nThe panel that was assayed.\n\n\ncellSegmentationSetId\\(^{*}\\).\nstring\nThe cell segmentation set ID.\n\n\ncellSegmentationSetName\\(^{*}\\)\nstring\nThe cell segmentation set name.\n\n\nslide_ID\\(^{*}\\)\nInt\nUnique identifier for the slide.\n\n\nCenterX_global_px\nfloat\nSee CenterX_local_px description. The global positions describes the relative position of this cell within the large sample reference frame.\n\n\nCenterY_global_px\nfloat\nSame as CenterX_global_px but for the y dimension.\n\n\ncell_ID\nInt\nUnique identifier for a single cell within a given FOV. To make a unique identifier for a cell within the whole sample use both the fov and cell_ID columns.\n\n\nunassignedTranscripts\\(^{*}\\)\nfloat\nProportion of transcripts in the FOV the cell resides in that are not assigned within any cell. This value is an FOV-level metric that is repeated for each cell (excluding cell 0).\n\n\nmedian_RNA\\(^{*}\\)\nfloat\nFOV-level statistic. Median RNA target probe expression across all cells within a given FOV.\n\n\nRNA_quantile_(proportion)\\(^{*}\\)\nfloat\nFOV-level statistic. The (proportion*100) percentile of RNA target expression across all cells within a given FOV.\n\n\nnCount_RNA\\(^{*}\\)\nInt\nTotal RNA transcripts observed.\n\n\nnFeature_RNA\\(^{*}\\)\nInt\nTotal number of unique RNA transcripts observed.\n\n\nmedian_negprobes\\(^{*}\\)\nfloat\nFOV-level statistic. Median negative probe expression across all cells within a given FOV.\n\n\nnegprobes_quantile_(proportion)\\(^{*}\\)\nfloat\nFOV-level statistic. The (proportion*100) percentile of negative probe expression across all cells within a given FOV.\n\n\nnCount_negprobes\\(^{*}\\)\nInt\nTotal Negative Control Probe counts observed.\n\n\nnFeature_negprobes\\(^{*}\\)\nInt\nTotal number of unique Negative Control Probe counts observed.\n\n\nmedian_falsecode\\(^{*}\\)\nfloat\nFOV-level statistic. Median System Control counts across all cells within a given FOV.\n\n\nfalsecode_quantile_(proportion)\\(^{*}\\)\nfloat\nFOV-level statistic. The (proportion*100) percentile of System Control counts across all cells within a given FOV.\n\n\nnCount_falsecode\\(^{*}\\)\nInt\nTotal System Control codes counts observed. These codes do not have a physical probe in the experiment.\n\n\nnFeature_falsecode\\(^{*}\\)\nInt\nTotal number of unique System Control codes counts observed.\n\n\nArea.um2\\(^{*}\\)\nfloat\nThe cell area in units of \\(\\mu m^{2}\\)\n\n\ncell\\(^{*}\\)\nstring\nRedundant with cell_id\n\n\n\n\n\n\nExample:\n'data.frame':   6 obs. of  65 variables:\n $ fov                    : int  1 1 1 1 1 1\n $ Area                   : int  3037 8790 5552 5822 4008 3603\n $ AspectRatio            : num  0.67 0.95 0.77 0.9 0.97 0.88\n $ CenterX_local_px       : int  3938 2741 3888 4214 4137 4163\n $ CenterY_local_px       : int  25 52 57 73 152 187\n $ Width                  : int  76 110 96 81 78 83\n $ Height                 : int  51 104 74 90 76 73\n $ Mean.B                 : int  41 425 88 197 73 91\n $ Max.B                  : int  252 2308 952 604 552 364\n $ Mean.G                 : int  50 1270 154 48 22 26\n $ Max.G                  : int  1192 6960 4192 184 380 160\n $ Mean.Y                 : int  106 366 254 235 97 196\n $ Max.Y                  : int  1228 2864 3884 1340 828 904\n $ Mean.R                 : int  36 62 221 20 4 16\n $ Max.R                  : int  2360 1044 5604 104 60 232\n $ Mean.DAPI              : int  92 37 181 288 237 324\n $ Max.DAPI               : int  408 236 924 1060 800 928\n $ SplitRatioToLocal      : num  0.7 2.01 0 1.33 0 0\n $ NucArea                : int  1252 0 1180 2384 1284 1536\n $ NucAspectRatio         : num  0.77 0 1 0.94 0.95 0.81\n $ Circularity            : num  0.92 1.05 1.03 1.03 0.94 0.83\n $ Eccentricity           : num  0.76 0.82 0.79 0.71 0.9 0.82\n $ Perimeter              : int  204 324 260 266 231 233\n $ Solidity               : num  14.9 27.1 21.4 21.9 17.4 ...\n $ cell_id                : chr  \"c_1_1_1\" \"c_1_1_2\" \"c_1_1_3\" \"c_1_1_4\" ...\n $ assay_type             : chr  \"RNA\" \"RNA\" \"RNA\" \"RNA\" ...\n $ version                : chr  \"v6\" \"v6\" \"v6\" \"v6\" ...\n $ Run_Tissue_name        : chr  \"example_tissue\" \"example_tissue\" \"example_tissue\" \"example_tissue\" ...\n $ Panel                  : chr  \"Human RNA 6k Discovery\" \"Human RNA 6k Discovery\" \"Human RNA 6k Discovery\" \"Human RNA 6k Discovery\" ...\n $ cellSegmentationSetId  : chr  \" a343598a-ed40-4a93-a655-49bc7688021d\" \" a343598a-ed40-4a93-a655-49bc7688021d\" \" a343598a-ed40-4a93-a655-49bc7688021d\" \" a343598a-ed40-4a93-a655-49bc7688021d\" ...\n $ cellSegmentationSetName: chr  \" Initial Segmentation\" \" Initial Segmentation\" \" Initial Segmentation\" \" Initial Segmentation\" ...\n $ slide_ID               : int  1 1 1 1 1 1\n $ CenterX_global_px      : int  21057 19860 21007 21333 21256 21282\n $ CenterY_global_px      : int  68070 68043 68038 68022 67943 67908\n $ cell_ID                : int  1 2 3 4 5 6\n $ unassignedTranscripts  : num  0.0349 0.0349 0.0349 0.0349 0.0349 ...\n $ median_RNA             : int  86 86 86 86 86 86\n $ RNA_quantile_0.75      : int  126 126 126 126 126 126\n $ RNA_quantile_0.8       : int  139 139 139 139 139 139\n $ RNA_quantile_0.85      : int  157 157 157 157 157 157\n $ RNA_quantile_0.9       : int  182 182 182 182 182 182\n $ RNA_quantile_0.95      : int  240 240 240 240 240 240\n $ RNA_quantile_0.99      : num  512 512 512 512 512 ...\n $ nCount_RNA             : int  138 295 234 344 230 249\n $ nFeature_RNA           : int  86 182 152 217 148 132\n $ median_negprobes       : int  9 9 9 9 9 9\n $ negprobes_quantile_0.75: int  126 126 126 126 126 126\n $ negprobes_quantile_0.8 : int  139 139 139 139 139 139\n $ negprobes_quantile_0.85: int  157 157 157 157 157 157\n $ negprobes_quantile_0.9 : int  182 182 182 182 182 182\n $ negprobes_quantile_0.95: int  240 240 240 240 240 240\n $ negprobes_quantile_0.99: num  512 512 512 512 512 ...\n $ nCount_negprobes       : int  0 0 1 0 0 0\n $ nFeature_negprobes     : int  0 0 1 0 0 0\n $ median_falsecode       : int  4 4 4 4 4 4\n $ falsecode_quantile_0.75: int  126 126 126 126 126 126\n $ falsecode_quantile_0.8 : int  139 139 139 139 139 139\n $ falsecode_quantile_0.85: int  157 157 157 157 157 157\n $ falsecode_quantile_0.9 : int  182 182 182 182 182 182\n $ falsecode_quantile_0.95: int  240 240 240 240 240 240\n $ falsecode_quantile_0.99: num  512 512 512 512 512 ...\n $ nCount_falsecode       : int  1 0 0 1 1 1\n $ nFeature_falsecode     : int  1 0 0 1 1 1\n $ Area.um2               : num  43.9 127.2 80.3 84.2 58 ...\n $ cell                   : chr  \"c_1_1_1\" \"c_1_1_2\" \"c_1_1_3\" \"c_1_1_4\" ...\n\n\n\n\n\n4 Transcript coordinates file\nMain differences between versions:\n\nThe contents of the CellComp column differ between version. In the current version “None” replaces “0”. The other three regions–Membrane, Nuclear, Cytoplasm–are unchanged.\ncell column is added to the newer version.\n\n\nLegacyAtoMx SIP v1.3.2\n\n\n\n\n\nTable 7: Description of the legacy transcripts file format. ‡ = contents changed between versions\n\n\n\n\n\n\n\n\n\n\nColumn Name\nType\nDescription\n\n\n\n\nfov\nInt\nThe field of view (FOV) number.\n\n\ncell_ID\nInt\nUnique identifier for a single cell within a given FOV. To make a unique identifier for a cell within the whole sample use both the fov and cell_ID columns.\n\n\nx_global_px\nfloat\nThe x position (in pixels) relative to the tissue.\n\n\ny_global_px\nfloat\nThe y position (in pixels) relative to the tissue.\n\n\nx_local_px\nfloat\nThe x position (in pixels) relative to the given FOV.\n\n\ny_local_px\nfloat\nThe y position (in pixels) relative to the given FOV.\n\n\nz\nInt\nThe z plane.\n\n\ntarget\nstring\nThe name of the target.\n\n\nCellComp‡\nstring\nSubcellular location of target.\n\n\n\n\n\n\nExample:\nfov cell_ID x_global_px y_global_px x_local_px y_local_px  z  target CellComp\n  1       0    6757.402    158836.4   3568.513  3619.7375 11   NEAT1        0\n  1       0    5111.389    156060.2   1922.500   843.5334 11   NEAT1        0\n  1       0    7860.461    157809.3   4671.572  2592.6715 11    CCR2        0\n  1       0    3790.489    155553.9    601.600   337.2168 11 HLA-DRA        0\n  1       0    3290.639    158023.6    101.750  2806.9750 11 HLA-DRA Membrane\n  1       0    7020.160    158656.3   3831.271  3439.6000 11     VHL        0\n  1       0    4252.914    157003.0   1064.025  1786.3376 11    FZD5  Nuclear\n  1       0    5987.309    157572.5   2798.420  2355.8000 11    CD37        0\n  1       0    5586.849    157774.2   2397.960  2557.5599 11   ATG12 Membrane\n\n\n\n\n\nTable 8: Description of the baseline transcripts file format for AtoMx SIP v1.3.2. * = new column in 1.3.2 compared to legacy; ‡ = contents changed between versions\n\n\n\n\n\n\n\n\n\n\nColumn Name\nType\nDescription\n\n\n\n\nfov\nInt\nThe field of view (FOV) number.\n\n\ncell_ID\nInt\nUnique identifier for a single cell within a given FOV. To make a unique identifier for a cell within the whole sample use both the fov and cell_ID columns.\n\n\ncell\\(^{*}\\)\nstring\nA study-wide unique cell identifier. Combination of c(ell), slide ID, fov, and cell_ID. Note that this is equivalent to cell_ID in napari-cosmx.\n\n\nx_local_px\nfloat\nThe x position (in pixels) relative to the given FOV.\n\n\ny_local_px\nfloat\nThe y position (in pixels) relative to the given FOV.\n\n\nx_global_px\nfloat\nThe x position (in pixels) relative to the tissue.\n\n\ny_global_px\nfloat\nThe y position (in pixels) relative to the tissue.\n\n\nz\nInt\nThe z plane.\n\n\ntarget\nstring\nThe name of the target.\n\n\nCellComp‡\nstring\nSubcellular location of target.\n\n\n\n\n\n\nExample:\n fov cell_ID        cell       x_local_px y_local_px x_global_px y_global_px   z   target  CellComp\n  30    4755 c_1_30_4755 29337.6332465278   173483.2   4259.8555    16.57764   3      B2M Cytoplasm         \n  30    4755 c_1_30_4755 29340.4174262153   173488.4   4262.6396    21.71997   3   COL3A1 Cytoplasm         \n  30    4757 c_1_30_4757 29593.4975043403   173480.9   4515.7197    14.27002   8    RPL32 Cytoplasm         \n  30    4759 c_1_30_4759 25211.3444434272   173477.6    133.5667    10.95020   6   COL1A1 Cytoplasm         \n  30    4759 c_1_30_4759 25224.5611029731   173483.9    146.7833    17.28320   6   COL1A2 Cytoplasm         \n  30    4760 c_1_30_4760 25902.6278143989   173480.8    824.8500    14.11694   7   TPSAB1 Cytoplasm         \n  30    4760 c_1_30_4760 25924.0527411567   173477.8    846.2750    11.10010   1 HSP90AB1 Cytoplasm         \n  30    4760 c_1_30_4760 25925.7694159614   173478.0    847.9916    11.34155   6     GLUL Cytoplasm         \n  30    4760 c_1_30_4760 25914.4152899848   173478.9    836.6375    12.27515   6   ADGRE2 Cytoplasm         \n  30    4760 c_1_30_4760 25902.9277411567   173480.7    825.1500    14.07520   8   TPSAB1 Cytoplasm   \n\n\n\n\n\n5 Polygons file\nThe polygons file was added to the list of flat files and shows the vertices of each cell’s polygon.\n\nLegacyAtoMx SIP v1.3.2\n\n\n(Not applicable)\n\n\n\n\n\nTable 9: Description of the baseline polygons file format for AtoMx SIP v1.3.2.\n\n\n\n\n\n\n\n\n\n\nColumn Name\nType\nDescription\n\n\n\n\nfov\nInt\nThe field of view (FOV) number.\n\n\ncell_ID\nInt\nUnique identifier for a single cell within a given FOV. To make a unique identifier for a cell within the whole sample use both the fov and cell_ID columns.\n\n\ncell\nstring\nA study-wide unique cell identifier. Combination of c(ell), slide ID, and cell_ID. Note that this is equivalent to cell_ID in napari-cosmx.\n\n\nx_local_px\nfloat\nThe x position (in pixels) of vertex relative to the given FOV.\n\n\ny_local_px\nfloat\nThe y position (in pixels) of vertex relative to the given FOV.\n\n\nx_global_px\nfloat\nThe x position (in pixels) of vertex relative to the tissue.\n\n\ny_global_px\nfloat\nThe y position (in pixels) of vertex relative to the tissue.\n\n\n\n\n\n\nExample:\nThis example below shows the vertices of cell c_1_2_3.\n  fov cellID    cell x_local_px y_local_px x_global_px y_global_px\n  2      3 c_1_2_3        279          0        4535       29792\n  2      3 c_1_2_3        279          1        4535       29791\n  2      3 c_1_2_3        270         15        4526       29777\n  2      3 c_1_2_3        266         20        4522       29772\n  2      3 c_1_2_3        234         53        4490       29739\n  2      3 c_1_2_3        223         64        4479       29728\n  2      3 c_1_2_3        214         71        4470       29721\n  2      3 c_1_2_3        210         72        4466       29720\n  2      3 c_1_2_3        199         72        4455       29720\n  2      3 c_1_2_3        186         66        4442       29726\n  2      3 c_1_2_3        182         64        4438       29728\n  2      3 c_1_2_3        179         62        4435       29730\n  2      3 c_1_2_3        176         31        4432       29761\n  2      3 c_1_2_3        176          4        4432       29788\n  2      3 c_1_2_3        179          0        4435       29792\n\n\n\n\n\n\n\n\nReferences\n\nFu, Xiaohang, Yingxin Lin, David M. Lin, Daniel Mechtersheimer, Chuhan Wang, Farhan Ameen, Shila Ghazanfar, Ellis Patrick, Jinman Kim, and Jean Y. H. Yang. 2024. “BIDCell: Biologically-Informed Self-Supervised Learning for Segmentation of Subcellular Spatial Transcriptomics Data.” Nature Communications 15 (January): 509. https://doi.org/10.1038/s41467-023-44560-w.\n\n\nHe, Shanshan, Ruchir Bhatt, Carl Brown, Emily A Brown, Derek L Buhr, Kan Chantranuvatana, Patrick Danaher, et al. 2022. “High-Plex Imaging of RNA and Proteins at Subcellular Resolution in Fixed Tissue by Spatial Molecular Imaging.” Nature Biotechnology 40 (December): 1794–1806. https://doi.org/10.1038/s41587-022-01483-z."
  },
  {
    "objectID": "posts/cellular-neighborhoods/cellular-neighborhoods.html",
    "href": "posts/cellular-neighborhoods/cellular-neighborhoods.html",
    "title": "Cellular neighborhoods: a useful, simple and flexible analysis framework",
    "section": "",
    "text": "The field of spatial analysis offers a growing array of sophisticated tools, including graphical neural networks, Fourier transforms, hidden Markov random fields. While these methods offer potential advantages in performance, simpler techniques have their own merit: they make analyses easier to understand, both for analysts and for their eventual audiences. In this spirit, we recommend “cellular neighborhoods” as an framework for diverse analyses. This framework offers a balance of flexibility, computational efficiency, and ease of use, making it a valuable tool for researchers.\nCellular neighborhood analysis begins with two steps:\n\nDefine each cell’s neighboring cells.\nCreate a new matrix encoding cells’ “spatial contexts”. To do this, we compute summaries of each cell’s neighbors, reporting for example their average expression profile or the abundance of different cell types within them.\n\n\n\n\n\n\nLeft: example of a cellular neighborhood defined as a cell’s 50 nearest neighbors. Right: the mean expression profile of those neighbors is used to define the cell’s spatial context. This ‘mean neighborhood expression’, calculated separately for all cells in the dataset, defines a new data matrix.\n\n\n\n\nOnce we’ve obtained a matrix of spatial context data, myriad analyses become possible. We can:\n\nPlot spatially smoothed expression to make spatial expression patterns for visually clear\nDerive spatial clusters / niches\nFind spatially auto-correlated genes / sets of genes\nSet up interesting differential expression problems, asking how cells modulate expression in response to their spatial context\nExplore ligand-receptor interactions\n\nMany of these analyses are achieved by simply applying techniques from single cell analyses, for example clustering the rows (cells) or columns (genes) of the matrix."
  },
  {
    "objectID": "posts/cellular-neighborhoods/cellular-neighborhoods.html#defining-a-cells-neighbors",
    "href": "posts/cellular-neighborhoods/cellular-neighborhoods.html#defining-a-cells-neighbors",
    "title": "Cellular neighborhoods: a useful, simple and flexible analysis framework",
    "section": "2.1 Defining a cell’s neighbors",
    "text": "2.1 Defining a cell’s neighbors\nConvenient approaches to define a cell’s neighbors include the “K-nearest” approach (we usually use the nearest 50 neighbors) and a radius-based approach. We prefer the K-nearest neighbors approach, mainly because radius-based neighborhoods tend to vary widely in the number of cells they contain, and neighborhoods of very few cells are statistically unstable.\nThe size of a neighborhood is up to the analyst’s discretion. Try to choose a neighborhood size that reflects your understanding of biology and that makes sense for your biological question. There is a Goldilocks zone, however: very small neighborhoods produce sparse and noisy data, and very large neighborhoods become inaccurate representations of a cell’s 3D surroundings.\n\n\n\n\n\n\nNote\n\n\n\nThe problem with large neighborhoods: the area of your circular neighborhood increases with the square of the radius, but the volume of the corresponding (unobserved) 3D tissue region increases with the cube of the radius. This means that the larger the radius, the less of your 3D neighborhood falls in the narrow tissue slide you’ve assayed, and the more it consists of unseen cells increasingly far away in the Z-dimension.\n\n\nHere’s code for defining cellular neighborhoods:\n\n# define neighbors using a K-nearest approach:\nneighbors.nearest50 &lt;- nearestNeighborGraph(x = xy[, 1], y = xy[, 2], N = 50)\n\n# define using a radius-based approach:\nneighbors.radiusbased &lt;- radiusBasedGraph(x = xy[, 1], y = xy[, 2], R = 0.05)\n\n# the output is a sparse matrix of cells * cells:\nstr(neighbors.nearest50)\n\nFormal class 'dgCMatrix' [package \"Matrix\"] with 6 slots\n  ..@ i       : int [1:327750] 1 22 30 40 54 59 62 63 73 78 ...\n  ..@ p       : int [1:6556] 0 29 60 89 114 141 181 207 239 276 ...\n  ..@ Dim     : int [1:2] 6555 6555\n  ..@ Dimnames:List of 2\n  .. ..$ : NULL\n  .. ..$ : NULL\n  ..@ x       : num [1:327750] 0.0603 0.0405 0.0135 0.0379 0.0179 ...\n  ..@ factors : list()\n\n# compare the number of neighbors found by each approach:\nsummary(Matrix::rowSums(neighbors.nearest50))\n\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n  1.230   1.595   1.742   1.784   1.927   5.360 \n\nsummary(Matrix::rowSums(neighbors.radiusbased))\n\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n  0.000   1.234   1.514   1.512   1.781   2.772 \n\n\n\n2.1.1 Subsampling neighbors to minimize spatial auto-correlation\nAn occasionally important detail:\nIn “Mitigating autocorrelation during spatially resolved transcriptomics data analysis”, Maher et al. (2023) describe an inconvenient tendency of spatial context matrices: because neighboring cells have largely the same neighbors, their entries in the spatial context matrix are correlated. This correlation between neighbors proves a substantial barrier to distance-based analyses like UMAP or Leiden clustering, producing UMAPs where all points fall in a highly-connected blob and generally poor Leiden performance. (However, for most analyses, correlation between neighboring cells’ spatial context vectors doesn’t seem to have much impact.) They propose that by defining each cell’s neighborhood as a random subset of its nearest neighbors, they can largely break this correlation between neighbors. They released a python toolkit for this, SPIN.\nFor R coders, here’s how you would get a neighborhood matrix with random subsetting:\n\nsubsetted_neighbors &lt;- subsampleNeighborsByRow(neighbors = neighbors.nearest50, p = 0.5)\nsummary(Matrix::rowSums(subsetted_neighbors))\n\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n 0.5635  0.7936  0.8712  0.8922  0.9668  2.7334"
  },
  {
    "objectID": "posts/cellular-neighborhoods/cellular-neighborhoods.html#summarizing-a-cells-neighbors-to-define-its-spatial-context",
    "href": "posts/cellular-neighborhoods/cellular-neighborhoods.html#summarizing-a-cells-neighbors-to-define-its-spatial-context",
    "title": "Cellular neighborhoods: a useful, simple and flexible analysis framework",
    "section": "2.2 Summarizing a cell’s neighbors to define its spatial context",
    "text": "2.2 Summarizing a cell’s neighbors to define its spatial context\nUsually, you’ll employ one of two approaches:\n\nReport the average expression of neighborhood cells\nReport the cell type abundances within the neighborhood cells\n\nBut more bespoke options are possible. For example, you could:\n\nOnly record expression of known ligands, under the theory that they’re mainly responsible for cell-cell communication.\nOnly record genes from a pathway of interest\nRecord QC metrics like the rate of flagged cells, or total counts per cell, or total negprobe counts per cell.\nCreate a hybrid matrix including both cell type abundances and expression of selected genes.\nInstead of computing means, look at SD or covariance of gene expression within a neighborhood.\n\nThe main takeaway here is that once you’ve defined cellular neighborhoods, it’s incredibly simply to extract all manner of variables from them, giving you great flexibility in how you pose biological questions.\nYou can implement the basic formats of spatial context matrices as follows:\n\n# mean neighborhood expression:\nspatialcontext_expression &lt;- get_neighborhood_expression(counts, neighbors.nearest50)\n# mean cell type abundances:\nspatialcontext_celltypes &lt;- neighbor_tabulate(annot$celltype, neighbors.nearest50)\n\n# spatial context matrices are dense:\nstr(spatialcontext_expression)\n\n num [1:6555, 1:11] 0.16 0.24 0.4 0.28 0.22 0.4 0.32 0.38 0.28 0.34 ...\n - attr(*, \"dimnames\")=List of 2\n  ..$ : NULL\n  ..$ : chr [1:11] \"ITGAV\" \"ITGA3\" \"SPOCK2\" \"SPP1\" ...\n\nstr(spatialcontext_celltypes)\n\n num [1:6555, 1:26] 24 34 17 36 29 11 36 35 19 39 ...\n - attr(*, \"dimnames\")=List of 2\n  ..$ : NULL\n  ..$ : chr [1:26] \"PCT\" \"Parietal.epithelium\" \"Connecting.tubule\" \"Type.B.intercalated.cell\" ..."
  },
  {
    "objectID": "posts/napari-rois/cosmx-rois.html",
    "href": "posts/napari-rois/cosmx-rois.html",
    "title": "Defining Regions of Interest in CosMx® SMI data using napari",
    "section": "",
    "text": "I am consistently impressed by the remarkable cellular resolution, sensitivity, and comprehensive spatial profiling capabilities that CosMx® SMI technology offers. Indeed, I often analyze datasets that consist of 10s of slides and millions of cells – numbers that are steadily growing with time.\nAt several points in my analysis workflow I need to subset the data. For example, I may want to examine a specific niche or ask what the molecular composition of each kidney glomerulus looks like. While some of these subsets can be achieved by computational means, there are some scenarios where I isolate specific regions or specific cells by directly selecting them on the tissue. I refer to this as selecting Regions of Interest (ROIs).\nIn this post, I will show you how to define ROIs using the napari-cosmx plugin. In a future post, we’ll show a similar approach using R.\n\n\nThis is the fourth installment of our napari series. Readers should be familiar with the napari-cosmx plugin and the basics. I’ll also make use of the python interpreter and users may benefit from reviewing the post on stitching before reading further.\n\nSection 2 shows a step-by-step guide to create ROIs. It starts with a simple polygon followed by adding additional code to make the process of ROI creation more automated via keyboard shortcuts.\nSection 3 shows another way to selection “ROIs” and that’s by selecting individual cells."
  },
  {
    "objectID": "posts/napari-rois/cosmx-rois.html#preliminaries",
    "href": "posts/napari-rois/cosmx-rois.html#preliminaries",
    "title": "Defining Regions of Interest in CosMx® SMI data using napari",
    "section": "",
    "text": "This is the fourth installment of our napari series. Readers should be familiar with the napari-cosmx plugin and the basics. I’ll also make use of the python interpreter and users may benefit from reviewing the post on stitching before reading further.\n\nSection 2 shows a step-by-step guide to create ROIs. It starts with a simple polygon followed by adding additional code to make the process of ROI creation more automated via keyboard shortcuts.\nSection 3 shows another way to selection “ROIs” and that’s by selecting individual cells."
  },
  {
    "objectID": "posts/napari-rois/cosmx-rois.html#more-efficient-roi-creation",
    "href": "posts/napari-rois/cosmx-rois.html#more-efficient-roi-creation",
    "title": "Defining Regions of Interest in CosMx® SMI data using napari",
    "section": "2.1 More efficient ROI creation",
    "text": "2.1 More efficient ROI creation\nThere are many nodules in this sample. While the process of creating an ROI is simple, this manual process can take time. It can be more efficient to look at computational approaches like defining these nodules based on shared cell type composition (i.e., niche). But if we still want fine control of the ROIs, we can speed up this process by creating a few helper functions that do many of these steps for us.\nIn the code below, we are creating a keyboard shortcut that will create a new shapes layer simply by pressing n on your keyboard. The new layer will be named ROI001 if it’s the first one; otherwise, it will add an integer to the ROI name (ROI002, ROI003…). After creating a new layer, pressing p will activate the polygon tool allowing you to select the vertices of a given polygon. Double-clicking the last vertex will “close” the polygon.\n\n\n\n\n\n\nTip\n\n\n\nI tend to keep the shapes layer inactive whenever possible. This limits the number of accidental vertex additions to a shape.\n\n\nHere’s the code. Be sure to add the shortcut definitions after creating the gem object. You can change the color and edge width to any valid value. Here I’ll make the border yellow with a width of 100.\n\ndef find_next_roi(my_list):\n  \"\"\"Finds the next ROI code in a list of ROI strings.\n\n  Args:\n      my_list: A list of strings in the format \"ROIxxx\" where xxx are digits.\n\n  Returns:\n      The next ROI code in the sequence, or \"ROI001\" if the list is empty \n      or the next sequential code if no gap is found.\n  \"\"\"\n\n  if not my_list:  # Handle empty list\n    return \"ROI001\"\n\n  # Extract numeric parts and convert to integers\n  numbers = [int(item[3:]) for item in my_list]\n\n  # Sort the numbers in ascending order\n  numbers.sort()\n\n  # Find the first gap in the sequence\n  for i in range(len(numbers) - 1):\n    if numbers[i + 1] - numbers[i] &gt; 1:\n      next_number = numbers[i] + 1\n      return f\"ROI{next_number:03d}\"\n\n  # If no gap is found, return the next sequential number\n  next_number = numbers[-1] + 1  # Get the last number and increment\n  return f\"ROI{next_number:03d}\"\n\n# This keybinding makes it easier to create a new shape layer for ROIs\n@gem.viewer.bind_key('n', overwrite=True)\ndef new_roi_layer(viewer):\n    # Search layers for \"ROI\" pattern\n    layers = viewer.layers\n    names = [x.name for x in layers]\n    names_filtered = [item for item in names if \"ROI\" in item]\n    new_roi_name = find_next_roi(names_filtered)\n    print(f\"Creating {new_roi_name} layer.\")\n    viewer.add_shapes(\n        shape_type='polygon',\n        scale = [gem.mm_per_px, gem.mm_per_px],\n        name=new_roi_name,\n        face_color='transparent',\n        edge_color='yellow',\n        edge_width=100\n    )\n\nIn the video below, I am quickly creating a new shapes layer using the keyboard combination n + p.\n\n\n\nAnd now that I have four ROIs, I can save them like this:\nN=4\nroi_list = ['ROI'+str(i).zfill(3) for i in range(1, N+1)]\ngem.save_layers(roi_list, \"path/to/output/data\")"
  },
  {
    "objectID": "posts/napari-rois/cosmx-rois.html#subsetting-based-on-rois",
    "href": "posts/napari-rois/cosmx-rois.html#subsetting-based-on-rois",
    "title": "Defining Regions of Interest in CosMx® SMI data using napari",
    "section": "2.2 Subsetting Based on ROIs",
    "text": "2.2 Subsetting Based on ROIs\nWhat we would like to do now is to identify which of the cells are in each of these polygons. There’s a method available in napari-cosmx to do just that.\nUsing the roi_list list we created above, we can generate a Boolean column in the metdata for all of the ROIs.\n\n\n\n\n\n\nNote\n\n\n\nDepending on the size of the sample, the size of the ROI(s), and your hardware, this process can be computationally intense.\n\n\nnew_metadata = gem.layers_to_metadata(roi_list)\n\nnew_metadata\n               cell_ID    cell_type initial_cell_type  ...  ROI002  ROI003  ROI004\nUID                                                    ...                        \n10101        c_1_100_1     B cell 1          B cell 1  ...   False   False   False\n10200      c_1_100_100   CD4 T cell        CD4 T cell  ...   False   False   False\n1000100   c_1_100_1000     B cell 1          B cell 1  ...   False   False   False\n1002101   c_1_100_1001   CD4 T cell        CD4 T cell  ...   False   False   False\n1004104   c_1_100_1002     B cell 1          B cell 1  ...   False   False   False\n...                ...          ...               ...  ...     ...     ...     ...\n350859     c_1_395_592   CD4 T cell        CD4 T cell  ...   False   False   False\n20457783  c_1_254_4523     B cell 1          B cell 1  ...   False   False   False\n3261907   c_1_271_1806     B cell 2          B cell 2  ...   False   False   False\n4670103   c_1_182_2161  plasma cell       plasma cell  ...   False   False   False\n25664444   c_1_88_5066  plasma cell       plasma cell  ...   False   False   False\n\n\n\n\n\n\nTip\n\n\n\nRecall that you can save your new metadata file to disk so that it can be used later with the color cells widget. (e.g., new_metadata.to_csv(\"_new_metadata.csv\", index=False)).\n\n\nROIs can be hierarchical. For example, one can create concentric rings around a focal region. So a given cell can be True for multiple ROIs.\nIf you prefer to have these extra columns converted into a single column with the name of the ROI a given cell is found in, you can use this function.\n\n\ndef generate_roi_summary_column(df):\n    \"\"\"\n    Generates a 'ROI' column based on all ROI columns in the dataframe and removes the individual ROI columns.\n\n    Args:\n        df: The pandas dataframe containing ROI columns.\n\n    Returns:\n        The updated dataframe with the 'ROI' summary column and individual ROI columns removed.\n    \"\"\"\n\n    # Get all columns that start with 'ROI'\n    roi_cols = [col for col in df.columns if col.startswith('ROI')]\n\n    # Filter dataframe to only include ROI columns\n    roi_df = df[roi_cols]\n\n    # Create a new column 'ROI' and initialize it with None\n    df['ROI'] = None\n\n    # Iterate over each row\n    for index, row in roi_df.iterrows():\n        # Check if all values in the row are False\n        if not any(row):\n            continue  # Keep 'ROI' as None\n\n        # If there's at least one True, find the first column name where it's True\n        for col in roi_cols:\n            if row[col]:\n                df.loc[index, 'ROI'] = col\n                break\n\n    # Drop the ROI columns\n    df.drop(columns=roi_cols, inplace=True)\n\n    return df\nHere’s a tabulation of the number of cells found in each ROI in this example.\n\nmeta_summary = generate_roi_summary_column(new_metadata)\n\nmeta_summary.ROI.value_counts()\nROI\nROI001    13503\nROI003     8536\nROI002     7686\nROI004     5721\nName: count, dtype: int64\nAs you can see in the code above, in the case you have hierarchial ROIs, a given cell that is present in multiple ROIs will be assigned the first ROI in the list."
  },
  {
    "objectID": "posts/insitucor/index.html",
    "href": "posts/insitucor/index.html",
    "title": "InSituCor: an open-source package and AtoMx custom module for exploratory data analysis",
    "section": "",
    "text": "Background\nWe developed InSituCor as a tool for exploratory analysis of CosMx data; it has since become a mainstay of our in-house analyses. InSituCor reports on modules of “spatially correlated” genes, i.e. genes that tend to be expressed in the same tissue regions as each other. We have found it to be a consistently useful tool for discovering unexpected relationships in CosMx data.\nInSituCor makes one important contribution to the spatial correlation field: it isolates correlations that can’t be explained by the cell type landscape alone. While the results of legacy methods are dominated by uninteresting results (e.g., “all the plasma cell markers are spatially correlated with each other”), InSituCor ignores these trivial findings, returning a more concise, and much more interesting manifest of spatial correlations.\nInSituCor is available as both an R package and a custom module for AtoMx.\n\n\nResources\n\nOur very succinct preprint\nThe InSituCor R package\nAn AtoMx custom module implementing InsituCor"
  },
  {
    "objectID": "posts/cell-typing-strategies/cell-typing-strategies.html",
    "href": "posts/cell-typing-strategies/cell-typing-strategies.html",
    "title": "Cell typing: advanced strategies",
    "section": "",
    "text": "Background\nCell typing is always critical and occasionally difficult. Here we’ll discuss what to do when straightforward approaches fail.\nBefore exploring the options here, you should:\n\nAttempt the standard approaches - InSituType, Leiden clustering and label transfer.\nIf you’re using InSituType, attempt the workflows described in the InSituType FAQS. This last document provides detailed guidance on using InSituType’s many options, and its contents should be enough to guide you through most cell typing exercises.\nConfirm your cell segmentation was successful. Use AtoMx or your favorite viewer to confirm that segmentation errors aren’t widespread.\n\nIn this document, we’ll address four common difficulties:\n\nFine subtyping, especially for immune cells\nCell typing based on marker genes\nStudies with batch effects\nFailure to find anchor cells / difficulties mapping reference profiles\nReference cell types claiming the wrong cells\n\n\n\nFine subtyping: take a hierarchical approach and rely on gene selection\nBroad cell typing, e.g. discerning cancer cells vs. fibroblasts vs. immune cells, does best using a large number of genes - the whole panel for 1k data, and at least half the 6k panel. But when we turn to fine subtyping, e.g. discerning CD4 T-cells vs. Tregs, a much smaller gene set is relevant. If we use a complete high-plex panel for this problem, we’ll rely on potentially thousands of unhelpful genes: genes that are mainly in the background for our cell types of interest, genes for which cell segmentation errors have introduced high levels of contaminating signal into our cell types of interest, and genes with minimal variability among our cell types of interest. These genes make fine cell typing harder by introducing noise, or, in the case of segmentation errors, bias. You may find your subclusters to be driven by sample ID or by spatial context.\nThe solution is simple: after establishing your broad cell types, perform fine cell typing among related cell types using a useful subset of genes. Hierarchical approaches like this are common in the single cell world. Defining the “useful subset of genes” is straightforward: we want genes that differ meaningfully between our closely-related cell types, and we want to avoid genes at risk of contamination from segmentation errors. We advise using a generous gene list: including at least 1/3-1/2 of the genes in the 1k and 6k panels seems to work well.\nThe below code shows how this approach would work for supervised cell typing. Here, we’ll perform just one filter, removing genes at risk of bias from cell segmentation errors:\n\n#### assumed data ---------------------------------------\n# xy: 2-column matrix of cells' xy positions\n# refprofiles: matrix of expected expression in genes * cells types, as \n#   is expected by InSituType.\n# counts: counts matrix, cells * genes.\n# clust: vector of broad cell type assignments.\n\n#### source functions for gene selection --------------------------------------- \n\nsource(url(\"https://github.com/Nanostring-Biostats/CosMx-Analysis-Scratch-Space/tree/Main/_code/cell-typing-advanced-strategies/getSubtypingGenes.R\"))\n# (if the above doesn't work, just download the file at that url then source it locally)\n\n#### supervised subtyping workflow ---------------------------------------\n\n## get genes safe from contamination:\nsafegenes &lt;- findSafeGenes(\n  counts = counts,                    # note we're entering info for all cells           \n  xy = xy,                            # again entering info for all cells\n  ismycelltype = (clust == \"T-cell\"), # logical indicating the cells to subtype\n  tissue = NULL,                      # specify if tissues have xy overlap\n  self_vs_neighbor_threshold = 1.75   # min ratio of expression in the cell type vs. in its neighbors\n  )$safegenes            \n\nmessage(print0(length(safegenes), \" genes kept from a panel of \", ncol(counts), \". Try to use at least 1/3 the panel.\"))\n\n## supervised subtyping of T-cells:\nres &lt;- insitutype(\n  x = counts[sub, ],\n  reference_profiles = refprofiles[Tcellgenes, c(\"CD4\", \"CD8\", \"Treg\")],\n  n_clusts = 0)\n\n## update the cluster assignments:\nclust[sub] &lt;- res$clust\n\nAnd for unsupervised clustering, we’ll filter on both risk of segmentation errors and for informativeness in our data. For “informativeness”, we’ll search for highly variable genes, as described by Stuart et al. (2019), and implemented in Seurat::FindVariableFeatures.\n\n#### assumed data ---------------------------------------\n# xy: 2-column matrix of cells' xy positions\n# refprofiles: matrix of expected expression in genes * cells types, as \n#   is expected by InSituType.\n# counts: counts matrix, cells * genes.\n# clust: vector of broad cell type assignments.\n\n#### source functions for gene selection --------------------------------------- \n\nsource(url(\"https://github.com/Nanostring-Biostats/CosMx-Analysis-Scratch-Space/tree/Main/_code/cell-typing-advanced-strategies/getSubtypingGenes.R\"))\n# (if the above doesn't work, just download the file at that url then source it locally)\n\n#### unsupervised subclustering workflow ---------------------------------------\n\n## get genes safe from contamination:\nsafegenes &lt;- findSafeGenes(\n  counts = counts,                    # note we're entering info for all cells           \n  xy = xy,                            # again entering info for all cells\n  ismycelltype = (clust == \"T-cell\"), # logical indicating the cells to subtype\n  tissue = NULL,                      # specify if tissues have xy overlap\n  self_vs_neighbor_threshold = 1.75   # min ratio of expression in the cell type vs. in its neighbors\n  )$safegenes           \n\n## Get highly variable genes in your subset:\nsub &lt;- clust == \"T-cell\"                                 \nsubsetHVGs &lt;- getSubclusteringGenes(\n  mat = counts[sub, ],     # raw counts from only the cell type of interest\n  varratiothresh = 1,      # how much var beyond what mean expression predicts\n  expressionthresh = 0.2)  # min expression level\n\n## keep genes meeting both the above criteria:\nusegenes &lt;- intersect(subsetHVGs, safegenes)\nmessage(print0(length(usegenes), \" genes kept from a panel of \", ncol(counts), \". Try to use at least 1/3 the panel.\"))\n\n## supervised subtyping of T-cells:\nres &lt;- insitutype(\n  x = counts[sub, usegenes],\n  n_clusts = 4)\n\n## update the cluster assignments:\nclust[sub] &lt;- paste0(\"T-cell cluster \", res$clust)\n\n\n\nCell typing based on marker genes\nWe generally advise against relying on raw marker gene expression for cell typing. However, a marker-centered view can occasionally be appropriate. For example, you might insist on only restricting your analysis to Treg’s to cells that are demonstrably FOXP3+. If you do want to base your cell typing on a marker gene, we recommend using smoothing/imputation to get cleaner marker gene expression values. The idea is to obtain more accurate expression values for a marker gene by borrowing information from other genes in its profile. This intuition is simple: if you see FOXP3 expression in all the cells with highly similar expression profiles to a cell in question, then the cell in question is very probably FOXP3+ itself, whether or not you observed any FOXP3 counts in it. Or, more formally, this approach negotiates a favorable variance-bias tradeoff: in this example, we bias cells’ FOXP3 expression values to resemble their nearest neighbors in expression space, while greatly reducing sampling variability compared to that of a single gene’s count value.\nWe demonstrate a smoothing/imputation approach to marker genes here. You can also use SAVER (Huang et al, 2018) or scImpute (Li & Li, 2018) or any of the many other published single cell imputation methods. Do note that performing deeper analyses of imputed expression values, e.g. differential expression testing, is hazardous (Andrews & Hemberg, 2019), though imputed counts can be useful for plotting.\n\n\nBatch effects: well-considered workflows\nInSituType is quite, but not completely, robust to batch effects. Leiden clustering and other methods relying on principal components of the data can be highly sensitive to them. If you see evidence of batch effects in your data, for example strong batch dependence in your cell typing results or your UMAP projection, consider the below strategies.\n\nUnsupervised clustering: InSituType will generally work even in the presence of batch effects. To run Leiden clustering, just begin by using any standard batch-correction method, e.g. Harmony (Korsunsky et al, 2019). Seurat’s label transfer functions offer another approach. Batch corrected data isn’t well-suited InSituType, which ingests raw data.\nSupervised cell typing with InSituType: run InSituType separately on each tissue/batch, using the rescale=TRUE option. This will perform a batch adjustment from the reference to each new tissue. We used this approach successfully in a study of lupus nephritis (Danaher et al., 2024). You can see the code we used here.\nSemi-supervised cell typing with InSituType: initially analyze a single batch of data. Once you’re satisfied that you’ve captured all the unknown and reference cell types in that batch, use it to derive a new reference matrix (use InSituType::getRNAprofiles). Then apply the above supervised cell typing strategy using this reference matrix.\n\n\n\nFailure to find anchor cells\nInSituType has the option of using anchor cells to calibrate reference profiles for CosMx data. This calibration is generally helpful for supervised cell typing and usually essential for semi-supervised cell typing, at least if the reference came from scRNA-seq data. (For details on this calibration, see the “Updating reference profiles” section of the InSituType FAQs.)\nSometimes, InSituType will fail to discover enough “anchor cells” to perform this calibration. In this case, there are several simple next steps.\n\nLower the thresholds for anchor selection (min_anchor_cosine and min_anchor_llr). This is often needed in high-plex studies - the defaults were optimized for 1000-plex data.\nIf you only find anchors for a few cell types: use rescale = TRUE, refit = FALSE. This performs a softer calibration: it rescales each row/gene of the reference matrix, but doesn’t fully refit each profile. This operation can be powered using only a few cell types.\nIf you have a whole single cell reference dataset, not just profiles, then try a label transfer algorithm, e.g. Seurat’s or MaxFuse (Chen et al 2023). If you do cell type with label transfer, then using InSituType::spatialUpdate can further improve these initial results.\n\n\n\nReference cell types claiming the wrong cells\nInSituType will occasionally assign a cell type to the wrong reference profile, e.g. we’ve seen some cancer cells get assigned to the “NK cells” profiles. Fortunately, this kind of event is easy to detect with even cursory QC of your cell type results, and easy to fix: just use InSituType::refineClusters. Correcting this kind of error should be thought of as a part of routine human-guided cell typing, an operation to perform alongside all the other renaming, merging, and subclustering operations performed with refineClusters.\n\n\nReferences\n\nStuart T, Butler A, Hoffman P, Hafemeister C, Papalexi E, Mauck WM, Hao Y, Stoeckius M, Smibert P, Satija R. Comprehensive integration of single-cell data. cell. 2019 Jun 13;177(7):1888-902.\nDanaher P, Hasle N, Nguyen ED, Roberts JE, Rosenwasser N, Rickert C, Hsieh EW, Hayward K, Okamura DM, Alpers CE, Reed RC. Childhood-onset lupus nephritis is characterized by complex interactions between kidney stroma and infiltrating immune cells. Science Translational Medicine. 2024 Nov 27;16(775):eadl1666.\nKorsunsky I, Millard N, Fan J, Slowikowski K, Zhang F, Wei K, Baglaenko Y, Brenner M, Loh PR, Raychaudhuri S. Fast, sensitive and accurate integration of single-cell data with Harmony. Nature methods. 2019 Dec;16(12):1289-96.\nHuang M, Wang J, Torre E, Dueck H, Shaffer S, Bonasio R, Murray JI, Raj A, Li M, Zhang NR. SAVER: gene expression recovery for single-cell RNA sequencing. Nature methods. 2018 Jul;15(7):539-42.\nLi WV, Li JJ. An accurate and robust imputation method scImpute for single-cell RNA-seq data. Nature communications. 2018 Mar 8;9(1):997.\nAndrews TS, Hemberg M. False signals induced by single-cell imputation. F1000Research. 2019 Mar 5;7:1740.\nChen S, Zhu B, Huang S, Hickey JW, Lin KZ, Snyder M, Greenleaf WJ, Nolan GP, Zhang NR, Ma Z. Integration of spatial and single-cell data across modalities with weakly linked features. Nature Biotechnology. 2024 Jul;42(7):1096-106."
  },
  {
    "objectID": "posts/insitudiff/index.html",
    "href": "posts/insitudiff/index.html",
    "title": "InSituDiff: perturbation analysis for spatial transcriptomics",
    "section": "",
    "text": "Background\nA typical study design will contrast several disease or treated samples with one or more controls. In these studies, it can be difficult to identify the (interesting) ways in which the disease samples are perturbed compared to the controls. To this end, we have created an R package, “InSituDiff”, containing a suite of tools for exploring how cellular neighborhoods are perturbed in disease compared to controls.\nThe heart of InSituDiff is the measurement of how “cellular neighborhoods” (a target cell and its nearest neighbors) contrast with their most similar control cellular neighborhood. This analysis produces a perturbation score for all cells * genes. With these perturbation scores in hand, numerous useful analyses become possible:\n\nSpatial maps of gene perturbation scores are often more informative than maps of expression level.\nWe can identify highly perturbed genes, and we can quantify the spatial dependence of their perturbations.\nBy applying spatial clustering algorithms to the perturbation matrix, we can discover distinct impacts of disease across the span of tissues.\nBy clustering genes’ perturbation values, we discover sets of genes with spatially correlated perturbations.\n\nThe above suite of analyses very quickly brings the major impacts of disease into focus. Conveniently, this analysis is agnostic to your cell typing results, making it a plausible tool for first-pass data exploration.\n\n\nResources\nThe InSituDiff R package\nSee the package vignette for a demonstration of the workflow."
  },
  {
    "objectID": "posts/visuals-reduce-whitespace/index.html",
    "href": "posts/visuals-reduce-whitespace/index.html",
    "title": "Functions for condensing FOVs and tissues to minimize whitespace",
    "section": "",
    "text": "Minimizing whitespace while plotting cells in xy space is a constant challenge. A single tissue will often have discontinuous FOVs, and aligning multiple tissues in a sensible way can be onerous.\nHere, for example, are FOVs collected from core needle biopsies, where the cells can barely be seen against the vast expanse of white space.\n\nAs a partial solution, see the function consenseXY(), provided here.\nThe main wrapper function contains an algorithm for pulling together FOVs from the same tissue, and an algorithm for tiling tissues across a plot.\nHere’s a toy example of FOV groups from two tissues before and after the algorithm (color denotes tissue ID):\n\nIt’s not perfect, but it’s an improvement on the original spacing with no thought or manual labor.\nWarning: the FOV condensing code is inefficiently written and takes longer than it should, though it’s still faster than working by hand."
  },
  {
    "objectID": "posts/visuals-reduce-whitespace/index.html#condensing-cells-in-xy-space-for-better-plotting",
    "href": "posts/visuals-reduce-whitespace/index.html#condensing-cells-in-xy-space-for-better-plotting",
    "title": "Functions for condensing FOVs and tissues to minimize whitespace",
    "section": "",
    "text": "Minimizing whitespace while plotting cells in xy space is a constant challenge. A single tissue will often have discontinuous FOVs, and aligning multiple tissues in a sensible way can be onerous.\nHere, for example, are FOVs collected from core needle biopsies, where the cells can barely be seen against the vast expanse of white space.\n\nAs a partial solution, see the function consenseXY(), provided here.\nThe main wrapper function contains an algorithm for pulling together FOVs from the same tissue, and an algorithm for tiling tissues across a plot.\nHere’s a toy example of FOV groups from two tissues before and after the algorithm (color denotes tissue ID):\n\nIt’s not perfect, but it’s an improvement on the original spacing with no thought or manual labor.\nWarning: the FOV condensing code is inefficiently written and takes longer than it should, though it’s still faster than working by hand."
  },
  {
    "objectID": "posts/pearsonpca/index.html",
    "href": "posts/pearsonpca/index.html",
    "title": "scPearsonPCA: An R package for efficient Principal Components decomposition of pearson residual normalized single cell data",
    "section": "",
    "text": "Here we present a package for better dimension reduction in spatial data. Pearson residuals can be an effective normalization method for spatially-resolved transcriptomic data. However, the normalized data matrix produced is dense with nearly all values non-zero. This limits the usability of pearson residuals for high-plex or large datasets where computing memory can be a limiting factor.\nHowever, the principal component (PC) decomposition of quasi-poisson pearson residuals can be computed directly from a sparse counts matrix and a few easy-to-calculate summary statistics. The R package scPearsonPCA enables this PC decomposition, including the returning the PCs as if the normalized data had been centered, scaled, and influential values clipped according to common best practices for PC analysis.\nIn this post we demonstrate a few quick examples for the package, as well as how to use the PCA results returned for common downstream analyses like UMAP and unsupervised clustering."
  },
  {
    "objectID": "posts/pearsonpca/index.html#introduction",
    "href": "posts/pearsonpca/index.html#introduction",
    "title": "scPearsonPCA: An R package for efficient Principal Components decomposition of pearson residual normalized single cell data",
    "section": "",
    "text": "Here we present a package for better dimension reduction in spatial data. Pearson residuals can be an effective normalization method for spatially-resolved transcriptomic data. However, the normalized data matrix produced is dense with nearly all values non-zero. This limits the usability of pearson residuals for high-plex or large datasets where computing memory can be a limiting factor.\nHowever, the principal component (PC) decomposition of quasi-poisson pearson residuals can be computed directly from a sparse counts matrix and a few easy-to-calculate summary statistics. The R package scPearsonPCA enables this PC decomposition, including the returning the PCs as if the normalized data had been centered, scaled, and influential values clipped according to common best practices for PC analysis.\nIn this post we demonstrate a few quick examples for the package, as well as how to use the PCA results returned for common downstream analyses like UMAP and unsupervised clustering."
  },
  {
    "objectID": "posts/pearsonpca/index.html#installation",
    "href": "posts/pearsonpca/index.html#installation",
    "title": "scPearsonPCA: An R package for efficient Principal Components decomposition of pearson residual normalized single cell data",
    "section": "2 Installation",
    "text": "2 Installation\nYou can install scPearsonPCA using the remotes package\n\nremotes::install_github(\"Nanostring-Biostats/CosMx-Analysis-Scratch-Space\",\n                         subdir = \"_code/scPearsonPCA\", ref = \"Main\")"
  },
  {
    "objectID": "posts/pearsonpca/index.html#most-used-functions",
    "href": "posts/pearsonpca/index.html#most-used-functions",
    "title": "scPearsonPCA: An R package for efficient Principal Components decomposition of pearson residual normalized single cell data",
    "section": "3 Most used functions",
    "text": "3 Most used functions\n\nsparse_quasipoisson_pca_seurat() This function takes a counts matrix as input and returns a PCA Seurat-style reduction by default. The PCA is based on quasi-poisson pearson residual normalization. Similar to a NormalizeData \\(\\rightarrow\\) ScaleData \\(\\rightarrow\\) RunPCA workflow, arguments available for returning the PCA as if data were centered and scaled, with extreme values clipped.\nsparse_quasipoisson_pca_seurat_batch() This function employs a batch-correction method to PCA, provided there is a single categorical variable for ‘batch’. Examples could be ‘patient’, ‘slide_id’, ‘tma_id’, etc. Akin to a quasipoisson glm-based correction with the batch variable used as a covariate, the basic idea here is that gene frequencies are computed separately by batch rather than across the full sample.\nsparse_quasipoisson_pca_seurat_multiomic() This function is useful for getting the PCA decomposition from same-cell multiomic data. Here we assume we have two matrices, a sparse RNA counts matrix x, and a (possibly dense,lower dimensional) matrix of already-normalized protein expression xother. We want to be able to get PCA from the combined dataset, while still applying effective normalization to the RNA data. This function uses similar algebraic shortcuts which allow for efficient calculation of PCA from the covariance matrix of pearson residuals from the RNA, by deriving PCA from the combined covariance matrix of pre-normalized protein, and pearson-normalized RNA. We’ll demo a full example below using a multiomics breast cancer dataset."
  },
  {
    "objectID": "posts/pearsonpca/index.html#quickstart-example-usage",
    "href": "posts/pearsonpca/index.html#quickstart-example-usage",
    "title": "scPearsonPCA: An R package for efficient Principal Components decomposition of pearson residual normalized single cell data",
    "section": "4 Quickstart / Example Usage",
    "text": "4 Quickstart / Example Usage\nFirst we’ll read in our Seurat object dataset. This is 960-plex NSCLC tissue.\n\nlibrary(data.table); setDTthreads(1)\nlibrary(scPearsonPCA)\nlibrary(ggplot2)\nlibrary(ggrepel)\n\n\nsem &lt;- readRDS(\"seurat_obj_nsclc.rds\")"
  },
  {
    "objectID": "posts/pearsonpca/index.html#pearson-pca-using-sparse_quasipoisson_pca_seurat",
    "href": "posts/pearsonpca/index.html#pearson-pca-using-sparse_quasipoisson_pca_seurat",
    "title": "scPearsonPCA: An R package for efficient Principal Components decomposition of pearson residual normalized single cell data",
    "section": "5 Pearson PCA using sparse_quasipoisson_pca_seurat",
    "text": "5 Pearson PCA using sparse_quasipoisson_pca_seurat\nWe typically recommend to use up to 2,000-3,000 highly variable genes for generating PCA results.\nA few summary stats used as input for calculating pearson-normalized PCs:\n\ntc is the total counts per cell across all genes.\ngenefreq is the proportion of transcript calls for each gene across all cells.\n\nIn general, it’s recommended to calculate these summary stats based on all genes rather than a subset of highly variable genes. While this dataset is only 960-plex, the code below uses 900 highly-variable genes as a demonstration for a basic workflow.\n\ntc &lt;- Matrix::colSums(sem[[\"RNA\"]]@counts) ## total counts per cell (across all genes)\ngenefreq &lt;- scPearsonPCA::gene_frequency(sem[[\"RNA\"]]@counts) ## gene frequency (across all cells)\nsum(genefreq)==1 # TRUE\n\nsem &lt;- Seurat::FindVariableFeatures(sem, nfeatures = 900)\nhvgs &lt;- sem@assays$RNA@var.features\n\n### Returns a Seurat-style DimReduc object with \n### hvgs x pcs feature loadings\n### cells x pcs cell embeddings\n### gene-length vector of the mean pearson of residuals\n### gene-length vector of the standard deviation of pearson residuals\npcaobj &lt;- \nsparse_quasipoisson_pca_seurat(sem[[\"RNA\"]]@counts[hvgs,]\n                               ,totalcounts = tc\n                               ,grate = genefreq[hvgs]\n                               ,scale.max = 10 ## PCs reflect clipping pearson residuals &gt; 10 SDs above the mean pearson residual\n                               ,do.scale = TRUE ## PCs reflect as if pearson residuals for each gene were scaled to have standard deviation=1\n                               ,do.center = TRUE ## PCs reflect as if pearson residuals for each gene were centered to have mean=0\n                               )\n\n\n5.1 Using the output for downstream analysis\nHere we’ll take the pcaobj we created and add the “DimReduc” to our seurat object. We can use this for downstream Seurat package analysis. Then, we’ll create a UMAP from these PC results using a helper function make_umap, which will also return a cells x cells nearest-neighbors graph we’ll use for unsupervised clustering.\n\numapobj &lt;- scPearsonPCA::make_umap(pcaobj)\nsem[[\"pearsonpca\"]] &lt;- pcaobj$reduction.data\nsem[[\"pearsonumap\"]] &lt;- umapobj$ump  ## umap\nsem[[\"pearsongraph\"]] &lt;- Seurat::as.Graph(umapobj$grph) ## nearest neighbors / adjacency matrix used for unsupervised clustering\nsem &lt;- Seurat::FindClusters(sem, graph = \"pearsongraph\")\nsem@meta.data$pearson_clusters &lt;- sem@meta.data$seurat_clusters\numapplot &lt;- scPearsonPCA::plot_umap(umapreduc = \"pearsonumap\", clustercol = \"pearson_clusters\", semuse = sem)\nprint(umapplot)"
  },
  {
    "objectID": "posts/pearsonpca/index.html#batch-corrected-pearson-pca-using-sparse_quasipoisson_pca_seurat_batch",
    "href": "posts/pearsonpca/index.html#batch-corrected-pearson-pca-using-sparse_quasipoisson_pca_seurat_batch",
    "title": "scPearsonPCA: An R package for efficient Principal Components decomposition of pearson residual normalized single cell data",
    "section": "6 Batch corrected Pearson PCA using sparse_quasipoisson_pca_seurat_batch",
    "text": "6 Batch corrected Pearson PCA using sparse_quasipoisson_pca_seurat_batch\nThe syntax is very similar if we want to correct for a batch variable, in this case ‘patient’. A few extra arguments are the cell identifier cellid_colname, batch identifier batch_variable, and a data.frame obs which should include both of these columns.\nWe also re-compute gene frequency passing these same additional arguments. This returns a genes x batches matrix of gene frequencies.\n\ngenefreq_batch &lt;- \ngene_frequency(sem[[\"RNA\"]]@counts, obs = data.table(sem@meta.data)[,.(cell_ID, patient)]\n               ,cellid_colname = \"cell_ID\"\n               ,batch_variable = \"patient\")\n\nMatrix::colSums(genefreq_batch)\n\n### Returns a Seurat-style DimReduc object with \n### hvgs x pcs feature loadings\n### cells x pcs cell embeddings\n### gene-length vector of the mean pearson of residuals\n### gene-length vector of the standard deviation of pearson residuals\npcaobj_batch &lt;- \nsparse_quasipoisson_pca_seurat_batch(sem[[\"RNA\"]]@counts[hvgs,]\n                                     ,totalcounts = tc\n                                     ,grate = genefreq_batch[hvgs,] ##\n                                     ,obs =data.table(sem@meta.data)[,.(cell_ID, patient)] \n                                     ,batch_variable = \"patient\"\n                                     ,cellid_colname = \"cell_ID\"\n                                     ,scale.max = 10\n                                     ,do.scale = TRUE\n                                     ,do.center = TRUE\n                                     )\n\n\n6.1 Using the output for downstream analysis\nHere again we’ll take the pcaobj_batch object and use it to create a UMAP and perform unsupervised clustering.\n\numapobj_batch &lt;- scPearsonPCA::make_umap(pcaobj_batch)\nsem[[\"pearsonbatchpca\"]] &lt;- pcaobj_batch$reduction.data\nsem[[\"pearsonbatchumap\"]] &lt;- umapobj_batch$ump\nsem[[\"pearsonbatchgraph\"]] &lt;- Seurat::as.Graph(umapobj_batch$grph) ## nearest neighbors / adjacency matrix used for unsupervised clustering\nsem &lt;- Seurat::FindClusters(sem, graph = \"pearsonbatchgraph\")\nsem@meta.data$pearson_clusters_batch &lt;- sem@meta.data$seurat_clusters\numapplotbatch &lt;- scPearsonPCA::plot_umap(umapreduc = \"pearsonbatchumap\", clustercol = \"pearson_clusters_batch\", semuse = sem)\nprint(umapplotbatch)\n\n\n\n\n\n\n\n\n\n\nFor this dataset, there are epithelial cell clusters which are fairly specific to each patient. This is expected in cancer tissue and may not warrant any batch correction.\nFor sake of demonstration here, however, we can visualize how the batch variable ‘patient’ separates more on the UMAP before vs. after batch-correction, where patient clusters have higher overlap in UMAP space.\nIn case of known batch effects, multiple methods of correction may be considered, and the best performing method may well vary from dataset to dataset. One alternative recommended method which often works well is ‘Harmony’, described in this post.\n\numapplot_patient_batch &lt;- scPearsonPCA::plot_umap(umapreduc = \"pearsonbatchumap\", clustercol = \"patient\", semuse = sem,alpha=0.1)\numapplot_patient &lt;- scPearsonPCA::plot_umap(umapreduc = \"pearsonumap\", clustercol = \"patient\", semuse = sem,alpha=0.1)\n\ncp &lt;- \ncowplot::plot_grid(umapplot_patient_batch + labs(title = \"UMAP using batch-corrected pearson PCs\")\n                   ,umapplot_patient + labs(title = \"UMAP using pearson PCs\")\n                   ,nrow=1) + \n  theme(plot.background = element_rect(fill = 'white',color='white')) + \n  cowplot::panel_border(remove=TRUE)  \nprint(cp)"
  },
  {
    "objectID": "posts/pearsonpca/index.html#pearson-pca-for-multiomic-data-using-sparse_quasipoisson_pca_seurat_multiomic",
    "href": "posts/pearsonpca/index.html#pearson-pca-for-multiomic-data-using-sparse_quasipoisson_pca_seurat_multiomic",
    "title": "scPearsonPCA: An R package for efficient Principal Components decomposition of pearson residual normalized single cell data",
    "section": "7 Pearson PCA for multiomic data using sparse_quasipoisson_pca_seurat_multiomic",
    "text": "7 Pearson PCA for multiomic data using sparse_quasipoisson_pca_seurat_multiomic\nBelow we’ll use a breast cancer dataset with WTx RNA + 64-plex protein to demo multiomic PCA and downstream analysis.\n\nReading in RNA and protein datasets\n\n## Note, using a v3-style Seurat Object below, i.e., `sem[[\"RNA\"]]@counts`\n## For v5-style, the syntax would be like `sem[[\"RNA\"]]$counts`\noptions(Seurat.object.assay.version = \"v3\")  \n\nsem_protein &lt;- readRDS(\"Breast/sem_protein.rds\")\nsem_rna &lt;- readRDS(\"Breast/sem_rna.rds\")\nsem_rna &lt;- subset(sem_rna, nCount_RNA &gt;=100)\n\n\n\nNormalizing the protein data\nThe sparse_quasipoisson_pca_seurat_multiomic function won’t do any special normalization to the protein data, so the data should be normalized going in. Here we’ll use pearson residuals from a gamma regression model as a normalization method, although other reasonable methods might be considered and left to the user’s disgression.\n\n## normalize each protein taking pearson residuals from gamma generalized linear model.\npgamm &lt;- scPearsonPCA::pearson_normalize_gamma_glm(as.matrix(sem_protein[[\"RNA\"]]@counts)\n                                                   ,upper_q_thresh = 0.99\n                                                   ,lower_q_thresh = 0.01\n                                                   )\n### add a '_protein' suffix to the protein names - helps differentiate proteins and RNA's with the same name. \nrownames(pgamm) &lt;- paste0(rownames(pgamm), \"_protein\")\n\npgamm[1:5,1:5] ## normalized protein data\n\n\n\n                      c_1_100_1  c_1_100_10 c_1_100_100 c_1_100_1000\n4-1BB_protein        -0.1592977  0.03704303  0.48381341 -0.054332422\nB7-H3_protein        -0.2409877 -0.08788226  0.08696422  0.006506165\nBcl-2_protein        -0.3037842 -0.26226294  0.26853206 -0.278620332\nBeta-catenin_protein -0.7617500 -0.06967635  0.14393940 -0.430273385\nCCR7_protein         -0.1174789 -0.21163185  0.24066117  5.283740671\n                     c_1_100_1001\n4-1BB_protein          -0.0686042\nB7-H3_protein           0.8100425\nBcl-2_protein          -0.2199310\nBeta-catenin_protein   -0.3508033\nCCR7_protein           -0.3366898\n\n\n\n\nPCA analysis derived from the joint covariance matrix of the the proteins and RNAs\nFirst we’ll identify a subset of highly variable genes from the RNA data. Then , we’ll pass in the RNA counts matrix and normalized protein matrix to get the PCA.\n\n## select genes from RNA data to use for PCA analysis.\n## Will take the top 2k features as well as any pre-defined immune celltyping markers from HieraType\nsem_rna &lt;- Seurat::FindVariableFeatures(sem_rna, nfeatures = 2000)\nuse_genes &lt;- c(sem_rna@assays$RNA@var.features)\n\n\n### total counts and gene frequency from RNA data computed across full dataset\ntc &lt;- Matrix::colSums(sem_rna[[\"RNA\"]]@counts)\ngenefreq &lt;- scPearsonPCA::gene_frequency(sem_rna[[\"RNA\"]]@counts)\n\n\n### Principal components derived from the combined covariance matrix of pearson residual normalized RNA and protein.\npcaobj_multiomics &lt;- scPearsonPCA::sparse_quasipoisson_pca_seurat_multiomic(sem_rna[[\"RNA\"]]@counts[use_genes,] ## raw counts matrix for hvgs\n                                                                       ,totalcounts = tc\n                                                                       ,grate = genefreq[use_genes]\n                                                                       ,xother = pgamm ## normalized protein\n                                                                       ,do.scale = TRUE\n                                                                       ,do.center = TRUE\n                                                                       ,scale.max = 10\n                                                                       ,ncores = 1\n)\n\n\n\nPC_ 1 \nPositive:  CD127_protein, pan-RAS_protein, p53_protein, EGFR_protein, TCF7_protein, NF-kB p65_protein, Channel-PanCK_protein, CTLA4_protein, EpCAM_protein, Beta-catenin_protein \n       LAMP1_protein, Ki-67_protein, AZGP1, FASN, SERHL2, DBI, KRT19, CD138_protein, PIP, NAMPT \nNegative:  CD39_protein, CD16_protein, CD40_protein, CD45_protein, VIM, CD4_protein, SPARC, CD74, COL1A1, COL3A1 \n       HLA-DRB1, COL1A2, STING_protein, HLA-DRA, CTSB, CST3, SMA_protein, APOE, Vimentin_protein, ICAM1_protein \nPC_ 2 \nPositive:  KRT19, AFMID, SERHL2, KRT8, FOXP3_protein, p53_protein, KRT7, CYP1B1, IgD_protein, LAG3_protein \n       ALDOA, MLPH, XBP1, NDRG1, CD24, CD123_protein, PGK1, Her2_protein, Channel-PanCK_protein, CD56_protein \nNegative:  H3C15, H4C14, H4C11, H3-7, H2BC4, H3C2, H4C12, H3C13, H2AC18, H2BC18 \n       H3C10, H1-2, H3C7, H2BC9, H2AC16, H1-5, H2BC12L, H2AC11, H3C11, H3C8 \nPC_ 3 \nPositive:  CD34_protein, CD123_protein, CD31_protein, COL4A1, SPARC, IGFBP7, COL4A2, PLVAP, GZMB_protein, SMA_protein \n       CD56_protein, HSPG2, LAG3_protein, FOXP3_protein, COL3A1, COL1A2, COL1A1, IgD_protein, LAMA4, COL6A2 \nNegative:  HLA-DRB1, CD74, HLA-DRA, APOE, Channel-CD68_protein, CTSD, HLA-DR_protein, LYZ, CD11c_protein, HLA-DQB1 \n       IFI30, CD68_protein, APOC1, HLA-DPA1, C1QC, GPNMB, CD45_protein, C1QB, HLA-DQA1, CTSB \nPC_ 4 \nPositive:  PD-L2_protein, GITR_protein, FOXP3_protein, 4-1BB_protein, LAG3_protein, CD56_protein, GZMB_protein, COL1A1, iNOS_protein, IgD_protein \n       Her2_protein, COL1A2, COL3A1, AEBP1, PD-1_protein, GZMA_protein, LUM, CD11b_protein, FN1, COL12A1 \nNegative:  PLVAP, CD34_protein, CD31_protein, COL4A1, A2M, EGFL7, AQP1, FLT1, KDR, COL4A2 \n       HSPG2, SHANK3, PODXL, PECAM1, ENG, CD34, MCAM, ECSCR, INSR, NHERF2 \nPC_ 5 \nPositive:  COL1A1, COL1A2, COL3A1, FN1, AEBP1, POSTN, LUM, COL6A3, COL12A1, C1S \n       THBS2, FBN1, SULF1, COL6A1, COL5A1, HTRA3, SFRP2, EpCAM_protein, Beta-catenin_protein, CTHRC1 \nNegative:  CD123_protein, GZMB_protein, FOXP3_protein, PD-L2_protein, LAG3_protein, iNOS_protein, CD56_protein, 4-1BB_protein, Her2_protein, GITR_protein \n       IgD_protein, CD31_protein, CD11b_protein, CD34_protein, CD68_protein, GZMA_protein, PD-1_protein, STING_protein, A2M, PLVAP \n\n\n\n\n7.1 Using the output for downstream analysis\n\numapobj_multiomics &lt;- scPearsonPCA::make_umap(pcaobj_multiomics)\n\n\nsem_rna[[\"multiumap\"]] &lt;- umapobj_multiomics$ump\nsem_rna[[\"multigrph\"]] &lt;- Seurat::as.Graph(umapobj_multiomics$grph[colnames(sem_rna),colnames(sem_rna)])\nsem_rna &lt;- Seurat::FindClusters(sem_rna, graph.name=\"multigrph\")\nsem_rna@meta.data$clusters_multi_unsup &lt;- sem_rna@meta.data$seurat_clusters\n\n\nxyp_multi_unsup &lt;- xyplot(\"clusters_multi_unsup\", metadata = sem_rna@meta.data, ptsize = 0.05) + coord_fixed()\nprint(xyp_multi_unsup)\n\n\n\n\n\n\n\n\n\n\n\numapp &lt;- plot_umap(umapreduc = \"multiumap\", clustercol = \"clusters_multi_unsup\", semuse = sem_rna)\nprint(umapp)\n\n\n\n\n\n\n\n\n\n\n\n7.1.1 RNA and protein marker heatmaps\nBelow we’ll look at a couple of marker heatmaps for these unsupervised clusters. These functions below use the HieraType package.\n\n#remotes::install_github(\"Nanostring-Biostats/CosMx-Analysis-Scratch-Space\", \n#                        subdir = \"_code/HieraType\", ref = \"Main\")\nlibrary(HieraType)\n\nfctbl_rna &lt;- clusterwise_foldchange_metrics(sem_rna[[\"RNA\"]]@counts[use_genes,]\n                                            ,totalcounts = tc\n                                            ,metadata = sem_rna@meta.data\n                                            ,cluster_column = \"clusters_multi_unsup\"\n                                            )\n\nhm_rna &lt;- add_ncells(marker_heatmap(fctbl_rna)) + labs(title = \"rna heatmap\")\nprint(hm_rna)\n\n\n\n\n\nfctbl_protein &lt;- HieraType::clusterwise_foldchange_metrics_protein(sem_protein[[\"RNA\"]]@counts[,rownames(sem_rna@meta.data)]\n                                                        ,metadata = sem_rna@meta.data\n                                                        ,cluster_column = \"clusters_multi_unsup\"\n                                                        ,propd = (pgamm[,rownames(sem_rna@meta.data)] &gt; 1)\n                                            )\nhm_protein &lt;- add_ncells(marker_heatmap(fctbl_protein)) + labs(title = \"protein heatmap\")\nprint(hm_protein)"
  },
  {
    "objectID": "posts/vignette-basic-analysis/index.html",
    "href": "posts/vignette-basic-analysis/index.html",
    "title": "Vignette: Basics of CosMx Analysis in R",
    "section": "",
    "text": "Updated vignette available\n\n\n\nAs of December 2025, we have an updated RNA analysis vignette available in three parts on our blog, starting here.\n\n\n\n\nA complete demo analysis of a CosMx dataset can be found at workflow section in this post and the correspond scripts are stored under _code/vignette folder in this repository. It’s intended to be used as a template for other analyses to follow.\nWe’ll be analyzing a 1000-plex dataset from melanoma samples. We begin with the files written by the AtoMx flat file export module. The full dataset we’ve used is too big to be saved on Github. To follow along, we recommend using your own data, also as output by the AtoMx flat file export module.\n\n\n\nWe’ll organize the data for this analysis as follows:\n\n\nThe “data” folder holds the exports from AtoMx\n“processed_data” holds data objects generated during analysis, meant to be used by later analyses.\n“results” holds results intended for human consumption.\n\nInside the “data” folder, we’ll place a folder names “flat_files”, containing the AtoMx exports:\n\nAnd we’ll organize code as follows:\n\n\nAnalysis scripts are numbered by the order in which they should be run. Each creates data used by the downstream scripts.\nScripts are meant to be run in the directory where they lie.\n“utils” holds R scripts containing functions used by analyses.\n\n\n\n\nOur flat file exports contain the following data types:\n\nRaw counts\nCell metadata: other attributes of cells, e.g. size, immunofluorescence values, tissue and FOV IDs,…\nSpatial locations: xy locations given in mm. Warning: studies containing multiple slides may initially have overlapping xy locations.\nTranscript data: for all RNA transcripts detected, location, gene ID, and cell ID. Most analyses use cell-level data, not this transcript-level data, but it can make compelling plots.\nTissue images. Not used by most analyses, but useful for Figures.\n\n\nOur analyses will append lots of new information to this starting point, ending here:\n\nNew data types include:\n\nUMAP coordinates\nData acting as new metadata columns, e.g. cell type assignment and spatial cluster\nSpecial results objects from analyses: cell typing, differential expression, InSituCor, …\n\n\n\n\nOur workflow performs the below steps:\nFirst, the fundamentals:\n\nParse and format data export by AtoMx\nCustom arranging of tissues and FOVs in space\nQC and normalization\nDimension reduction (PCA and UMAP)\nCell typing\n\nThen, we go after biology:\n\nDefining cells’ spatial context\nHypothesis-driven analyses, i.e. differential expression: how do cells change behavior based on their spatial context? (coming summer 2024)\nHypothesis-generating analyses: identifying spatially correlated genes with InSituCor\n\n\n\n\n\nFor large experiments, more advanced workflows may be needed to avoid overwhelming your compute and/or memory.\nFor studies across multiple flow cells, batch correction should be considered."
  },
  {
    "objectID": "posts/vignette-basic-analysis/index.html#introduction",
    "href": "posts/vignette-basic-analysis/index.html#introduction",
    "title": "Vignette: Basics of CosMx Analysis in R",
    "section": "",
    "text": "A complete demo analysis of a CosMx dataset can be found at workflow section in this post and the correspond scripts are stored under _code/vignette folder in this repository. It’s intended to be used as a template for other analyses to follow.\nWe’ll be analyzing a 1000-plex dataset from melanoma samples. We begin with the files written by the AtoMx flat file export module. The full dataset we’ve used is too big to be saved on Github. To follow along, we recommend using your own data, also as output by the AtoMx flat file export module."
  },
  {
    "objectID": "posts/vignette-basic-analysis/index.html#file-structure",
    "href": "posts/vignette-basic-analysis/index.html#file-structure",
    "title": "Vignette: Basics of CosMx Analysis in R",
    "section": "",
    "text": "We’ll organize the data for this analysis as follows:\n\n\nThe “data” folder holds the exports from AtoMx\n“processed_data” holds data objects generated during analysis, meant to be used by later analyses.\n“results” holds results intended for human consumption.\n\nInside the “data” folder, we’ll place a folder names “flat_files”, containing the AtoMx exports:\n\nAnd we’ll organize code as follows:\n\n\nAnalysis scripts are numbered by the order in which they should be run. Each creates data used by the downstream scripts.\nScripts are meant to be run in the directory where they lie.\n“utils” holds R scripts containing functions used by analyses."
  },
  {
    "objectID": "posts/vignette-basic-analysis/index.html#data-structure",
    "href": "posts/vignette-basic-analysis/index.html#data-structure",
    "title": "Vignette: Basics of CosMx Analysis in R",
    "section": "",
    "text": "Our flat file exports contain the following data types:\n\nRaw counts\nCell metadata: other attributes of cells, e.g. size, immunofluorescence values, tissue and FOV IDs,…\nSpatial locations: xy locations given in mm. Warning: studies containing multiple slides may initially have overlapping xy locations.\nTranscript data: for all RNA transcripts detected, location, gene ID, and cell ID. Most analyses use cell-level data, not this transcript-level data, but it can make compelling plots.\nTissue images. Not used by most analyses, but useful for Figures.\n\n\nOur analyses will append lots of new information to this starting point, ending here:\n\nNew data types include:\n\nUMAP coordinates\nData acting as new metadata columns, e.g. cell type assignment and spatial cluster\nSpecial results objects from analyses: cell typing, differential expression, InSituCor, …"
  },
  {
    "objectID": "posts/vignette-basic-analysis/index.html#sec-workflow",
    "href": "posts/vignette-basic-analysis/index.html#sec-workflow",
    "title": "Vignette: Basics of CosMx Analysis in R",
    "section": "",
    "text": "Our workflow performs the below steps:\nFirst, the fundamentals:\n\nParse and format data export by AtoMx\nCustom arranging of tissues and FOVs in space\nQC and normalization\nDimension reduction (PCA and UMAP)\nCell typing\n\nThen, we go after biology:\n\nDefining cells’ spatial context\nHypothesis-driven analyses, i.e. differential expression: how do cells change behavior based on their spatial context? (coming summer 2024)\nHypothesis-generating analyses: identifying spatially correlated genes with InSituCor"
  },
  {
    "objectID": "posts/vignette-basic-analysis/index.html#general-analysis-advice",
    "href": "posts/vignette-basic-analysis/index.html#general-analysis-advice",
    "title": "Vignette: Basics of CosMx Analysis in R",
    "section": "",
    "text": "For large experiments, more advanced workflows may be needed to avoid overwhelming your compute and/or memory.\nFor studies across multiple flow cells, batch correction should be considered."
  },
  {
    "objectID": "posts/transcript-segmentation/index.html",
    "href": "posts/transcript-segmentation/index.html",
    "title": "A practical guide to transcript-based cell segmentation in spatial transcriptomics",
    "section": "",
    "text": "Spatial transcriptomics technologies provide high-resolution spatial maps of transcript locations within tissue. A central challenge in these datasets is cell segmentation, which assigns transcripts to individual cells accurately, particularly when image data is noisy, missing, or ambiguous.\nTo address this, researchers have developed transcript-based analysis techniques that either:\n\nSection 2.1 Segment cells from transcript locations (e.g., Baysor, ProSeg),\nSection 2.2 Refine existing image-based segmentations using transcript patterns (e.g., FastReseg),\nSection 2.3 Avoid segmentation entirely by analyzing the spatial organization of transcripts directly (e.g., FICTURE).\n\nThis post provides a practical walk-through of each technique with examples on using it with CosMx® data, whose standard data format are described here.\n\n\n\n\n\n\nFigure 1: Schematic of transcript-informed approaches\n\n\n\nLike other items in our CosMx Analysis Scratch Space, the usual caveats and license applies."
  },
  {
    "objectID": "posts/transcript-segmentation/index.html#sec-txSeg",
    "href": "posts/transcript-segmentation/index.html#sec-txSeg",
    "title": "A practical guide to transcript-based cell segmentation in spatial transcriptomics",
    "section": "2.1 Transcript-Based Segmentation",
    "text": "2.1 Transcript-Based Segmentation\nThese methods directly infer cell boundaries by clustering or modeling the spatial distribution of transcripts, often using gene identity as additional signal.\nUse when:\n\nYou don’t have reliable cell images (e.g., missing or low-quality DAPI/membrane stains)\nYou want to define cells purely from mRNA localization\nYou need a de novo segmentation pipeline without preprocessing\n\nLimitations:\n\nMay oversegment sparse cells or misplace boundaries without priors\nTranscript noise can bias clustering in low-resolution assays and introduce circularity in analysis pipeline\n\nBest for: Datasets where transcript positions are abundant and dense."
  },
  {
    "objectID": "posts/transcript-segmentation/index.html#sec-txRefine",
    "href": "posts/transcript-segmentation/index.html#sec-txRefine",
    "title": "A practical guide to transcript-based cell segmentation in spatial transcriptomics",
    "section": "2.2 Segmentation Refinement",
    "text": "2.2 Segmentation Refinement\nThese tools enhance an existing segmentation mask, correcting common segmentation errors using transcript-level context only when there is sufficient evidence.\nUse when:\n\nYou already ran an image-based segmentation (e.g., Cellpose, watershed)\nYou notice cells with minor contamination from neighboring cells\nYou want to keep image-based alignment but improve transcript association\n\nLimitations:\n\nRelies on the quality of the initial mask — can’t fix everything\nAdds an extra pipeline step, but is lightweight\n\nBest for: Any pipeline combining tissue images with transcript-based validation, especially if accurate cell boundaries affect downstream quantification."
  },
  {
    "objectID": "posts/transcript-segmentation/index.html#sec-segFree",
    "href": "posts/transcript-segmentation/index.html#sec-segFree",
    "title": "A practical guide to transcript-based cell segmentation in spatial transcriptomics",
    "section": "2.3 Segmentation-Free Analysis",
    "text": "2.3 Segmentation-Free Analysis\nInstead of forcing transcripts into discrete cells, these approaches model gene expression directly in space, uncovering continuous spatial features, patterns, and regions.\nUse when:\n\nYou want to avoid cell segmentation biases\nYour tissue has ambiguous or poorly defined boundaries\nYou aim to study gradients, niches, or expression domains more than individual cells\n\nLimitations:\n\nNo per-cell outputs (e.g., no cell-by-gene matrices)\nSome tools are exploratory and require interpretation beyond standard stats\n\nBest for: Ultra-dense data like Seq-Scope or CosMx where transcript resolution enables high-fidelity spatial patterning without segmentation artifacts."
  },
  {
    "objectID": "posts/transcript-segmentation/index.html#baysor-probabilistic-transcript-based-segmentation",
    "href": "posts/transcript-segmentation/index.html#baysor-probabilistic-transcript-based-segmentation",
    "title": "A practical guide to transcript-based cell segmentation in spatial transcriptomics",
    "section": "3.1 Baysor: Probabilistic Transcript-Based Segmentation",
    "text": "3.1 Baysor: Probabilistic Transcript-Based Segmentation\nBaysor (Petukhov et al. 2021) segments cells by modeling transcript positions and gene identities using a Bayesian mixture model. It optionally incorporates nuclei positions for prior constraints.\nPros\n\nFully probabilistic\nHandles overlapping cells and ambiguous boundaries\nOptional priors improve accuracy\n\nCons\n\nSlower and very high memory consumption on large datasets\nRequires Julia and formatting input data\nSensitive to input parameters, tend to over-segmenting and bias towards smaller cells.\n\n\n3.1.1 Install Baysor\nThe simplest way to install Baysor on Linux is by downloading a precompiled binary from the repository’s release section. Once downloaded, you can run the executable located at bin/baysor. Below is the example code on how to setup an AWS EC2 instance to run baysor. For other platforms, please refer to the full installation instruction provided by the original authors here.\n\nSSH log into your AWS EC2 instance as admin and navigate to a folder you can write on, e.g. /home/YourUserName/data.\n\n\n\n\nlog into ec2 as admin\n\n# replace content inside &lt;&gt; with your actual setup\nssh -i \"your-key-to-ec2.pem\" &lt;admin-name&gt;@&lt;instance-ip-address&gt; \n\n# show container/docker info to get container ID\nsudo docker ps -a\n\n# get into the container, replace \"root\" with your admin name \nsudo docker exec --user=\"root\" -it &lt;container-ID&gt; /bin/bash\n\n# navigate to working directory\ncd /home/YourUserName/data\n\n\n\nDownload and unzip the precompiled binary to target folder. For Baysor v0.7.1, there should be two executable baysor and julia inside the unzipped./bin folder.\n\n\n\n\nobtain Baysor binary\n\nwget https://github.com/kharchenkolab/Baysor/releases/download/v0.7.1/baysor-x86_x64-linux-v0.7.1_build.zip\nunzip baysor-x86_x64-linux-v0.7.1_build.zip\n\nls -l bin/julia\nls -l bin/baysor\n\n\n\nMake the downloaded binary executable (./bin folder) for all users, set library path to empty (necessary to work with pre-compiled executable) and verify if baysor/bin is working.\n\n\n\n\nmake Baysor executable\n\nchmod -R o+x /home/YourUserName/data/bin \nchmod -R o+r /home/YourUserName/data/bin \n\nls -l /home/YourUserName/data/bin/julia \nls -l /home/YourUserName/data/bin/baysor\n\nLD_LIBRARY_PATH=\"\"\necho $LD_LIBRARY_PATH\n\n/home/YourUserName/data/bin/julia --help\n/home/YourUserName/data/bin/baysor --help\n\n\n\nCreate symbolic links such that one could run with command line without the full path to the binary file.\n\n\n\n\ncreate symbolic link\n\nsudo ln -s /home/YourUserName/data/bin/julia /usr/local/bin/julia\nsudo ln -s /home/YourUserName/data/bin/baysor /usr/local/bin/baysor\n\njulia --help\nbaysor --help\n\n\nNow you should be able to run Baysor from command line in your EC2 instance.\n\n\n3.1.2 Run Baysor\nAs detailed in Baysor’s documentations, baysor segmentation command requires data frame of transcripts’ coordinates and gene type as inputs. One can specify the data format as command arguments and configure the processing in the .toml file.\nPrepare Inputs\nThe transcript file (e.g. Pancreas_tx_file.csv) exported by AtoMx® SIP has spatial coordinates under pixel unit in global coordinate system and is recommended to convert into micrometer unit before processing. Besides, AtoMx exported transcript file has study-unique cell ID under cell column which could be provided to baysor command as prior segmentation.\n\n# prepare Tx file in R\nfullTx &lt;- data.table::fread(\"Pancreas_tx_file.csv\")\n\n# convert to micrometer \npixel_size &lt;- 0.12028 # micron per pixel \nz_step &lt;- 0.8 # micron per z step \n\nfullTx[['x_allS_um']] &lt;- fullTx[['x_global_px']] * pixel_size\nfullTx[['y_allS_um']] &lt;- fullTx[['y_global_px']] * pixel_size\nfullTx[['z_allS_um']] &lt;- fullTx[['z']] * z_step\n\n# assign unify \"cell\" ID to extracellular transcripts in tx file \nfullTx[cell_ID == 0, cell := \"0\"]\n\n# export the modified transcript file to use with command line \ndata.table::fwrite(fullTx, file = \"Pancreas_prepared_tx_file.csv\")\n\nRun Command\nBelow is an example command that performs Baysor segmentation on transcript file (e.g. Pancreas_prepared_tx_file.csv) and output results to folder ~/data/baysor_outputs. Optionally, one can disable the polygon outputs for faster processing by passing --polygon-format none to the command.\n\n\n\nrun Baysor\n\nbaysor run Pancreas_prepared_tx_file.csv :cell \\\n  --output ~/data/baysor_outputs \\\n  --gene-column target \\\n  --x-column x_allS_um \\\n  --y-column y_allS_um \\\n  --z-column z_allS_um \\\n  --config baysor_cosmx_config.toml \\\n  --count-matrix-format tsv\n\n\nAn example configuration file for using CosMx data with Baysor is shown below.\n[data]\ngene = \"target\"\nmin_molecules_per_gene = 1\nexclude_genes = \"FalseCode*,NegPrb*,SystemControl*,Negative*,Custom*\"\nmin_molecules_per_cell = 20\n\n[segmentation]\nprior_segmentation_confidence = 0.2 # Confidence of the prior segmentation. Default: 0.2\nunassigned_prior_label = \"0\" # Label for unassigned cells in the prior segmentation. Default: \"0\"\n\n[plotting]\nmin_pixels_per_cell = 10 # Number of pixels per cell of minimal size, used to estimate size of the final plot. For most protocols values around 7-30 give enough visualization quality. Default: 15\nmax_plot_size = 3000 # Maximum size of the molecule plot in pixels. Default: 5000A\n\n\n\n\n\n\nTip\n\n\n\nSince a full run can be time-consuming, it’s recommended to perform a quick preview to extract initial insights from the data and to make informed guesses about the parameters for the full analysis. One can achieve this with baysor preview command using the same input arguments. For more details, see here and a discussion on parameter choices could be found here.\n\n\nOutputs\nBy default, baysor segmentation generates the following outputs.\n\n\n\nBaysor outputs\n\nbaysor_outputs/\n├── segmentation_cell_stats.csv\n├── segmentation_counts.tsv\n├── segmentation.csv\n├── segmentation_log.log\n├── segmentation_params.dump.toml\n├── segmentation_polygons_2d.json\n└── segmentation_polygons_3d.json\n\n\nA full description on outputs could be found in Baysor’s documentations. Briefly,\n\nsegmentation_cell_stats.csv: a cell x attributes data frame with new cell ID under cell column, number of transcripts assigned under n_transcripts column, and average assignment confidence per cell under avg_assignment_confidence column.\nsegmentation_counts.tsv: the single-cell count matrix with segmented statistics; one could choose to output it as loom format when setting --count-matrix-format loom in command.\nsegmentation.csv: the per molecular level information for the full transcript file, with cell column for new cell ID, confidence and is_noise columns for whether the molecule is real (not noise), and assignment_confidence column for the confidence that the particular molecule is assigned to a correct cell.\n\nWe recommend to remove molecules with confidence below 0.9 or is_nose = True from single-cell expression matrix for downstream analysis."
  },
  {
    "objectID": "posts/transcript-segmentation/index.html#proseg-fast-transcript-simulation-based-segmentation",
    "href": "posts/transcript-segmentation/index.html#proseg-fast-transcript-simulation-based-segmentation",
    "title": "A practical guide to transcript-based cell segmentation in spatial transcriptomics",
    "section": "3.2 ProSeg: Fast Transcript Simulation Based Segmentation",
    "text": "3.2 ProSeg: Fast Transcript Simulation Based Segmentation\nProSeg (Jones et al. 2025) is a high-speed, Rust-based tool that segments cells using density-based clustering of transcript positions. It is optimized for large datasets from platforms like CosMx.\nPros\n\nMuch faster and smaller memory footprint than Baysor\nDoes not require image inputs to consider prior segmentation with assigned nuclear compartment\nWorks on compressed csv.gz files directly\n\nCons\n\nFewer model-based refinements than Baysor\nA sampling method which runs in non-deterministic way in its current form.\nThe direct outputs are posterior expectations instead of integers counts assigned to each cell.\nProne to merge error and generate abnormally large cells near sample edge next to cell-free region.\n\n\n3.2.1 Install ProSeg\nTo install ProSeg, one would need to first install cargo and then the proseg package. For an AWS EC2 instance, one should first log into the instance as admin (see Baysor installation above Section 3.1.1 for details) and then do the following.\n\nInstall cargo as admin root and set it up for all users.\n\n\n\n\ninstall cargo\n\ncurl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh\n\n# activate cargo environment or restart session to have PATH change in effect \n. \"$HOME/.cargo/env\"\necho $HOME\n\n# test installation\nwhich cargo\ncargo --version\n\n\nBy default, cargo would be installed under /root/.cargo folder. To make it executable for all users, one could copy its binary to local environment.\n\n\n\nsetup cargo for all users\n\nls /root/.cargo/bin/\n\nsudo cp /root/.cargo/bin/* /usr/local/bin/\nsudo chmod 755 /usr/local/bin/*\n\n\nNow, one could use cargo as non-admin user.\n\nClone and install proseg.\n\n\n\n\ninstall proseg\n\ngit clone https://github.com/dcjones/proseg.git\ncargo install proseg\n\n# test installation\nwhich proseg\nproseg --version\n\n\n\n\n3.2.2 Run ProSeg\nSame as baysor, the primary input for proseg is the transcript data frame. Since proseg command allows a more flexible data structure and internal conversion between pixel and micrometer units using coordinate-scale argument, the transcript file exported by AtoMx® SIP could be used directly without modification or decompression (i.e. working for .csv.gz file).\nRun Command\nBelow is an example command that performs ProSeg segmentation on transcript file (e.g. Pancreas_tx_file.csv) and output results to folder ~/data/proseg_outputs. In addition to prior segmentation, the assigned nuclear compartments in transcript files are also provided to proseg via arguments --compartment-column CellComp --compartment-nuclear Nuclear.\n\n\n\nrun ProSeg\n\nproseg Pancreas_tx_file.csv \\\n  --output-path ~/data/proseg_outputs \\\n  --gene-column target \\\n  --x-column x_global_px \\\n  --y-column y_global_px \\\n  --z-column z \\\n  --compartment-column CellComp \\\n  --compartment-nuclear Nuclear \\\n  --fov-column fov \\\n  --cell-id-column cell \\\n  --cell-id-unassigned '' \\\n  --cell-assignment-column cell_ID \\\n  --cell-assignment-unassigned '0' \\\n  --excluded-genes '^(SystemControl|Negative)' \\\n  --coordinate-scale 0.12028 \n\n\n\n\n\n\n\n\nTip\n\n\n\nProSeg performs a z coordinate normalization step to remove sample tilt and cap z coordinates within 1st ~ 99th percentile of original value. Thus, it’s recommended to split your dataset by tissue sections first and then process each one separately. This helps avoid problems that can happen because the sections may have different z-coordinate values. More advice and description on argument options could be found here.\n\n\nOutputs\nBy default, proseg segmentation generates the following outputs.\n\n\n\nProSeg outputs\n\nproseg_outputs/\n├── cell-metadata.csv\n├── cell-polygons.geojson\n├── cell-polygons-layers.geojson\n├── expected-counts.csv\n├── transcript-metadata.csv\n└── union-cell-polygons.geojson\n\n\nA full description on ProSeg’s output format could be found here. Briefly.\n\ncell-metadata.csv: a cell x attributes data frame with new cell ID under cell column, cell volume under volume column.\n\nWe recommend to inspect the volume value to remove cells that are abnormally large.\n\nexpected-counts.csv: the single-cell expression matrix with segmented statistics; the reported expression values are posterior expectations shown as fractional counts instead of integers.\n\nWe recommend to calculate the observed single-cell count matrix with the new cell ID assignment from the output transcript-metadata.csv before downstream single-cell analysis for consistency.\n\ntranscript-metadata.csv: the per molecular level information for the full transcript file, with gene column for gene name, assignment column for new cell ID, probability and background columns for whether the molecule is real and confidently assigned.\n\nWe recommend to remove molecules with background = 1 before generating the observed single-cell count matrix from transcript file.\n\n\nGenerate Count Matrix\n\n# read in ProSeg processed transcript files in R\ndt &lt;- data.table::fread(\"proseg_outputs/transcript-metadata.csv\")\n\n# remove background transcripts and keep only the needed columns \ndt &lt;- dt[background !=1, .SD, .SDcols = c('assignment', 'gene')]\ndt[['gene']] &lt;- factor(dt[['gene']])\ndt[['assignment']] &lt;- as.character(dt[['assignment']])\n\n# get observed cell x gene count matrix \ncounts &lt;- reshape2::acast(dt, assignment ~ gene, fun.aggregate = length)\ncounts &lt;- Matrix::Matrix(counts, sparse = TRUE)"
  },
  {
    "objectID": "posts/transcript-segmentation/index.html#fastreseg-transcript-based-segmentation-refinement",
    "href": "posts/transcript-segmentation/index.html#fastreseg-transcript-based-segmentation-refinement",
    "title": "A practical guide to transcript-based cell segmentation in spatial transcriptomics",
    "section": "3.3 FastReseg: Transcript-Based Segmentation Refinement",
    "text": "3.3 FastReseg: Transcript-Based Segmentation Refinement\nFastReseg (Wu, Beechem, and Danaher 2025) is a transcript-informed refinement tool that improves segmentation masks (e.g., from Cellpose or watershed) by leveraging local transcript expression profiles to resolve over-segmentation, under-segmentation, and cell boundaries.\nPros\n\nFast and lightweight\nEnhances biological accuracy without radically redefining cell boundaries\nSupports configurable refinement rules\n\nCons\n\nRequires an existing segmentation mask\nWorks best with dense, high-plex data\n\nPlease refer to earlier post and the package tutorial on how to use FastReseg to evaluate segmentation performance and further perform refinement.\n\n3.3.1 FastReseg Custom Module in AtoMx\nFor AtoMx users (version 2.0.1 or later), here we provide a custom module designed to perform FastReseg analysis on CosMx RNA studies hosted on the AtoMx SIP platform.\nThis module conducts segmentation evaluation on pre-segmented data and introduces a new cell metadata column, lrtest_nlog10P, which quantifies the degree of spatial dependency observed within existing cells. It also enables the removal of flagged transcripts from current cell segments. When the module is executed a second time with the same configuration and overwrite_RNA_soma = TRUE, it allows downstream AtoMx analysis to proceed using the trimmed RNA data. Currently, the FastReseg custom module supports transcript cleanup through trimming only, as this is the primary error mode encountered in thin tissue sections."
  },
  {
    "objectID": "posts/transcript-segmentation/index.html#ficture-segmentation-free-spatial-transcript-analysis",
    "href": "posts/transcript-segmentation/index.html#ficture-segmentation-free-spatial-transcript-analysis",
    "title": "A practical guide to transcript-based cell segmentation in spatial transcriptomics",
    "section": "3.4 FICTURE: Segmentation-Free Spatial Transcript Analysis",
    "text": "3.4 FICTURE: Segmentation-Free Spatial Transcript Analysis\nFICTURE (Si et al. 2024) is a segmentation-free spatial factorization method. It models spatial transcript patterns using statistical models to extract biologically meaningful regions and interactions.\nPros\n\nNo reliance on image or segmentation\nIdeal for spatial transcriptomics data of submicron-resolution (e.g., Seq-Scope, CosMx)\nAvoids biases of segmentation methods\n\nCons\n\nWorks on 2D transcript data only\nDoesn’t yield per-cell outputs (i.e., no cell boundaries)\nInterpretation can be abstract for some users\n\n\n3.4.1 Install FICTURE\nFICTURE relies on bgzip and tabix for file processing and one could install those libraries as part of htslib installation. For an AWS EC2 instance, one should first log into the instance as admin (see Baysor installation above Section 3.1.1 for details) and then do the following.\n\nInstall htslibC library (latest release).\n\n\n\n\ninstall C dependencies of FICTURE\n\n# download and unzip the release version\nwget https://github.com/samtools/htslib/releases/download/1.20/htslib-1.20.tar.bz2\ntar -xvjf htslib-1.20.tar.bz2\ncd htslib-1.20\n\n# setup location to install, typically under /usr/local/ for all users\n./configure --prefix=/usr/local/\nsudo make\nsudo make install\n\n# test installation\nhtsfile --version\n\n\nIf the installation location is not under /usr/local/, one would need to add the installation path to PATH system environment variable when login as non-admin user.\n\n\n\nupdate PATH\n\nPATH=/where/to/install/bin/:$PATH\n\n# test installation\nbgzip\ntabix\n\n\n\nSet up python virtual environment and install FICTURE package via pip.\n\n\n\n\ncreate env and install FICTURE\n\n## Create a virtual environment\nVENV=/path/to/venv/name   ## replace it with your desired path\npython -m venv ${VENV}\n\n## Activate the virtual environment\nsource ${VENV}/bin/activate\n\n## Clone the GitHub repository\ngit clone https://github.com/seqscope/ficture.git\ncd ficture\n\n## Install the required packages\npip install -r requirements.txt\n\n## Install FICTURE locally\npip install -e .\n\n\n\n\n3.4.2 Run FICTURE\nA full description on how to run FICTURE could be found here. More information regarding how to submit FICTURE jobs to SLURM cluster is described in FICTURE’s documents.\nPrepare Inputs\nBelow is an example command that prepares AtoMx-exported transcript file (e.g. Pancreas_tx_file.csv) for FICTURE processing using its utility function. See here for more details.\n\n\n\nprepare CosMx Tx file for FICTURE\n\n# path to input transcript file, working for .csv.gz file too \ninputFile=/path/to/input/Pancreas_tx_file.csv\n\n## set up output folder and identifier \noutDir=/path/to/preprocess_data\niden=pancreas\n\nfilteredFile=${outDir}/filtered.matrix.${iden}.tsv\nfeatureFile=${outDir}/feature.clean.${iden}.tsv\n\n# navigate to the root folder of FICTURE package to use its utilities function\ncd ficture \n\n# generate transcript file (required) and gene list (optional)\npython misc/format_cosmx.py \\\n  --input ${inputFile} \\\n  --output ${filteredFile} \\\n  --gcol target \\\n  --feature ${featureFile} \\\n  --dummy_genes 'Negative|SystemControl' \\\n  --px_to_um 0.12028 \\\n  --precision 2 \\\n  --annotation cell fov\n\n# sort the filtered transcript files based on coordinate columns (first 2) and then zip it\nsort -k2,2g -k1,1g ${filteredFile} | gzip -c &gt; ${filteredFile}.gz\n\n# remove the unsorted unzip version\nrm ${filteredFile}\n\n\n\n\n\npreprocess outputs\n\npreprocess_data/\n├── coordinate_minmax.tsv\n├── feature.clean.pancreas.tsv\n└── filtered.matrix.pancreas.tsv.gz\n\n\nRun Command\nBelow is an example command that perform the complete FICTURE pipeline with 2 different hexagon flat-to-flat widths train-width, 12 and 18 micron, at same time.\n\n\n\nrun FICTURE\n\n# setup pipeline output folder\noutDir2=/path/to/ficture_outputs\n\n# generate transcript file and gene list (optional)\nficture run together --in-tsv ${filteredFile}.gz \\\n  --in-minmax ${outDir}/coordinate_minmax.tsv \\\n  --in-feature ${featureFile} \\\n  --out-dir ${outDir2} \\\n  --train-width 12,18 \\\n  --n-factor 12 \\\n  --n-jobs 4\\\n  --plot-each-factor \\\n  --all\n\n\nIf the installation path for bgzip and tabix is not under /usr/local/bin/, pass the installation location to the ficture command as well: --bgzip /where/to/install/bin/bgzip --tabix /where/to/install/bin/tabix.\nOutputs\nBy default, ficture run together command generates the following outputs when setting number of expression factors n-factor to 12 with 2 different train-width values. A detailed description on the output files are described in FICTURE’s documents.\n\n\n\nFICTURE outputs\n\nficture_outputs\n├── analysis\n│   ├── nF12.d_12\n│   │   ├── figure\n│   │   │   ├── nF12.d_12.cbar.png\n│   │   │   ├── nF12.d_12.coarse.png\n│   │   │   ├── nF12.d_12.coarse.top.png\n│   │   │   ├── nF12.d_12.decode.prj_12.r_4_5.pixel.png\n│   │   │   ├── nF12.d_12.rgb.tsv\n│   │   │   └── sub\n│   │   │       ├── nF12.d_12.decode.prj_12.r_4_5.pixel.F_0.png\n│   │   │       ├── nF12.d_12.decode.prj_12.r_4_5.pixel.F_10.png\n│   │   │       ├── nF12.d_12.decode.prj_12.r_4_5.pixel.F_11.png\n│   │   │       ├── nF12.d_12.decode.prj_12.r_4_5.pixel.F_1.png\n│   │   │       ├── nF12.d_12.decode.prj_12.r_4_5.pixel.F_2.png\n│   │   │       ├── nF12.d_12.decode.prj_12.r_4_5.pixel.F_3.png\n│   │   │       ├── nF12.d_12.decode.prj_12.r_4_5.pixel.F_4.png\n│   │   │       ├── nF12.d_12.decode.prj_12.r_4_5.pixel.F_5.png\n│   │   │       ├── nF12.d_12.decode.prj_12.r_4_5.pixel.F_6.png\n│   │   │       ├── nF12.d_12.decode.prj_12.r_4_5.pixel.F_7.png\n│   │   │       ├── nF12.d_12.decode.prj_12.r_4_5.pixel.F_8.png\n│   │   │       └── nF12.d_12.decode.prj_12.r_4_5.pixel.F_9.png\n│   │   ├── nF12.d_12.coherence.tsv\n│   │   ├── nF12.d_12.decode.prj_12.r_4_5.anchor.tsv.gz\n│   │   ├── nF12.d_12.decode.prj_12.r_4_5.bulk_chisq.tsv\n│   │   ├── nF12.d_12.decode.prj_12.r_4_5.done\n│   │   ├── nF12.d_12.decode.prj_12.r_4_5.factor.info.html\n│   │   ├── nF12.d_12.decode.prj_12.r_4_5.factor.info.tsv\n│   │   ├── nF12.d_12.decode.prj_12.r_4_5.pixel.sorted.tsv.gz\n│   │   ├── nF12.d_12.decode.prj_12.r_4_5.pixel.sorted.tsv.gz.tbi\n│   │   ├── nF12.d_12.decode.prj_12.r_4_5.posterior.count.tsv.gz\n│   │   ├── nF12.d_12.done\n│   │   ├── nF12.d_12.fit_result.tsv.gz\n│   │   ├── nF12.d_12.model_matrix.tsv.gz\n│   │   ├── nF12.d_12.model.p\n│   │   ├── nF12.d_12.model_selection_candidates.p\n│   │   ├── nF12.d_12.posterior.count.tsv.gz\n│   │   ├── nF12.d_12.prj_12.r_4.fit_result.tsv.gz\n│   │   └── nF12.d_12.prj_12.r_4.posterior.count.tsv.gz\n│   └── nF12.d_18\n│       ├── figure\n│       │   ├── nF12.d_18.cbar.png\n│       │   ├── nF12.d_18.coarse.png\n│       │   ├── nF12.d_18.coarse.top.png\n│       │   ├── nF12.d_18.decode.prj_18.r_4_5.pixel.png\n│       │   ├── nF12.d_18.rgb.tsv\n│       │   └── sub\n│       │       ├── nF12.d_18.decode.prj_18.r_4_5.pixel.F_0.png\n│       │       ├── nF12.d_18.decode.prj_18.r_4_5.pixel.F_10.png\n│       │       ├── nF12.d_18.decode.prj_18.r_4_5.pixel.F_11.png\n│       │       ├── nF12.d_18.decode.prj_18.r_4_5.pixel.F_1.png\n│       │       ├── nF12.d_18.decode.prj_18.r_4_5.pixel.F_2.png\n│       │       ├── nF12.d_18.decode.prj_18.r_4_5.pixel.F_3.png\n│       │       ├── nF12.d_18.decode.prj_18.r_4_5.pixel.F_4.png\n│       │       ├── nF12.d_18.decode.prj_18.r_4_5.pixel.F_5.png\n│       │       ├── nF12.d_18.decode.prj_18.r_4_5.pixel.F_6.png\n│       │       ├── nF12.d_18.decode.prj_18.r_4_5.pixel.F_7.png\n│       │       ├── nF12.d_18.decode.prj_18.r_4_5.pixel.F_8.png\n│       │       └── nF12.d_18.decode.prj_18.r_4_5.pixel.F_9.png\n│       ├── nF12.d_18.coherence.tsv\n│       ├── nF12.d_18.decode.prj_18.r_4_5.anchor.tsv.gz\n│       ├── nF12.d_18.decode.prj_18.r_4_5.bulk_chisq.tsv\n│       ├── nF12.d_18.decode.prj_18.r_4_5.done\n│       ├── nF12.d_18.decode.prj_18.r_4_5.factor.info.html\n│       ├── nF12.d_18.decode.prj_18.r_4_5.factor.info.tsv\n│       ├── nF12.d_18.decode.prj_18.r_4_5.pixel.sorted.tsv.gz\n│       ├── nF12.d_18.decode.prj_18.r_4_5.pixel.sorted.tsv.gz.tbi\n│       ├── nF12.d_18.decode.prj_18.r_4_5.posterior.count.tsv.gz\n│       ├── nF12.d_18.done\n│       ├── nF12.d_18.fit_result.tsv.gz\n│       ├── nF12.d_18.model_matrix.tsv.gz\n│       ├── nF12.d_18.model.p\n│       ├── nF12.d_18.model_selection_candidates.p\n│       ├── nF12.d_18.posterior.count.tsv.gz\n│       ├── nF12.d_18.prj_18.r_4.fit_result.tsv.gz\n│       └── nF12.d_18.prj_18.r_4.posterior.count.tsv.gz\n├── batched.matrix.tsv.gz\n├── hexagon.d_12.tsv.gz\n├── hexagon.d_18.tsv.gz\n├── Makefile\n└── sort_decode.sh"
  },
  {
    "objectID": "posts/fov-qc/index.html#introduction",
    "href": "posts/fov-qc/index.html#introduction",
    "title": "FOV QC from single-cell gene expression in spatial dataset",
    "section": "Introduction",
    "text": "Introduction\nIn most CosMx experiments, FOVs perform comparably and data analyses do not require consideration of FOV as a relevant variable. FOVs can, however, experience technical effects, which in some cases require quality control considerations (ex: cells in an FOV clustering as the same cell type). We recommend that FOV QC be performed early in data analysis. Should lower quality FOVs be detected, we recommend they are excluded.\nHere we will describe known FOV-level quality considerations and will show use of R code for detecting impacted FOVs."
  },
  {
    "objectID": "posts/fov-qc/index.html#fov-quality",
    "href": "posts/fov-qc/index.html#fov-quality",
    "title": "FOV QC from single-cell gene expression in spatial dataset",
    "section": "FOV quality",
    "text": "FOV quality\nLower quality FOVs generally result in reduced overall gene expression or reduced signal from select genes. An example of such a phenomena is shown below where a gene with impacted signal is muted in specific FOVs (top left); other genes behave consistently.\n\n\n\n\n\n\n\n\n\nPotential causes for lower FOV quality (e.g. lower relative signal for all/select genes for a given FOV compared to majority of FOVs) include tissue/section quality, high autofluorescence, and inadequate fiducials."
  },
  {
    "objectID": "posts/fov-qc/index.html#approach-to-fov-qc",
    "href": "posts/fov-qc/index.html#approach-to-fov-qc",
    "title": "FOV QC from single-cell gene expression in spatial dataset",
    "section": "Approach to FOV QC",
    "text": "Approach to FOV QC\nFirst, we will apply a permissive look at FOV signal strength, filtering out FOVs with &gt;60% loss of signal across most of their spatial span.\nThen we will look for FOVs with potentially biased gene expression profiles. Because FOV quality issues can be linked to fluorescent reporters (multiple reporters encode a gene)\nwe will look at the level of reporters, not genes.\nSpecifically, for each reporter, we’ll look for FOVs where genes using the reporter are underexpressed compared to comparable regions elsewhere. And we’ll fail reporter cycles with low quality for multiple reporters.\n\nTechnical details:\nWe place a 7x7 grid across each FOV. For each grid square, we find the 10 most similar squares in other FOVs, with “similar” being based on the square’s expression profile (we also only accept one neighbor per other FOV).\nThen we score FOVs for signal loss. For each square, we compare its total counts to its comparator squares. For each reporter bit, this gives us 49 contrasts. If most (75%) of an FOV’s squares have low total counts compared to comparators, we flag the FOV.\nTo score FOVs for bias, we use a similar approach. For each reporter, we take the genes using the bit, and we contrast their expression in the square vs. in the average of the 10 most similar squares elsewhere. When an FOV’s grid squares consistently underexpress the relevant gene set, we flag the FOV.\nBelow we demonstrate this approach, looking at a tissue with particularly dramatic FOV effects.\n\n\n\n\n\n\n\n\n\nOn the left, we plot expression of a single reporter bit (c12B = reporter cycle 12, color Blue) impacted by FOV effects. FOV 19 has almost entirely lost expression of the genes from this reporter, and FOV 16 looks as though it could be losing some expression.\nOn the right, we show the results of our FOV QC approach: for a 7x7 grid within each FOV, we see estimated change in reporter bit expression compared to similar grid squares in other FOVs. FOV 19 still stands out as an obvious quality control flag. In contrast, the low expression in FOV 16 is shown to be similar - sometimes higher, sometimes lower - than biologically similar regions elsewhere in the tissue. FOV 22 now stands out as having perhaps increased expression of the bit, but the high log2(fold-changes) (red squares) appear to follow spatially smooth biology and not the sharp FOV borders, suggesting we need not worry about technical quality issues in this FOV.\nOur tool summarize our output across FOVs x reporter bits with plots like the below:\n\n\n\n\n\n\n\n\n\nIn this example, 2 reporter bits from reporter cycle 12 were flagged, as was one bit from reporter cycle 18. Because low quality impacts reporter cycles, not the individual colors within them, we only flag FOVs in which at least two reporters/colors from a single reporter cycle appear anomalous. This rule helps avoid flagging FOVs due to biological variability. So in this example, FOV 19 would be flagged since it had 2 bits flagged in reporter cycle 12, whereas FOV 18 would not be flagged since it had only one bit flagged in reporter cycle 18."
  },
  {
    "objectID": "posts/fov-qc/index.html#code",
    "href": "posts/fov-qc/index.html#code",
    "title": "FOV QC from single-cell gene expression in spatial dataset",
    "section": "Code",
    "text": "Code\nVignette for FOV QC can be found here with functions stored under _code/FOV QC folder in the repository. The gene-to-barcode mappings needed by this approach are saved in the same folder.\nWe advise this approach be applied separately to each slide or tissue in a study.\n\n\n\n\n\n\nNote\n\n\n\nThis experimental approach is new as of April 2024 and is lightly tested. Please use thoughtfully while considering biological context."
  },
  {
    "objectID": "posts/cell-typing-cheat-sheets/index.html",
    "href": "posts/cell-typing-cheat-sheets/index.html",
    "title": "Cheat sheets for cell typing, powered by LLMs and the Human Protein Atlas",
    "section": "",
    "text": "A key part of any cell typing attempt is examination of each cell type’s spatial distributions. These patterns can strongly suggest which cell type an unknown cluster is, and they are useful for confirming putative cell type assignments.\nThe Human Protein Atlas is a powerful resource for these exercises. For almost every cell type in the human body, the HPA contains high-res IHC images of a protein that is highly specific to the cell type.\nHere, with the help of LMMs, we have compiled “cheat sheets” for a small collection of tissues. Each sheet delineates the cell types present in a tissue type, suggests a marker protein that can be found in the HPA, and links to the relevant HPA page and to a relevant IHC image.\nHere’s a glance at one:\n\n\n\nLung cheat sheet\n\n\nCaveat: this information was generated by an LLM and reviewed/edited by humans. As with any product of an LMM (or a human), give any individual claim less than total credence.\nWe are posting this now with just 3 tissues covered, with the plan to add more later. If you mimic our approach for another tissue, feel free to send us your own cheat sheets, and we’ll host them here for the community."
  },
  {
    "objectID": "posts/cell-typing-cheat-sheets/index.html#introduction",
    "href": "posts/cell-typing-cheat-sheets/index.html#introduction",
    "title": "Cheat sheets for cell typing, powered by LLMs and the Human Protein Atlas",
    "section": "",
    "text": "A key part of any cell typing attempt is examination of each cell type’s spatial distributions. These patterns can strongly suggest which cell type an unknown cluster is, and they are useful for confirming putative cell type assignments.\nThe Human Protein Atlas is a powerful resource for these exercises. For almost every cell type in the human body, the HPA contains high-res IHC images of a protein that is highly specific to the cell type.\nHere, with the help of LMMs, we have compiled “cheat sheets” for a small collection of tissues. Each sheet delineates the cell types present in a tissue type, suggests a marker protein that can be found in the HPA, and links to the relevant HPA page and to a relevant IHC image.\nHere’s a glance at one:\n\n\n\nLung cheat sheet\n\n\nCaveat: this information was generated by an LLM and reviewed/edited by humans. As with any product of an LMM (or a human), give any individual claim less than total credence.\nWe are posting this now with just 3 tissues covered, with the plan to add more later. If you mimic our approach for another tissue, feel free to send us your own cheat sheets, and we’ll host them here for the community."
  },
  {
    "objectID": "posts/cell-typing-cheat-sheets/index.html#cheat-sheets-for-tissue-specific-cell-typing",
    "href": "posts/cell-typing-cheat-sheets/index.html#cheat-sheets-for-tissue-specific-cell-typing",
    "title": "Cheat sheets for cell typing, powered by LLMs and the Human Protein Atlas",
    "section": "2 Cheat sheets for tissue-specific cell typing:",
    "text": "2 Cheat sheets for tissue-specific cell typing:\n\nKidney\nPancreas\nLung"
  },
  {
    "objectID": "posts/cell-typing-cheat-sheets/index.html#example-llm-prompts-for-generating-your-own-cheat-sheet",
    "href": "posts/cell-typing-cheat-sheets/index.html#example-llm-prompts-for-generating-your-own-cheat-sheet",
    "title": "Cheat sheets for cell typing, powered by LLMs and the Human Protein Atlas",
    "section": "3 Example LLM prompts for generating your own cheat sheet:",
    "text": "3 Example LLM prompts for generating your own cheat sheet:\nWe employed variations of the below to elicit these cheat sheets from a LLM. The whole exercise should take ~2 minutes per cell type.\n\n\n\n\n\n\nPrompt to get good markers\n\n\n\nCan you please give me a table of the major cell types in the human lung, and 1-3 good marker genes or proteins for each one? (Marker proteins are better - we’ll be looking them up in the Human protein atlas next.)\n\n\n\n\n\n\n\n\nPrompt to get HPA links\n\n\n\nNow please add links to the Human Protein Atlas tissue page for the best marker for each cell type\n\n\nHere we exercised some curatorial judgment and selected the best IHC image by eye. We appended the links to those images to the table generated from the previous prompt. See the final column below:\n\n\n\nAdding links to IHC images\n\n\n\n\n\n\n\n\nPrompt to compile into HTML file\n\n\n\nOK, now make me an html please from the below table. The links to images should be thumbnails.\n\n\nNow copy the response to notepad, save as .html, and you’re done!"
  },
  {
    "objectID": "posts/squidpy-essentials/squidpy-essentials.html",
    "href": "posts/squidpy-essentials/squidpy-essentials.html",
    "title": "Using Squidpy with AtoMx® SIP exports",
    "section": "",
    "text": "Elucidating the spatial distribution of RNA transcripts and protein is one of the fundamental utilities of the CosMx® Spatial Molecular Imager (SMI). When it comes to analysis, the AtoMx® Spatial Informatics Portal (SIP) is an end-to-end solution that has several advantages including built-in analysis modules, data storage, and the ability to analyze from a browser window. For fully custom analyses, the SIP also has the ability to export the data.\nThere are a growing number of open-sourced analysis solutions that can analyze and visualize SMI data. For example, Giotto (Dries et al. 2021) has been available for a few years, uses a range of algorithms, and has ways to visualize tissue images built in. More recently, Seurat (Hao et al. 2024), another R package (and another artist!), has added image viewing capabilities into its workflow. For vignettes on how to analyze and visualize SMI data with Seurat, check out our recent blog post or the vignette from Seurat’s website.\nFor python users, I find squidpy (Palla et al. 2022) works well, is feature-rich, and is speedy. Part of this efficiency is thanks to the anndata package. For more info on creating anndata objects with SMI data, see this post. Squidpy also has a built-in function to read in SMI data, read.nanostring, that reads in the counts data, metadata, and optionally the field of view (FOV) file and image data. The developers also have a vignette that uses a slide from the first public data release of SMI data (He et al. 2022). Note that the example dataset in that vignette uses a legacy file format that differs slightly compared to AtoMx SIP. For more information on the differences, see this post.\nIn this blog post, I’ll show you how to:\n\nSection 2 export the squidpy-relevant files from AtoMx SIP\nSection 3 (and Appendix Section 7.1) tips for installing squidpy\nSection 4 analysis examples without spatial images\nSection 5 how to pivot your AtoMx SIP-exported data into a format that can be used with squidpy and image-based analysis examples\n\n\n\n\n\n\n\nNote\n\n\n\nIn this blog post I provide some analysis examples but this is not intended to provide recommendations of parameters, clustering approaches, etc. I have not tested my example dataset on all of the squidpy functions so there may be errors.\nLike other items in our CosMx Analysis Scratch Space, the usual caveats and license applies."
  },
  {
    "objectID": "posts/squidpy-essentials/squidpy-essentials.html#reading-expression-and-metadata-only",
    "href": "posts/squidpy-essentials/squidpy-essentials.html#reading-expression-and-metadata-only",
    "title": "Using Squidpy with AtoMx® SIP exports",
    "section": "4.1 Reading expression and metadata only",
    "text": "4.1 Reading expression and metadata only\nCreate an anndata object like this:\n\n\nPython\n\n\nfrom pathlib import Path\nimport os\nimport numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nimport scanpy as sc\nimport squidpy as sq\n\nflat_file_dir = 'path/to/breast_cancer_example/flatFiles/AUG29_13INTEGR_6K_BRST_PS_S2'\nmeta_file = [item for item in os.listdir(flat_file_dir) if 'metadata_file' in item][0]\ncounts_file = [item for item in os.listdir(flat_file_dir) if 'exprMat_file' in item][0]\n\nadata0 = sq.read.nanostring(\n    path=flat_file_dir,\n    counts_file=counts_file,\n    meta_file=meta_file\n)\nadata0\n\nAnnData object with n_obs × n_vars = 80073 × 6524\n    obs: 'RNA_nbclust_132d0e1b.dc7d.48de.814b.a88cd8d14f03_1_clusters', 'RNA_nbclust_132d0e1b.dc7d.48de.814b.a88cd8d14f03_1_posterior_probability', 'RNA_nbclust_9685fc9a.4f00.4267.99c1.ce1cb894807f_1_clusters', 'RNA_nbclust_9685fc9a.4f00.4267.99c1.ce1cb894807f_1_posterior_probability', 'cell', 'nCount_RNA', 'nFeature_RNA', 'nCount_negprobes', 'nFeature_negprobes', 'fov', 'Area', 'AspectRatio', 'Width', 'Height', 'Mean.PanCK', 'Max.PanCK', 'Mean.CD68_CK8_18', 'Max.CD68_CK8_18', 'Mean.CD298_B2M', 'Max.CD298_B2M', 'Mean.CD45', 'Max.CD45', 'Mean.DAPI', 'Max.DAPI', 'cell_id', 'assay_type', 'version', 'Run_Tissue_name', 'Panel', 'cellSegmentationSetId', 'cellSegmentationSetName', 'slide_ID', 'CenterX_global_px', 'CenterY_global_px', 'unassignedTranscripts', 'nCount_falsecode', 'nFeature_falsecode', 'Area.um2', 'propNegative', 'complexity', 'errorCtEstimate', 'percOfDataFromError', 'qcFlagsRNACounts', 'qcFlagsCellCounts', 'qcFlagsCellPropNeg', 'qcFlagsCellComplex', 'qcFlagsCellArea', 'qcCellsFlagged', 'median_negprobes', 'negprobes_quantile_0.9', 'median_RNA', 'RNA_quantile_0.9', 'nCell', 'nCount', 'nCountPerCell', 'nFeaturePerCell', 'propNegativeCellAvg', 'complexityCellAvg', 'errorCtPerCellEstimate', 'percOfDataFromErrorPerCell', 'qcFlagsFOV', 'i.median_negprobes', 'i.negprobes_quantile_0.9', 'i.median_RNA', 'i.RNA_quantile_0.9', 'cell_ID'\n    uns: 'spatial'\n    obsm: 'spatial', 'spatial_fov'\n\n\n\n\n\n\nNote\n\n\n\nThe column names that you have may differ from the ones above. That’s because the example dataset has been processed in AtoMx SIP which created additional columns (e.g., RNA_nbclust_[GUID]_1_clusters). For more information on the expected columns from flat file exports, see the metadata column descriptions."
  },
  {
    "objectID": "posts/squidpy-essentials/squidpy-essentials.html#including-the-fov-file",
    "href": "posts/squidpy-essentials/squidpy-essentials.html#including-the-fov-file",
    "title": "Using Squidpy with AtoMx® SIP exports",
    "section": "4.2 Including the FOV file",
    "text": "4.2 Including the FOV file\nIf we try to read in the optional FOV file generated in AtoMx SIP using squidpy v1.5.0, we might get an error stating “Index fov invalid”.\n\n\nPython\n\n\nfov_file = [item for item in os.listdir(flat_file_dir) if 'fov_positions_file' in item][0]\n\nadata = sq.read.nanostring(\n    path=flat_file_dir,\n    counts_file=counts_file,\n    meta_file=meta_file,\n    fov_file=fov_file\n)\n\n\n\n\nClick to show error\n---------------------------------------------------------------------------\nValueError                                Traceback (most recent call last)\nCell In[23], line 3\n      1 fov_file = [item for item in os.listdir(flat_file_dir) if 'fov_positions_file' in item][0]\n----&gt; 3 adata = sq.read.nanostring(\n      4     path=flat_file_dir,\n      5     counts_file=counts_file,\n      6     meta_file=meta_file,\n      7     fov_file=fov_file\n      8 )\n\nFile &lt;project path&gt;/.venv/lib/python3.10/site-packages/squidpy/read/_read.py:266, in nanostring(path, counts_file, meta_file, fov_file)\n    263                     continue\n    265 if fov_file is not None:\n--&gt; 266     fov_positions = pd.read_csv(path / fov_file, header=0, index_col=fov_key)\n    267     for fov, row in fov_positions.iterrows():\n    268         try:\n\nFile &lt;project path&gt;/.venv/lib/python3.10/site-packages/pandas/io/parsers/readers.py:1026, in read_csv(filepath_or_buffer, sep, delimiter, header, names, index_col, usecols, dtype, engine, converters, true_values, false_values, skipinitialspace, skiprows, skipfooter, nrows, na_values, keep_default_na, na_filter, verbose, skip_blank_lines, parse_dates, infer_datetime_format, keep_date_col, date_parser, date_format, dayfirst, cache_dates, iterator, chunksize, compression, thousands, decimal, lineterminator, quotechar, quoting, doublequote, escapechar, comment, encoding, encoding_errors, dialect, on_bad_lines, delim_whitespace, low_memory, memory_map, float_precision, storage_options, dtype_backend)\n   1013 kwds_defaults = _refine_defaults_read(\n   1014     dialect,\n   1015     delimiter,\n   (...)\n   1022     dtype_backend=dtype_backend,\n   1023 )\n   1024 kwds.update(kwds_defaults)\n-&gt; 1026 return _read(filepath_or_buffer, kwds)\n\nFile &lt;project path&gt;/.venv/lib/python3.10/site-packages/pandas/io/parsers/readers.py:626, in _read(filepath_or_buffer, kwds)\n    623     return parser\n    625 with parser:\n--&gt; 626     return parser.read(nrows)\n\nFile &lt;project path&gt;/.venv/lib/python3.10/site-packages/pandas/io/parsers/readers.py:1923, in TextFileReader.read(self, nrows)\n   1916 nrows = validate_integer(\"nrows\", nrows)\n   1917 try:\n   1918     # error: \"ParserBase\" has no attribute \"read\"\n   1919     (\n   1920         index,\n   1921         columns,\n   1922         col_dict,\n-&gt; 1923     ) = self._engine.read(  # type: ignore[attr-defined]\n   1924         nrows\n   1925     )\n   1926 except Exception:\n   1927     self.close()\n\nFile &lt;project path&gt;/.venv/lib/python3.10/site-packages/pandas/io/parsers/c_parser_wrapper.py:333, in CParserWrapper.read(self, nrows)\n    330     data = {k: v for k, (i, v) in zip(names, data_tups)}\n    332     names, date_data = self._do_date_conversions(names, data)\n--&gt; 333     index, column_names = self._make_index(date_data, alldata, names)\n    335 return index, column_names, date_data\n\nFile &lt;project path&gt;/.venv/lib/python3.10/site-packages/pandas/io/parsers/base_parser.py:371, in ParserBase._make_index(self, data, alldata, columns, indexnamerow)\n    368     index = None\n    370 elif not self._has_complex_date_col:\n--&gt; 371     simple_index = self._get_simple_index(alldata, columns)\n    372     index = self._agg_index(simple_index)\n    373 elif self._has_complex_date_col:\n\nFile &lt;project path&gt;/.venv/lib/python3.10/site-packages/pandas/io/parsers/base_parser.py:403, in ParserBase._get_simple_index(self, data, columns)\n    401 index = []\n    402 for idx in self.index_col:\n--&gt; 403     i = ix(idx)\n    404     to_remove.append(i)\n    405     index.append(data[i])\n\nFile &lt;project path&gt;/.venv/lib/python3.10/site-packages/pandas/io/parsers/base_parser.py:398, in ParserBase._get_simple_index.&lt;locals&gt;.ix(col)\n    396 if not isinstance(col, str):\n    397     return col\n--&gt; 398 raise ValueError(f\"Index {col} invalid\")\n\nValueError: Index fov invalid\n\n\nThis error arises because of a format change that is detailed in this post. A simple fix is to adjust the column name in the fov file from “FOV” to the legacy “fov” like this:\n\n\nPython\n\nfov_file = [item for item in os.listdir(flat_file_dir) if 'fov_positions_file' in item][0]\n\nfov_df = pd.read_csv(os.path.join(flat_file_dir, fov_file))\nif 'FOV' in fov_df.columns:\n  print(\"Refactoring file to older format.\")\n  # Rename 'FOV' column to 'fov'\n  fov_df.rename(columns={'FOV': 'fov'}, inplace=True)\n  # have fov_file reference the new, formatted file and write it\n  fov_file = os.path.join(flat_file_dir,'fov_positions_formatted.csv')\n  fov_df.to_csv(fov_file, index=False)\n\nadata1 = sq.read.nanostring(\n    path=flat_file_dir,\n    counts_file=counts_file,\n    meta_file=meta_file,\n    fov_file=fov_file\n)\n\n\n\nRefactoring file to older format.\n\nAnnData object with n_obs × n_vars = 80073 × 6524\n    obs: 'RNA_nbclust_132d0e1b.dc7d.48de.814b.a88cd8d14f03_1_clusters', 'RNA_nbclust_132d0e1b.dc7d.48de.814b.a88cd8d14f03_1_posterior_probability', 'RNA_nbclust_9685fc9a.4f00.4267.99c1.ce1cb894807f_1_clusters', 'RNA_nbclust_9685fc9a.4f00.4267.99c1.ce1cb894807f_1_posterior_probability', 'cell', 'nCount_RNA', 'nFeature_RNA', 'nCount_negprobes', 'nFeature_negprobes', 'fov', 'Area', 'AspectRatio', 'Width', 'Height', 'Mean.PanCK', 'Max.PanCK', 'Mean.CD68_CK8_18', 'Max.CD68_CK8_18', 'Mean.CD298_B2M', 'Max.CD298_B2M', 'Mean.CD45', 'Max.CD45', 'Mean.DAPI', 'Max.DAPI', 'cell_id', 'assay_type', 'version', 'Run_Tissue_name', 'Panel', 'cellSegmentationSetId', 'cellSegmentationSetName', 'slide_ID', 'CenterX_global_px', 'CenterY_global_px', 'unassignedTranscripts', 'nCount_falsecode', 'nFeature_falsecode', 'Area.um2', 'propNegative', 'complexity', 'errorCtEstimate', 'percOfDataFromError', 'qcFlagsRNACounts', 'qcFlagsCellCounts', 'qcFlagsCellPropNeg', 'qcFlagsCellComplex', 'qcFlagsCellArea', 'qcCellsFlagged', 'median_negprobes', 'negprobes_quantile_0.9', 'median_RNA', 'RNA_quantile_0.9', 'nCell', 'nCount', 'nCountPerCell', 'nFeaturePerCell', 'propNegativeCellAvg', 'complexityCellAvg', 'errorCtPerCellEstimate', 'percOfDataFromErrorPerCell', 'qcFlagsFOV', 'i.median_negprobes', 'i.negprobes_quantile_0.9', 'i.median_RNA', 'i.RNA_quantile_0.9', 'cell_ID'\n    uns: 'spatial'\n    obsm: 'spatial', 'spatial_fov'"
  },
  {
    "objectID": "posts/squidpy-essentials/squidpy-essentials.html#analysis",
    "href": "posts/squidpy-essentials/squidpy-essentials.html#analysis",
    "title": "Using Squidpy with AtoMx® SIP exports",
    "section": "4.3 Analysis",
    "text": "4.3 Analysis\n\n\n\n\n\n\nNote\n\n\n\nPlease note that the code in this section is an example and not a recommendation for specific thresholding, QC filtering, clustering parmaterization, etc. of SMI data.\n\n\nWith the expression and metadata loaded, we can run exploratory data analysis similar to what was described in the squidpy vignette. There are some adjustments to squidpy’s vignette that are needed. These adjustments reflect the flat file format changes (detailed here).\n\n\nPython\n\n\n# Place control targets into separate variables\nadata1.var[\"Negative\"] = adata1.var_names.str.startswith(\"Negative\")\nadata1.var[\"SystemControl\"] = adata1.var_names.str.startswith(\"SystemControl\")\nadata1\n\nAnnData object with n_obs × n_vars = 80073 × 6524\n    obs: 'RNA_nbclust_132d0e1b.dc7d.48de.814b.a88cd8d14f03_1_clusters', 'RNA_nbclust_132d0e1b.dc7d.48de.814b.a88cd8d14f03_1_posterior_probability', 'RNA_nbclust_9685fc9a.4f00.4267.99c1.ce1cb894807f_1_clusters', 'RNA_nbclust_9685fc9a.4f00.4267.99c1.ce1cb894807f_1_posterior_probability', 'cell', 'nCount_RNA', 'nFeature_RNA', 'nCount_negprobes', 'nFeature_negprobes', 'fov', 'Area', 'AspectRatio', 'Width', 'Height', 'Mean.PanCK', 'Max.PanCK', 'Mean.CD68_CK8_18', 'Max.CD68_CK8_18', 'Mean.CD298_B2M', 'Max.CD298_B2M', 'Mean.CD45', 'Max.CD45', 'Mean.DAPI', 'Max.DAPI', 'cell_id', 'assay_type', 'version', 'Run_Tissue_name', 'Panel', 'cellSegmentationSetId', 'cellSegmentationSetName', 'slide_ID', 'CenterX_global_px', 'CenterY_global_px', 'unassignedTranscripts', 'nCount_falsecode', 'nFeature_falsecode', 'Area.um2', 'propNegative', 'complexity', 'errorCtEstimate', 'percOfDataFromError', 'qcFlagsRNACounts', 'qcFlagsCellCounts', 'qcFlagsCellPropNeg', 'qcFlagsCellComplex', 'qcFlagsCellArea', 'qcCellsFlagged', 'median_negprobes', 'negprobes_quantile_0.9', 'median_RNA', 'RNA_quantile_0.9', 'nCell', 'nCount', 'nCountPerCell', 'nFeaturePerCell', 'propNegativeCellAvg', 'complexityCellAvg', 'errorCtPerCellEstimate', 'percOfDataFromErrorPerCell', 'qcFlagsFOV', 'i.median_negprobes', 'i.negprobes_quantile_0.9', 'i.median_RNA', 'i.RNA_quantile_0.9', 'cell_ID'\n    var: 'Negative', 'SystemControl'\n    uns: 'spatial'\n    obsm: 'spatial', 'spatial_fov'\nWe can calculate QC metrics with scanpy’s (Wolf, Angerer, and Theis 2018) pre-processing tool calculate_qc_metrics method. In the code below, we are going to add Negatives and SystemControls as the qc_var argument (which will add cell-level columns to obs). In addition, target-level columns are added to var.\n\n\nPython\n\nsc.pp.calculate_qc_metrics(adata1, qc_vars=[\"Negative\", \"SystemControl\"], inplace=True)\nadata1\n\nAnnData object with n_obs × n_vars = 80073 × 6524\n    obs: 'RNA_nbclust_132d0e1b.dc7d.48de.814b.a88cd8d14f03_1_clusters', 'RNA_nbclust_132d0e1b.dc7d.48de.814b.a88cd8d14f03_1_posterior_probability', 'RNA_nbclust_9685fc9a.4f00.4267.99c1.ce1cb894807f_1_clusters', 'RNA_nbclust_9685fc9a.4f00.4267.99c1.ce1cb894807f_1_posterior_probability', 'cell', 'nCount_RNA', 'nFeature_RNA', 'nCount_negprobes', 'nFeature_negprobes', 'fov', 'Area', 'AspectRatio', 'Width', 'Height', 'Mean.PanCK', 'Max.PanCK', 'Mean.CD68_CK8_18', 'Max.CD68_CK8_18', 'Mean.CD298_B2M', 'Max.CD298_B2M', 'Mean.CD45', 'Max.CD45', 'Mean.DAPI', 'Max.DAPI', 'cell_id', 'assay_type', 'version', 'Run_Tissue_name', 'Panel', 'cellSegmentationSetId', 'cellSegmentationSetName', 'slide_ID', 'CenterX_global_px', 'CenterY_global_px', 'unassignedTranscripts', 'nCount_falsecode', 'nFeature_falsecode', 'Area.um2', 'propNegative', 'complexity', 'errorCtEstimate', 'percOfDataFromError', 'qcFlagsRNACounts', 'qcFlagsCellCounts', 'qcFlagsCellPropNeg', 'qcFlagsCellComplex', 'qcFlagsCellArea', 'qcCellsFlagged', 'median_negprobes', 'negprobes_quantile_0.9', 'median_RNA', 'RNA_quantile_0.9', 'nCell', 'nCount', 'nCountPerCell', 'nFeaturePerCell', 'propNegativeCellAvg', 'complexityCellAvg', 'errorCtPerCellEstimate', 'percOfDataFromErrorPerCell', 'qcFlagsFOV', 'i.median_negprobes', 'i.negprobes_quantile_0.9', 'i.median_RNA', 'i.RNA_quantile_0.9', 'cell_ID', 'n_genes_by_counts', 'log1p_n_genes_by_counts', 'total_counts', 'log1p_total_counts', 'pct_counts_in_top_50_genes', 'pct_counts_in_top_100_genes', 'pct_counts_in_top_200_genes', 'pct_counts_in_top_500_genes', 'total_counts_Negative', 'log1p_total_counts_Negative', 'pct_counts_Negative', 'total_counts_SystemControl', 'log1p_total_counts_SystemControl', 'pct_counts_SystemControl'\n    var: 'Negative', 'SystemControl', 'n_cells_by_counts', 'mean_counts', 'log1p_mean_counts', 'pct_dropout_by_counts', 'total_counts', 'log1p_total_counts'\n    uns: 'spatial'\n    obsm: 'spatial', 'spatial_fov'\nWe can explore these cell-level and target-level QC metrics with visuals using the seaborn package. For example the code below generates Figure 3 and shows how the number of unique genes in a cell correlates with the total number of transcripts in a cell.\n\n\nPython\n\n\nsns.jointplot(\n    data=adata1.obs,\n    x=\"total_counts\",\n    y=\"n_genes_by_counts\",\n    kind=\"scatter\",\n    alpha=0.2\n)\nplt.savefig(\"figures/fig-qc.png\", dpi=200)\n\n\n\n\n\n\n\n\n\n\nFigure 3: Unique genes by total counts. Each dot represents a cell. Y-axis: the number of genes with postive counts in a cell. X-axis the sum of counts for a cell.\n\n\n\n\n\nThe total Negative probe counts by total counts is shown below and Figure 4.\n\n\nPython\n\n\nsns.jointplot(\n    data=adata1.obs,\n    x=\"total_counts\",\n    y=\"total_counts_Negative\",\n    kind=\"scatter\",\n    alpha=0.2\n)\nplt.savefig(\"figures/fig-qc1.png\", dpi=200)\n\n\n\n\n\n\n\n\n\n\nFigure 4: The number of negative counts (Y) relative to the total counts (X) per cell.\n\n\n\n\n\nWe see that the proportion of negative counts relative to total counts is:\n\n\nPython\n\nadata1.obs[\"total_counts_Negative\"].sum() / adata1.obs[\"total_counts\"].sum()\n\n\n0.00041567286608445926 (i.e., 0.04%)\n\nHistograms of total transcripts, total unique genes per cell, and total transcrips per FOV can be seen in Figure 5.\n\n\nPython\n\nfig, axs = plt.subplots(1, 3, figsize=(15, 4))\n\naxs[0].set_title(\"Total transcripts per cell\")\nsns.histplot(\n    adata1.obs[\"total_counts\"],\n    kde=False,\n    ax=axs[0],\n)\n\naxs[1].set_title(\"Unique transcripts per cell\")\nsns.histplot(\n    adata1.obs[\"n_genes_by_counts\"],\n    kde=False,\n    ax=axs[1],\n)\n\naxs[2].set_title(\"Transcripts per FOV\")\nsns.histplot(\n    adata1.obs.groupby(\"fov\").sum()[\"total_counts\"],\n    kde=False,\n    ax=axs[2],\n)\nplt.savefig(\"figures/fig-qc2.png\", dpi=200)\n\n\n\n\n\n\n\n\n\n\nFigure 5: Total counts per cell (left), total unique genes per cell (middle) and total transcripts per FOV (right).\n\n\n\n\n\nWe can filter, normalize, and cluster with scanpy’s functions. For a full list of available functions, see scanpy’s API documentation.\n\n\nPython\n\nadata1.shape\n\n\n(80073, 6524)\n\n\n\nPython\n\nsc.pp.filter_cells(adata1, min_counts=250)\nsc.pp.filter_genes(adata1, min_cells=1000)\nadata1.shape\n\n\n(69293, 6177)\n\n\n\nPython\n\nadata1.layers[\"counts\"] = adata1.X.copy()\nsc.pp.normalize_total(adata1, inplace=True, exclude_highly_expressed=True)\nsc.pp.log1p(adata1)\nsc.pp.pca(adata1, n_comps=50)\nsc.pp.neighbors(adata1)\nsc.tl.umap(adata1, min_dist=0.2, spread=1)\nsc.tl.leiden(adata1)\n\n\n\nPython\n\nadata1.obs[\"logpMean.PanCK\"] = np.log1p(adata1.obs['Mean.PanCK'])\nsc.pl.umap(\n    adata1,\n    color=[\"logpMean.PanCK\",\"leiden\"]\n)\n\n\n\n\n\n\n\n\n\nFigure 6: UMAP figures with cells colored by natural log Mean PanCK expression (left) and Leiden clusters (right)."
  },
  {
    "objectID": "posts/squidpy-essentials/squidpy-essentials.html#rearrange-data-files-to-match-squidpys-layout",
    "href": "posts/squidpy-essentials/squidpy-essentials.html#rearrange-data-files-to-match-squidpys-layout",
    "title": "Using Squidpy with AtoMx® SIP exports",
    "section": "5.1 Rearrange data files to match squidpy’s layout",
    "text": "5.1 Rearrange data files to match squidpy’s layout\nIf we take a look one of the NSCLC public datasets from He et al. (2022) (Lung5_Rep1), we can see the expected file structure has four folders (CellComposite, CellLabels, CellOverlay, and CompartmentLabels) and four flat files.\n\n\n\nTerminal\n\ntree -L 3\n\n├── Lung5_Rep1-Flat_files_and_images\n│   ├── CellComposite\n│   │   ├── CellComposite_F001.jpg\n|   |   ...\n│   │   └── CellComposite_F032.jpg\n│   ├── CellLabels\n│   │   ├── CellLabels_F001.tif\n|   |   ...\n│   │   └── CellLabels_F032.tif\n│   ├── CellOverlay\n│   │   ├── CellOverlay_F001.jpg\n|   |   ...\n│   │   └── CellOverlay_F032.jpg\n│   ├── CompartmentLabels\n│   │   ├── CompartmentLabels_F001.tif\n|   |   ...\n│   │   └── CompartmentLabels_F032.tif\n│   ├── Lung5_Rep1_exprMat_file.csv\n│   ├── Lung5_Rep1_fov_positions_file.csv\n│   ├── Lung5_Rep1_metadata_file.csv\n│   └── Lung5_Rep1_tx_file.csv\n\n\nThis file structure is actually a subset of the raw data and flat files that are exported from AtoMx SIP.\n\n\n\nTerminal\n\ntree -L 3\n\n├── RawFiles\n│   └── &lt;flow cell&gt;\n│       └── &lt;slide&gt;\n│           ├── AnalysisResults\n│           │   └── muy2ybakqy\n│           ├── CellStatsDir\n│           │   ├── &lt;slide&gt;_C902_P02_To_P01_RegStats.csv\n│           │   ├── CellComposite\n│           │   ├── CellOverlay\n│           │   ├── FOV001\n│           │   │   ├── CellBoundaries_F001.csv\n│           │   │   ├── CellBoundaries_F001_935.fz\n│           │   │   ├── CellLabels_F001.tif\n│           │   │   ├── CompartmentLabels_F001.tif\n│           │   │   ├── Run_86906312-688f-4f31-9fc5-48b04db5f958_&lt;slide&gt;_Cell_Stats_F001.csv\n│           │   │   └── Run_86906312-688f-4f31-9fc5-48b04db5f958_FOV001__complete_code_cell_target_call_coord.cs\n│           │   ...\n│           │   ├── FOV064\n│           │   └── Morphology2D\n│           └── RunSummary\n│               ├── 75d021be-b81e-4d7d-ad28-d390a13da7ad.mkit\n│               ├── Beta15_Affine_Transform_20221118.csv\n│               ├── Distortion\n│               ├── FovTracking\n│               ├── Morphology_ChannelID_Dictionary.txt\n│               ├── Run86906312-688f-4f31-9fc5-48b04db5f958_&lt;slide&gt;_Beta15_RNA_SpatialBC_Metrics4D.csv\n│               ├── Run_86906312-688f-4f31-9fc5-48b04db5f958_&lt;slide&gt;_Beta15_ExptConfig.txt\n│               ├── SampleSlide_PlaneFit_&lt;slide&gt;_History.csv\n│               ├── Shading\n│               ├── c902.fovs.csv\n│               ├── latest.af.fovs.csv\n│               └── latest.fovs.csv\n├── flatFiles\n│   └── &lt;flow cell&gt;\n│       ├── &lt;flow cell&gt;_exprMat_file.csv.gz\n│       ├── &lt;flow cell&gt;_fov_positions_file.csv.gz\n│       ├── &lt;flow cell&gt;_metadata_file.csv.gz\n│       └── fov_positions_formatted.csv\n\n\nSo in order to read in image data into squidpy, we must first rearrange our folders. We can do this manually by moving, copying, or linking files to match the expected format. Normally I am a big fan of symbolic links for just this situation. However, I have noticed that read.nanostring can have an error when using symbolic links for some of the files (error not shown). So for simplicity I will make a copy of the data and place them into a new folder sample_dir_formatted.\n\n\n\nTerminal\n\n# Note that this code works for a single slide. If exporting\n# multiple slides, some modification might be necessary.\n\n# cd to parent directory\n\n# create a directory adjacent to RawData and flatFiles\nmkdir -p sample_dir_formatted && cd $_\n\n# Add flat files\nfor file in $(ls ../flatFiles/*/*csv*); do cp $file ./; done\n\n# Add folders\ncp -r ../RawFiles/*/*/CellStatsDir/CellComposite ./\ncp -r ../RawFiles/*/*/CellStatsDir/CellOverlay ./\n\nmkdir -p CellLabels\nfor file in $(ls ../RawFiles/*/*/CellStatsDir/FOV*/CellLabels*); do cp $file ./CellLabels/ ; done\nrm ./CellLabels/._Cell*\n  \nmkdir -p CompartmentLabels\nfor file in $(ls ../RawFiles/*/*/CellStatsDir/FOV*/CompartmentLabels*); do cp $file ./CompartmentLabels/ ; done\n\n\nThe file structure of sample_dir_formatted now looks like this:\n\n\n\nTerminal\n\ntree -L 2\n\n.\n├── &lt;flow cell&gt;_exprMat_file.csv.gz\n├── &lt;flow cell&gt;_fov_positions_file.csv.gz\n├── &lt;flow cell&gt;_metadata_file.csv.gz\n├── CellComposite\n│   ├── CellComposite_F001.jpg\n|   ├── ...\n│   └── CellComposite_F064.jpg\n├── CellLabels\n│   ├── CellLabels_F001.tif\n|   ├── ...\n│   └── CellLabels_F064.tif\n├── CellOverlay\n│   ├── CellOverlay_F001.jpg\n|   ├── ...\n│   └── CellOverlay_F064.jpg\n└── CompartmentLabels\n    ├── CompartmentLabels_F001.tif\n    ...\n    └── CompartmentLabels_F064.tif\n\n\n\n\n\n\n\n\nNote\n\n\n\nIf your flow cell was created prior to AtoMx v1.3.2, the CellComposite jpg files may not show the composites but instead just blank images. They will still load into squidpy but will not show the expected tissue structure. This issue was patched for samples created in v1.3.2+. If you have blank images and would like to replace them with composite images, check out this post."
  },
  {
    "objectID": "posts/squidpy-essentials/squidpy-essentials.html#read-expression-and-image-data-into-squidpy",
    "href": "posts/squidpy-essentials/squidpy-essentials.html#read-expression-and-image-data-into-squidpy",
    "title": "Using Squidpy with AtoMx® SIP exports",
    "section": "5.2 Read expression and image data into squidpy",
    "text": "5.2 Read expression and image data into squidpy\nThe block of code below reads the flat files and images now that the image data are in the specified format. The location of the data in the example code below is sample_dir and is provided as the argument for the path parameter of read.nanostring.\n\n\nPython\n\n\nfrom pathlib import Path\nimport os\nimport numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nimport scanpy as sc\nimport squidpy as sq\n\nsample_dir = 'path/to/breast_cancer_example/sample_dir_formatted'\nmeta_file = [item for item in os.listdir(sample_dir) if 'metadata_file' in item][0]\ncounts_file = [item for item in os.listdir(sample_dir) if 'exprMat_file' in item][0]\nfov_file = [item for item in os.listdir(sample_dir) if 'fov_positions_file' in item][0]\n \nfov_df = pd.read_csv(os.path.join(sample_dir, fov_file))\nif 'FOV' in fov_df.columns:\n  print(\"Refactoring file to older format.\")\n  # Rename 'FOV' column to 'fov'\n  fov_df.rename(columns={'FOV': 'fov'}, inplace=True)\n  # have fov_file reference the new, formatted file and write it\n  fov_file = os.path.join(sample_dir,'fov_positions_formatted.csv')\n  fov_df.to_csv(fov_file, index=False)\n\nadata2 = sq.read.nanostring(\n    path=sample_dir,\n    counts_file=counts_file,\n    meta_file=meta_file,\n    fov_file=fov_file\n)\n\n# This part of the analyis is similar to above\nadata2.var[\"Negative\"] = adata2.var_names.str.startswith(\"Negative\")\nadata2.var[\"SystemControl\"] = adata2.var_names.str.startswith(\"SystemControl\")\nsc.pp.calculate_qc_metrics(adata2, qc_vars=[\"Negative\", \"SystemControl\"], inplace=True)\nsc.pp.filter_cells(adata2, min_counts=250)\nsc.pp.filter_genes(adata2, min_cells=1000)\nadata2.layers[\"counts\"] = adata2.X.copy()\nsc.pp.normalize_total(adata2, inplace=True, exclude_highly_expressed=True)\nsc.pp.log1p(adata2)\nsc.pp.pca(adata2, n_comps=50)\nsc.pp.neighbors(adata2)\nsc.tl.umap(adata2, min_dist=0.2, spread=1)\nsc.tl.leiden(adata2)"
  },
  {
    "objectID": "posts/squidpy-essentials/squidpy-essentials.html#spatial-analysis",
    "href": "posts/squidpy-essentials/squidpy-essentials.html#spatial-analysis",
    "title": "Using Squidpy with AtoMx® SIP exports",
    "section": "5.3 Spatial Analysis",
    "text": "5.3 Spatial Analysis\nIn addition to the analysis code we’ve already covered, we can view and analyze our CosMx results with image data. For a full list of features, please see squidpy’s documentation. For some of the examples below, I’ll use a subset of the data – a single FOV – to speed up computation and to make plotting easier.\n\n\nPython\n\nadata_subset = adata2[adata2.obs.fov == \"35\"].copy()\n\n\n5.3.1 Viewing results in space\nFigure 7 shows a single FOV image data with cells drawn as contours that are colored based on their Leiden cluster.\n\n\nPython\n\nsq.pl.spatial_segment(\n    adata2,\n    color=\"leiden\",\n    seg_contourpx=20,\n    seg_cell_id=\"cell_ID\",\n    library_key=\"fov\",\n    library_id=\"35\",\n    img=True,\n    size=60,\n    figsize = (4, 4),\n    dpi = 200,\n    save = \"fig-image1.png\"\n)\n\n\n\n\n\n\n\n\n\n\n\nFigure 7: Leiden clusters in space for a single FOV of breast cancer tissue. Clusters are displayed as cell contours overlaid on morphology image (green = PanCK, magenta = DAPI).\n\n\n\n\n\n\n\n5.3.2 Autocorrelation with Moran’s I\nMoran’s I is a useful spatial statistic for measuring the extent that a gene’s expression is clustered in space (verus random or dispersed). Taking a look at the single-FOV subset, we see genes with positive Moran’s I.\n\n\nPython\n\n\nsq.gr.spatial_neighbors(adata_subset, coord_type=\"generic\", delaunay=True)\nsq.gr.spatial_autocorr(\n    adata_subset,\n    mode=\"moran\",\n    n_perms=100,\n    n_jobs=1,\n)\nadata_subset.uns[\"moranI\"].head(10)\n\n                I  pval_norm  var_norm  pval_z_sim  pval_sim   var_sim  pval_norm_fdr_bh  pval_z_sim_fdr_bh  pval_sim_fdr_bh\nCRIP1    0.634842        0.0  0.000279         0.0  0.009901  0.000460               0.0                0.0         0.044936\nCOX6C    0.624853        0.0  0.000279         0.0  0.009901  0.000496               0.0                0.0         0.044936\nCOL1A1   0.616015        0.0  0.000279         0.0  0.009901  0.000476               0.0                0.0         0.044936\nSCGB2A2  0.587074        0.0  0.000279         0.0  0.009901  0.000419               0.0                0.0         0.044936\nCOL1A2   0.572189        0.0  0.000279         0.0  0.009901  0.000487               0.0                0.0         0.044936\nCOL3A1   0.559603        0.0  0.000279         0.0  0.009901  0.000449               0.0                0.0         0.044936\nSPARC    0.547069        0.0  0.000279         0.0  0.009901  0.000394               0.0                0.0         0.044936\nKRT8     0.516281        0.0  0.000279         0.0  0.009901  0.000427               0.0                0.0         0.044936\nERBB2    0.509171        0.0  0.000279         0.0  0.009901  0.000458               0.0                0.0         0.044936\nKRT19    0.502475        0.0  0.000279         0.0  0.009901  0.000529               0.0                0.0         0.044936\n\nWhen we plot the expression of some of these genes (Figure 8), we indeed see some how they are aggregated. For example, COX6C expression, which may have clinical significance with breast cancer (Tian et al. 2021), is autocorrelated and co-occurs with cells high in KRT19.\n\n\nPython\n\n\nsq.pl.spatial_segment(\n    adata_subset,\n    library_id=\"35\",\n    seg_cell_id=\"cell_ID\",\n    library_key=\"fov\",\n    color=[\"COX6C\", \"COL1A1\", \"KRT19\"],\n    size=60,\n    img=False,\n    figsize=(4, 4),\n    dpi = 200,\n    save = \"fig-nhood-Morans-I.png\"\n)\n\n\n\n\n\n\n\n\n\nFigure 8: Expression for select genes showing relatively high Moran’s I.\n\n\n\n\n\n\n\n5.3.3 Spatial co-occurence\nWhile Moran’s I quantifies autocorrelation of genes, spatial co-occurence with gr.co_occurence quantifies cell-level co-occurences. In example below, co-occurence of Leiden clusters was used (Figure 9).\n\n\nPython\n\n\nsq.gr.co_occurrence(\n    adata_subset,\n    cluster_key=\"leiden\",\n)\n\nsq.pl.co_occurrence(\n    adata_subset,\n    cluster_key=\"leiden\",\n    clusters=\"1\",\n    save = \"fig-co-occurence1.png\"\n)\nsq.pl.spatial_segment(\n    adata_subset,\n    shape=\"hex\",\n    color=\"leiden\",\n    library_id=\"35\",\n    library_key=\"fov\",\n    seg_cell_id=\"cell_ID\",\n    img=False,\n    size=60,\n    ax = ax[1],\n    save = \"fig-co-occurence2.png\"\n)\n\n\n\n\n\n\n\n\n\nFigure 9: Co-occurence of Leiden clusters. Left: Leiden clusters in space for a single FOV of breast cancer tissue. Right: co-occurence probability ratio (Y) for each cluster relative to Leiden cluster 1 (orange cells in left plot) with increasing radius (X).\n\n\n\n\n\n\n\n5.3.4 Neighborhood enrichment\nWe can take a look at neighborhood enrichment scores using gr.nhood_enrichment and pl.nhood_enrichment(Figure 10).\n\n\nPython\n\n\nsq.gr.nhood_enrichment(adata2, cluster_key=\"leiden\")\nsq.pl.nhood_enrichment(\n    adata2,\n    cluster_key=\"leiden\",\n    figsize=(5, 5),\n    dpi = 200,\n    title=\"Neighborhood enrichment\",\n    save = \"fig-nhood-enrichment.png\"\n)\n\n\n\n\n\n\n\n\n\n\nFigure 10: Neighborhood enrichment across all FOVs for each pairwise combination of Leiden clusters."
  },
  {
    "objectID": "posts/squidpy-essentials/squidpy-essentials.html#sec-venv",
    "href": "posts/squidpy-essentials/squidpy-essentials.html#sec-venv",
    "title": "Using Squidpy with AtoMx® SIP exports",
    "section": "7.1 Create a virtual environment for squidpy",
    "text": "7.1 Create a virtual environment for squidpy\nI recommend creating a separate virtual environment to run squidpy and to keep packages isolated from the rest of your system. This can be operating system and architecture specific so my (M1 Mac) specific example code below may not work with your configuration.\n\n\n\n\n\n\nNote\n\n\n\nTroubleshooting or assistance with squidpy installation is beyond the scope of this post. Please see squidpy’s documentation.\n\n\nIn general, there are two main package management systems: the default one that ships with python and conda. I’ll use the former for this post. For more information, please see the Python Packaging User Guide for examples on Windows and Mac/Linux.\n\n\n\nTerminal\n\npython3.10 -m venv .venv\nsource .venv/bin/activate\npython --version\n\n\n\nPython 3.10.6\n\n\n\n\nTerminal\n\npip install squidpy\n\n\nHere are the packages that I used for this post:\n\n\n\nTerminal\n\npip freeze &gt; requirements.txt\n\n\n\n\nClick to show contents of requirements.txt\naiobotocore==2.5.4\naiohttp==3.9.5\naioitertools==0.11.0\naiosignal==1.3.1\nanndata==0.10.8\narray_api_compat==1.7.1\nasciitree==0.3.3\nasync-timeout==4.0.3\nattrs==23.2.0\nbotocore==1.31.17\ncertifi==2024.6.2\ncharset-normalizer==3.3.2\nclick==8.1.7\nclick-plugins==1.1.1\ncligj==0.7.2\ncloudpickle==3.0.0\ncolorcet==3.1.0\ncontourpy==1.2.1\ncycler==0.12.1\ndask==2024.6.1\ndask-expr==1.1.4\ndask-image==2024.5.3\ndatashader==0.16.2\ndistributed==2024.6.1\ndocrep==0.3.2\nexceptiongroup==1.2.1\nfasteners==0.19\nfiona==1.9.6\nfonttools==4.53.0\nfrozenlist==1.4.1\nfsspec==2023.6.0\ngeopandas==0.14.4\nh5py==3.11.0\nidna==3.7\nigraph==0.11.5\nimageio==2.34.1\nimportlib_metadata==7.2.0\ninflect==7.2.1\nJinja2==3.1.4\njmespath==1.0.1\njoblib==1.4.2\nkiwisolver==1.4.5\nlazy_loader==0.4\nlegacy-api-wrap==1.4\nleidenalg==0.10.2\nllvmlite==0.43.0\nlocket==1.0.0\nmarkdown-it-py==3.0.0\nMarkupSafe==2.1.5\nmatplotlib==3.9.0\nmatplotlib-scalebar==0.8.1\nmdurl==0.1.2\nmore-itertools==10.3.0\nmsgpack==1.0.8\nmultidict==6.0.5\nmultipledispatch==1.0.0\nmultiscale_spatial_image==0.11.2\nnatsort==8.4.0\nnetworkx==3.3\nnumba==0.60.0\nnumcodecs==0.12.1\nnumpy==1.26.4\nome-zarr==0.9.0\nomnipath==1.0.8\npackaging==24.1\npandas==2.2.2\nparam==2.1.0\npartd==1.4.2\npatsy==0.5.6\npillow==10.3.0\nPIMS==0.7\npsutil==6.0.0\npyarrow==16.1.0\npyct==0.5.0\npygeos==0.14\nPygments==2.18.0\npynndescent==0.5.13\npyparsing==3.1.2\npyproj==3.6.1\npython-dateutil==2.9.0.post0\npytz==2024.1\nPyYAML==6.0.1\nrequests==2.32.3\nrich==13.7.1\ns3fs==2023.6.0\nscanpy==1.10.1\nscikit-image==0.24.0\nscikit-learn==1.5.0\nscipy==1.13.1\nseaborn==0.13.2\nsession-info==1.0.0\nshapely==2.0.4\nsix==1.16.0\nslicerator==1.1.0\nsortedcontainers==2.4.0\nspatial_image==0.3.0\nspatialdata==0.0.15\nsquidpy==1.5.0\nstatsmodels==0.14.2\nstdlib-list==0.10.0\ntblib==3.0.0\ntexttable==1.7.0\nthreadpoolctl==3.5.0\ntifffile==2024.6.18\ntoolz==0.12.1\ntornado==6.4.1\ntqdm==4.66.4\ntypeguard==4.3.0\ntyping_extensions==4.12.2\ntzdata==2024.1\numap-learn==0.5.6\nurllib3==1.26.19\nvalidators==0.28.3\nwrapt==1.16.0\nxarray==2024.6.0\nxarray-dataclasses==1.8.0\nxarray-datatree==0.0.14\nxarray-schema==0.0.3\nxarray-spatial==0.4.0\nyarl==1.9.4\nzarr==2.18.2\nzict==3.0.0\nzipp==3.19.2"
  },
  {
    "objectID": "posts/napari-cosmx-basics/using-napari-cosmx.html",
    "href": "posts/napari-cosmx-basics/using-napari-cosmx.html",
    "title": "napari-cosmx essentials",
    "section": "",
    "text": "Figure 1: Drawing that represents the duality of napari-cosmx. On the left side, cell types within a mouse coronal hemisphere are shown in an interactive Graphical User Interface. In addition to creating images interactively, the right side highlights that images can be generated programmatically. Both sides of napari-cosmx are discussed in this post."
  },
  {
    "objectID": "posts/napari-cosmx-basics/using-napari-cosmx.html#sec-preprocessing",
    "href": "posts/napari-cosmx-basics/using-napari-cosmx.html#sec-preprocessing",
    "title": "napari-cosmx essentials",
    "section": "2.1 Pre-processing example data",
    "text": "2.1 Pre-processing example data\nOnce downloaded, unzip the HalfBrain.zip file on your computer or external hard drive. The format for this dataset differs from the expected AtoMx SIP export so a preprocessing step is necessary.\nWhen uncompressed, the raw data in the HalfBrain folder are actually nested like this:\n\n\n\nTerminal\n\ntree -L 4\n\n├── AnalysisResult\n│   └── HalfBrain_20230406_205644_S1\n│       └── AnalysisResults &lt;-- **Raw Data Folder**\n|           └── cp7bjyp7pm\n├── CellStatsDir\n│   └── HalfBrain_20230406_205644_S1\n│       └── CellStatsDir &lt;-- **Raw Data Folder**\n│           ├── CellComposite\n│           ├── CellOverlay\n│           ├── FOV001\n│           ├── FOV002\n|           ...\n│           ├── Morphology2D\n│           └── RnD\n└── RunSummary\n    └── HalfBrain_20230406_205644_S1\n        └── RunSummary &lt;-- **Raw Data Folder**\n            ├── Beta12_Affine_Transform_20221103.csv\n            ├── FovTracking\n            ├── Morphology_ChannelID_Dictionary.txt\n            ├── Run1000_20230406_205644_S1_Beta12_ExptConfig.txt\n            ├── Run1000_20230406_205644_S1_Beta12_SpatialBC_Metrics4D.csv\n            ├── Shading\n            ├── c902.fovs.csv\n            └── latest.fovs.csv\n\n\n\n2.1.1 Expected Raw Data Format\nIn order for napari-cosmx to stitch this non-AtoMx example dataset, we’ll need to rearrange the folders so that the nested raw data are at the top level. After rearrangement, the proper file structure should look like this:\n\n\n\nTerminal\n\ntree -L 2\n\n.\n├── AnalysisResults\n│   └── cp7bjyp7pm\n├── CellStatsDir\n│   ├── CellComposite\n│   ├── CellOverlay\n│   ├── FOV001\n│   ├── FOV002\n...\n│   ├── Morphology2D\n│   └── RnD\n└── RunSummary\n    ├── Beta12_Affine_Transform_20221103.csv\n    ├── FovTracking\n    ├── Morphology_ChannelID_Dictionary.txt\n    ├── Run1000_20230406_205644_S1_Beta12_ExptConfig.txt\n    ├── Run1000_20230406_205644_S1_Beta12_SpatialBC_Metrics4D.csv\n    ├── Shading\n    ├── c902.fovs.csv\n    └── latest.fovs.csv\n\n\nThere are a few ways to rearrange. The first method retains the original folder structure and simply makes symbolic links to the data in the expected format. Here’s how to do it in unix/mac (Windows not shown).\n\n\n\nTerminal\n\n# Terminal in Mac/Linux\n\n# cd to folder containing HalfBrain. Then, \n\nmkdir -p RawFiles && cd $_\nln -s ../HalfBrain/AnalysisResult/HalfBrain_20230406_205644_S1/AnalysisResults .\nln -s ../HalfBrain/CellStatsDir/HalfBrain_20230406_205644_S1/CellStatsDir .\nln -s ../HalfBrain/RunSummary/HalfBrain_20230406_205644_S1/RunSummary .\n\n\nAlternatively, we could manually move folders. Specifically, in your Finder window, create a folder named RawData. Then, move:\n\nHalfBrain/AnalysisResult/HalfBrain_20230406_205644_S1/AnalysisResults to RawData/AnalysisResults\nHalfBrain/CellStatsDir/HalfBrain_20230406_205644_S1/CellStatsDir to RawData/CellStatsDir\nHalfBrain/RunSummary/HalfBrain_20230406_205644_S1/RunSummary to RawData/RunSummary\n\nOnce the file structure is properly formatted, use the stitching widget method from an earlier blog post to create the mouse brain napari files.\n\n\n\n2.1.2 Adding metadata\nWe will also use the cell typing data from the Seurat file. Let’s include the following metadata columns:\n\nRNA_nbclust_clusters: the cell typing results (with abbreviated names)\nRNA_nbclust_clusters_long: (optional) human-readable cell type names\nspatialClusteringAssignments: spatial niche assignments\n\nNote that the Seurat file contains two sections of mouse brain samples. We need to filter the metadata to include only those cells from Run1000_S1_Half. Note that when preparing the metadata for napari, the cell ID must be the first column (i.e., see the relocate verb in the code below).\n\n# This is R code\nlibrary(Seurat)\nlibrary(plyr)\nlibrary(dplyr)\n# sem_path will be wherever you downloaded your Seurat object\nsem_path &lt;- \"/path/to/your/muBrainRelease_seurat.RDS\"\nsem &lt;- readRDS(sem_path)\nmeta &lt;- sem@meta.data %&gt;% \n  filter(Run_Tissue_name==\"Run1000_S1_Half\") %&gt;%\n  select(RNA_nbclust_clusters, \n  RNA_nbclust_clusters_long, \n  spatialClusteringAssignments)\n  \nmeta$cell_ID &lt;- row.names(meta) # adds cell_ID column\nrownames(meta) &lt;- NULL\nmeta &lt;- meta %&gt;% relocate(cell_ID) # moves cell_ID to first column position\nwrite.table(meta, file=\"/path/to/inside/napari-ready-folder/_metadata.csv\", \n            sep=\",\", col.names=TRUE, row.names=FALSE, quote=FALSE)\n\nNow that the data are ready, drag and drop the slide folder into napari to launch the plugin."
  },
  {
    "objectID": "posts/napari-cosmx-basics/using-napari-cosmx.html#color-cells-with-outlines",
    "href": "posts/napari-cosmx-basics/using-napari-cosmx.html#color-cells-with-outlines",
    "title": "napari-cosmx essentials",
    "section": "4.1 Color cells with outlines",
    "text": "4.1 Color cells with outlines\nWe can plot the cell colors as boundaries instead of filled in polygons (Figure 7).\n\n# gem.viewer.camera.center = (0.0, -0.5375926704126319, -54.7415680001114)\n# gem.viewer.camera.zoom = 1371.524539264374\n\ngfap.visible = False\ndna.visible = False\ngem.viewer.layers['Calb1'].visible = False\ngem.viewer.layers['Npy'].visible = False\ngem.viewer.layers['Targets'].visible = False\n\ngem.viewer.camera.center = (0.0, -0.6346878790298397, -54.95271110236874)\ngem.viewer.camera.zoom = 2113.6387223301786\ngem.color_cells('RNA_nbclust_clusters', contour=2)\n\nfig_path = output_path + \"/fig-contours.png\"\nwith imageio.get_writer(fig_path, dpi=(800, 800)) as writer:\n        screenshot = gem.viewer.screenshot(canvas_only=True)\n        writer.append_data(screenshot)\n\n\n\n\n\n\n\n\n\nFigure 7: Cells types (or other metadata items) can be represented as cell boundaries."
  },
  {
    "objectID": "posts/napari-cosmx-basics/using-napari-cosmx.html#plot-transcripts-with-an-expanded-color-pallette",
    "href": "posts/napari-cosmx-basics/using-napari-cosmx.html#plot-transcripts-with-an-expanded-color-pallette",
    "title": "napari-cosmx essentials",
    "section": "4.2 Plot transcripts with an expanded color pallette",
    "text": "4.2 Plot transcripts with an expanded color pallette\nThe GUI offers a handful of colors to plot transcripts. We can specify which color, by name or by hexcode, to plot. For example:\n\ngem.plot_transcripts(gene = \"Calb1\", color = 'pink', point_size=20)\n\nwhich is the same as\n\ngem.plot_transcripts(gene = \"Calb1\", color = '#FFC0CB', point_size=20)"
  },
  {
    "objectID": "posts/napari-cosmx-basics/using-napari-cosmx.html#plotting-genes-with-list-comprehensions",
    "href": "posts/napari-cosmx-basics/using-napari-cosmx.html#plotting-genes-with-list-comprehensions",
    "title": "napari-cosmx essentials",
    "section": "4.3 Plotting genes with list comprehensions",
    "text": "4.3 Plotting genes with list comprehensions\nWe can plot similar genes or targets with the same color. For example, the code that generated Figure 8 is here.\n\ngem.viewer.camera.center = (0.0, -0.6346878790298397, -54.95271110236874)\ngem.viewer.camera.zoom = 2113.6387223301786\n\ndf = gem.targets\nfiltered_df = df[df.target.str.contains(\"NegPrb\")]\n\npandas_df = filtered_df.to_pandas_df()\nnegatives = pandas_df.target.unique().tolist()\n[gem.plot_transcripts(gene = x, color = \"white\", point_size=20) for x in negatives];\n\nfig_path = output_path + \"/fig-negatives.png\"\nwith imageio.get_writer(fig_path, dpi=(800, 800)) as writer:\n        screenshot = gem.viewer.screenshot(canvas_only=False)\n        writer.append_data(screenshot)\n\n\n\n\n\n\n\n\n\nFigure 8: Same extent as Figure 7 but with negatives shown in white.\n\n\n\n\n\nWe can also supply of list of tuples where each tuple is a target and a color.\n\ngenes = [('Npy', \"magenta\"), (\"Calb1\", \"white\")]\n[gem.plot_transcripts(gene = x[0], color = x[1], point_size=20) for x in genes];\n\nfor x in negatives:\n  gem.viewer.layers[x].visible = False\n\ngem.color_cells('RNA_nbclust_clusters') # reset to filled contours\ncell_type_layer = gem.viewer.layers['RNA_nbclust_clusters']\ncell_type_layer.opacity = 0.9\ncell_type_layer.visible = True\ngem.viewer.camera.center = (0.0, -0.026937869510583412, -59.20560304046731)\ngem.viewer.camera.zoom = 3820.667999302201\ngem.viewer.layers['Segmentation'].visible = True\ngem.viewer.layers['Segmentation'].opacity = 0.6\n\nfig_path = output_path + \"/fig-crowded-tx.png\"\nwith imageio.get_writer(fig_path, dpi=(800, 800)) as writer:\n        screenshot = gem.viewer.screenshot(canvas_only=False)\n        writer.append_data(screenshot)\n\n\n\n\n\n\n\n\n\nFigure 9: Cortical layer with Npy (magenta) and Calb1 (white)."
  },
  {
    "objectID": "posts/napari-cosmx-basics/using-napari-cosmx.html#changing-transcript-transparency",
    "href": "posts/napari-cosmx-basics/using-napari-cosmx.html#changing-transcript-transparency",
    "title": "napari-cosmx essentials",
    "section": "4.4 Changing transcript transparency",
    "text": "4.4 Changing transcript transparency\nSometimes transcripts can be stacked on top of each other to the point that it’s difficult to qualitatively determine the number of transcripts. Adjusting the transcript opacity of the layer in the GUI only changes the transparency of a single point. But it’s possible to change all points using the ipython interpreter.\n\ngem.viewer.layers['Npy'].opacity = 0.5\nfig_path = output_path + \"/fig-tx-opacity.png\"\nwith imageio.get_writer(fig_path, dpi=(800, 800)) as writer:\n        screenshot = gem.viewer.screenshot(canvas_only=False)\n        writer.append_data(screenshot)\n\n\n\n\n\n\n\n\n\nFigure 10: Same extent as Figure 9 but opacity of Npy reduced from 1 to 0.5."
  },
  {
    "objectID": "posts/napari-cosmx-basics/using-napari-cosmx.html#center-to-a-particular-fov",
    "href": "posts/napari-cosmx-basics/using-napari-cosmx.html#center-to-a-particular-fov",
    "title": "napari-cosmx essentials",
    "section": "4.5 Center to a particular FOV",
    "text": "4.5 Center to a particular FOV\nWhile zooming (gem.viewer.camera.zoom) and panning (gem.viewer.camera.center) can control the exact location of the camera, you can programmatically go to a particular fov with the center_fov method.\n\n# center to fov 123 and zoom in a little (i.e., buffer &gt; 1).\ngem.center_fov(fov=123, buffer=1.2)\n\nfig_path = output_path + \"/fig-center-to-fov.png\"\nwith imageio.get_writer(fig_path, dpi=(800, 800)) as writer:\n        screenshot = gem.viewer.screenshot(canvas_only=False)\n        writer.append_data(screenshot)\n\n\n\n\n\n\n\n\n\nFigure 11: Centering to a particular FOV (123) using the center_fov method."
  },
  {
    "objectID": "posts/napari-cosmx-basics/using-napari-cosmx.html#plot-all-transcripts",
    "href": "posts/napari-cosmx-basics/using-napari-cosmx.html#plot-all-transcripts",
    "title": "napari-cosmx essentials",
    "section": "4.6 Plot all transcripts",
    "text": "4.6 Plot all transcripts\nThis is not advised for resource-limited systems as it plots all transcripts. The method add_points plots all the points for a given FOV. If no FOV is specified, it will plot all transcripts (this can be taxing on resource-limited computers).\n\ngem.add_points(fov=123)\ngem.viewer.layers['Targets'].opacity = 0.4\nfig_path = output_path + \"/fig-tx-all.png\"\nwith imageio.get_writer(fig_path, dpi=(800, 800)) as writer:\n        screenshot = gem.viewer.screenshot(canvas_only=False)\n        writer.append_data(screenshot)\n\n\n\n\n\n\n\n\n\nFigure 12: All targets for FOV 123."
  },
  {
    "objectID": "posts/napari-cosmx-basics/using-napari-cosmx.html#changing-background-color",
    "href": "posts/napari-cosmx-basics/using-napari-cosmx.html#changing-background-color",
    "title": "napari-cosmx essentials",
    "section": "4.7 Changing background color",
    "text": "4.7 Changing background color\nFor some publication styles (e.g., posters), turning the background a lighter color might be useful. However, when changing the background, some items might be more difficult to see (compare Figure 7 with Figure 13).\n\ngem.viewer.window.qt_viewer.canvas.background_color_override = 'white'\nfig_path = output_path + \"/fig-white.png\"\nwith imageio.get_writer(fig_path, dpi=(800, 800)) as writer:\n        screenshot = gem.viewer.screenshot(canvas_only=True)\n        writer.append_data(screenshot)\n\n\n\n\n\n\n\n\n\nFigure 13: Same extent as Figure 7 but with a white background."
  },
  {
    "objectID": "posts/napari-cosmx-basics/using-napari-cosmx.html#scale-bar-location",
    "href": "posts/napari-cosmx-basics/using-napari-cosmx.html#scale-bar-location",
    "title": "napari-cosmx essentials",
    "section": "4.8 Scale Bar location",
    "text": "4.8 Scale Bar location\nTo reposition the scale bar to the bottom left:\n\ngem.viewer.window.qt_viewer.canvas.background_color_override = 'black'\ngem.viewer.scale_bar.position='bottom_left'\nfig_path = output_path + \"/fig-scale_bl.png\"\nwith imageio.get_writer(fig_path, dpi=(800, 800)) as writer:\n        screenshot = gem.viewer.screenshot(canvas_only=True)\n        writer.append_data(screenshot)\n\n\n\n\n\n\n\n\n\nFigure 14: Same extent as Figure 7 but with a scale bar moved to the bottom left."
  },
  {
    "objectID": "posts/napari-cosmx-basics/using-napari-cosmx.html#specify-individual-cell-types",
    "href": "posts/napari-cosmx-basics/using-napari-cosmx.html#specify-individual-cell-types",
    "title": "napari-cosmx essentials",
    "section": "4.9 Specify individual cell types",
    "text": "4.9 Specify individual cell types\nHere’s my last tip for this post. Using the color_cells method, one can choose the color of the cell types and which cells to color by supplying a dictionary. If a cell type is not in the supplied dictionary, it will not be shown as a color.\n\ncustom_colors = {\n\"MOL\":\"#AA0DFE\",\n\"GN\":\"#85660D\",\n\"CHO_HB\":\"orange\" # need not be hexcode\n}\n\ngem.color_cells('RNA_nbclust_clusters', color=custom_colors)\nfig_path = output_path + \"/fig-color_three.png\"\nwith imageio.get_writer(fig_path, dpi=(800, 800)) as writer:\n        screenshot = gem.viewer.screenshot(canvas_only=True)\n        writer.append_data(screenshot)\n\n\n\n\n\n\n\n\n\nFigure 15: Same extent as Figure 7 highlighting three cell types only. MOL = mature oligodenrocytes = purple; GN = granule neurons = brown; CHO_HB = Cholinergic neurons Habenula = orange; cyan = all other cells."
  },
  {
    "objectID": "posts/spatial-discovery-tips/index.html#spatial-discovery",
    "href": "posts/spatial-discovery-tips/index.html#spatial-discovery",
    "title": "Interactive Spatial Analysis with LLMs",
    "section": "Spatial Discovery",
    "text": "Spatial Discovery\nAtoMx SIP 2.2 brings several new features and enhancements to users in the beta release of its brand new visual-first experience. This includes pre-processing and pre-calculations of many of “upstream” modules like quality, cluster, etc. In addition to visual enhancements, this new experience brings new analysis modules like Novae domains and Spatial Discovery.\nIn this “vlog” post, I quickly explain what the Spatial Discovery is and demonstrate and example of how I use it in combination with LMMs to accelerate my discoveries. Click the chapters to the right of the video to begin."
  },
  {
    "objectID": "posts/spatial-discovery-tips/index.html#study-insights",
    "href": "posts/spatial-discovery-tips/index.html#study-insights",
    "title": "Interactive Spatial Analysis with LLMs",
    "section": "Study Insights",
    "text": "Study Insights\nWhen downloading the Spatial Discovery Study Insights you will get a zip file. Within that zip file is a series of text files containing pertinent results from the study. One of those files is the readme markdown file which explains what each file contains, the column names, the data types, and other useful information that an LMM can use for added context."
  },
  {
    "objectID": "posts/spatial-discovery-tips/index.html#example-prompts",
    "href": "posts/spatial-discovery-tips/index.html#example-prompts",
    "title": "Interactive Spatial Analysis with LLMs",
    "section": "Example Prompts",
    "text": "Example Prompts\nOne of the most exciting things about this interactive approach is that you can really ask any number of questions to the prompt. I typically start by confirming if it can understand the files I uploaded and some questions defining my spatial domains and cell types before asking about biological processes but it’s entirely open-ended. Here’s some example prompts that you can try.\n\nCan you read and understand the contents of these files related to my colon cancer dataset? If so, I would like to have a conversation about the data with you.\nTell me the most likely cell types from my Leiden clusters. From the data, can you provide me a table with the Leiden cluster, the most likely cell type, 1-3 marker genes that helped you determine this cell type, and a brief biological justification?\nFrom the Leiden cluster and domain information, can you provide a contingency table showing the counts? For example, in domain1 there are X number of Leiden 1 cells.\nGiven the composition of cell types (Leiden) and domains, can you assign a biological name to each domain for me?\nWhat are the top 5 biologically relevant pathways in each domain?\nFor &lt;insert pathway&gt;, show me the relationship between mean intensity and spatial autocorrelation for each cell type (Leiden cluster). Make this an interactive xy scatter plot for me.\nTell me something interesting about this dataset.\nGive me three interesting pathway paterns that you found that I should check out spatially in AtoMx SIP."
  },
  {
    "objectID": "posts/spatial-discovery-tips/index.html#tips-when-working-with-lmms",
    "href": "posts/spatial-discovery-tips/index.html#tips-when-working-with-lmms",
    "title": "Interactive Spatial Analysis with LLMs",
    "section": "Tips when working with LMMs",
    "text": "Tips when working with LMMs\n\nWe have tested this on several models (chatGPT, copilot, Gemini) and premium tiers tend to perform best as they can hold more content than the free tiers. Free tiers also have a shorter conversaton limit and more restricting data upload size limits.\nIf working with many samples and/or conditions, using “temporary” chats can reduce the LMMs from “pulling in” results that are not related to the current study.\nTaking screenshots of the sample from AtoMx SIP and pasting them in the chat can help provide the LMM more context. LMMs thrive on plain text and verification is recommended.\n\nIf you discover other tips when working an analyzing your CosMx SMI results in this format, I would love to hear from you."
  },
  {
    "objectID": "posts/on-cell-typing-with-marker-genes/index.html",
    "href": "posts/on-cell-typing-with-marker-genes/index.html",
    "title": "On the use of marker genes",
    "section": "",
    "text": "On cell typing with marker genes\nOur basic recommendation is this: relying on a few marker genes alone will not produce successful cell typing.\nSpatial transcriptomics data has two features that make marker genes challenging to use.\n\nBackground: cells’ expression profiles can include two kinds of false counts: these platforms sometimes see transcripts that aren’t present (false detections), and errors in cell segmentation lead transcripts from one cell to be assigned to its neighbor. Both these phenomena lead to marker genes being counted in cells where they aren’t truly present.\nVariable signal strength / false negative detection: tissues and cells vary widely in how efficiently existing RNA molecules are read. Thus genes with low expression are easily missed in many cells.\n\nApplying the above phenomena to FOXP3, the canonical marker for Treg cells, we can envision non-Treg cells with spurious FOXP3 coming from false detections or contamination from a neighboring Treg (error mode 1 above), and we can imagine Treg cells where FOXP3 isn’t detected (error mode 2 above). A cell typing regime that applied an expression threshold to FOXP3 would be unacceptably error-prone.\nInstead of using marker genes, we recommend cell typing using most or all of cells’ expression profiles. The data for a single gene in a single cell is noisy, but the evidence from a complete expression profile is much more stable. Given clusters derived from all or most of your panel, marker genes are useful for annotating clusters. E.g., if a cluster is enriched in FOXP3, you can safely label it Tregs.\nAs an advanced approach, we have had success cell typing using smoothed expression of marker genes. We replace each cell’s observed profile with the average profile of the 20+ cells that have the most similar expression profiles to it. This essentially performs a variance-bias tradeoff: we bias a cell to look like its neighbors in expression space, but we greatly cut down the noise in the expression level. Cell typing based on marker genes in this smoothed data can be successful."
  },
  {
    "objectID": "posts/composite-images/making-composite-images.html",
    "href": "posts/composite-images/making-composite-images.html",
    "title": "Making composite images from layered morphology 2D images",
    "section": "",
    "text": "Figure 1: A composite image created using the make_composite.py script. This image represents all channels of a single field of view in the publicly available mouse coronal hemisphere FFPE dataset.\n\n\n\n\n\n\n1 Description\nComposite images of CosMx® Spatial Molecular Imager (SMI) fields of view (FOVs) can be useful when using open-sourced software such as squidpy and giotto. In this post, we describe the make_composite.py script, a developmental python script that creates such composite images from layered morphology 2D images that can be exported from the AtoMx® Spatial Informatics Portal (SIP). Layered images are extracted from the 2D morphology TIF files and written in a file format selected by the user. The extracted images are converted to 8bit, and composite images are written from these 8bit images.\n\n\n\n\n\n\nNote\n\n\n\nmake_composite.py is a development version. Use at your own risk.\n\n\n\n\n2 Where to find the script?\nThe script and license can be found in the assets/make-composite folder of the repository.\n\n\n3 Required libraries\nThe script requires the following libraries to be installed:\n\nPillow (e.g., pip install pillow)\nNumpy (e.g., pip install numpy)\n\n\n\n4 User inputs (required)\n\nclipping (int or float) - Histogram clipping percentage. This value is the percentage of the histogram to clip on the left and right side. The effect changes the contrast of the image. A higher percentage produces more contrast. The user needs to determine the appropriate percentage by testing on a subset of images. The same clipping value is applied to all images. Generally, setting the value between 1 and 3 is a good starting point. Specifying a clipping value of 0 will not alter the histogram. A value is required, there is no default. clipping is a required input.\nuser_format (str) - File format to be written. Options are jpg, png, and tif. All output files will be written in the format specified by the user. user_format is a required input.\n\n\n\n5 Additional inputs (changed within the script)\n\nVariable: colors = [‘cyan’, ‘red’, ‘yellow’, ‘blue’, ‘magenta’]. The variable is the composite color scheme (not a user input; changeable within the script). The colors are listed in order of channel number (channel 0 to channel 4). Example: Channel 0 is colored ‘cyan’,\nVariable: compress_value (set to 3). Lossless file compression value. Higher values produce smaller files at the expense of increased script execution time. The set value is a compromise between file size and execution time.\n\n\n\n6 Output\n\nraw – The extracted tif files from the morphology 2D images will be saved in this folder. The file format will follow &lt;fov_num&gt;_ch&lt;#&gt;_raw.&lt;user_format&gt;. &lt;fov_num&gt; is the fov number,ch&lt;#&gt; is the channel number (from 0 to 4), and &lt;user_format&gt; is the specified file type format (see User inputs). Note: If the specified user_format is jpg, the raw files will be 8bit jpg files.\nExample\nF001_ch0_raw.jpg (for user_format = jpg)\n8bit - The images in the raw_folder are converted to 8bit and saved in this folder. Note: If the specified user_format is jpg, the 8bit files are identical to the raw files. The file format will follow &lt;fov_num&gt;_ch&lt;#&gt;_8bit.&lt;user_format&gt; except when user_format = jpg\nExample\nF001_ch0_8bit.tif (for user_format = tif)\nF001_ch0_raw.jpg (for user_format = jpg)\n8bit_autocontrast – Images in the 8bit folder are autocontrasted based on the user supplied clipping value. The file format will follow &lt;fov_num&gt;_ch&lt;#&gt;_8bit_autocontrast.&lt;user_format&gt;\nExample\nF001_ch0_8bit_autocontrast.png (for user_format = png)\ncomposite - Composite images created from the images in the 8bit folder. The composite type is a screen composite. The file format will follow &lt;fov_num&gt;_composite.&lt;user_format&gt;\nExample\nF001_composite.jpg (for user_format = jpg)\ncomposite_autocontrast - Images in the composite_folder are autocontrasted based on the user specified clipping value. The file format will follow &lt;fov_num&gt;_composite_autocontrast.&lt;user_format&gt;\nExample\nF001_composite_autocontrast.png (for user_format = png)\n\n\n\n7 Usage\ncd to/your/Morphology2D folder\npython /path/to/your/make_composite.py # and follow the on-screen prompts\nRegex pattern matching on 2D morphology file name format is implemented, however, only NanoString 2D morphology files should be present in the folder containing the make_composite script.\n\n\n8 Example\nThe example dataset that we used was the mouse coronal hemisphere FFPE dataset that is available to download from NanoString’s website here.\nThe Morphology2D folder is found within the CellStatsDir folder and has TIF files for each of the 130 FOVs.\n\n# In Terminal\ncd /path/to/slide/CellStatsDir/Morphology2D\n\n\n# In Terminal\ntree -L 1\n\n├── 20230406_205644_S1_C902_P99_N99_F001.TIF\n├── 20230406_205644_S1_C902_P99_N99_F002.TIF\n...\n├── 20230406_205644_S1_C902_P99_N99_F129.TIF\n└── 20230406_205644_S1_C902_P99_N99_F130.TIF\n\nOnce in the Morphology2D folder, simply run the script and follow the on-screen prompts (Figure 2).\n\n# In Terminal\npython /path/to/CosMx-Analysis-Scratch-Space/assets/make-composite/make_composite.py\n\n\n\n\n\n\n\n\n\nFigure 2: Screenshot of standard output from terminal following script execution. In this example, I set the clipping percentage to 3 and the output to png. On a Macbook Pro M1, this took about 25 minutes to process 130 FOVs.\n\n\n\n\n\nWhen complete, the structure of the Morphology2D folder should resemble this:\n\n# In Terminal\ntree -L 1\n\n├── 20230406_205644_S1_C902_P99_N99_F001.TIF\n├── 20230406_205644_S1_C902_P99_N99_F002.TIF\n...\n├── 20230406_205644_S1_C902_P99_N99_F129.TIF\n├── 20230406_205644_S1_C902_P99_N99_F130.TIF\n├── 8bit\n├── 8bit_autocontrast\n├── composite\n├── composite_autocontrast\n└── raw\nThese composite images can now be imported into open-sourced software or explored further."
  },
  {
    "objectID": "posts/GeoMx-scMask-generation/index.html",
    "href": "posts/GeoMx-scMask-generation/index.html",
    "title": "GeoMx® mask generation for marker-based single-cell application",
    "section": "",
    "text": "The ability to separate cells based on their relationship to nearby marker protein staining is a desired feature in many biological studies. One such use case would be to study the difference between neurons immediately next to neurofibrillary tangles and neurons that are a little further away. Another example would be to study the immune cells that are at different stages of engulfing microbes. This post introduces a pipeline for automatically generating GeoMx® Digital Spatial Profiler (DSP)-ready binary masks in batch for marker-based single-cell application.\nLike other items in our Analysis Scratch Space, the usual caveats and license applies."
  },
  {
    "objectID": "posts/GeoMx-scMask-generation/index.html#input-image-arguments",
    "href": "posts/GeoMx-scMask-generation/index.html#input-image-arguments",
    "title": "GeoMx® mask generation for marker-based single-cell application",
    "section": "4.1 Input Image Arguments:",
    "text": "4.1 Input Image Arguments:\n\nin_dir\n\nabsolute path to folder containing multi-channel images to evaluate\n\nout_dir\n\noutput parent folder for intermediate results and final masks. (default to use input image folder)\n\ncyto_chan\n\ninput channel index for cytoplasm or membrane stain of cells (starting from 1); Default: 1\n\nquery_chan\n\ninput channel index for the stain in query to define positive vs. negative staining (starting from 1); Default: 2\n\nnuc_chan\n\ninput channel index for nuclear stain of cells (starting from 1); default to 0 to exclude nuclear stain from cell segmentation; Default: 0"
  },
  {
    "objectID": "posts/GeoMx-scMask-generation/index.html#cell-segmentation-model-arguments",
    "href": "posts/GeoMx-scMask-generation/index.html#cell-segmentation-model-arguments",
    "title": "GeoMx® mask generation for marker-based single-cell application",
    "section": "4.2 Cell Segmentation Model Arguments:",
    "text": "4.2 Cell Segmentation Model Arguments:\n\ncell_seg_model\n\ncell segmentation model in use, ok to pass a file path of custom model; Default: cyto3\n\ncell_diameter\n\nmedian cell diameter of input images, in pixel unit; Default: 30\n\nmin_cell_area\n\nminimal area of a valid cell, in squared pixel unit; can turn off with -1; Default: 15"
  },
  {
    "objectID": "posts/GeoMx-scMask-generation/index.html#positive-stained-cell-arguments",
    "href": "posts/GeoMx-scMask-generation/index.html#positive-stained-cell-arguments",
    "title": "GeoMx® mask generation for marker-based single-cell application",
    "section": "4.3 Positive-stained cell Arguments:",
    "text": "4.3 Positive-stained cell Arguments:\n\nthresh_method\n\nauto-threshold method to define positive-stained object in query channel, use either triangle or otsu; Default: triangle\n\nfill_holes\n\nfill holes in positive-stained object before area filtering; if True, use 0.1x of input cell diameter as kernel size and output roundish borders; Default: False\n\nmin_positive_area\n\nminimal area of a positive-stained object in query channel, in squared pixel unit; recommend to be 0.5x of expected cell area; Default: 50\n\nmin_intersect_area\n\nminimal intersection area between a positive-stained cell with nearest positive-stained object in query channel, in squared pixel unit; recommend to be 0.1x of expected cell area; Default: 500\n\nclean_export\n\nexport masks into file only when there are cells selected in either case; Default: False"
  },
  {
    "objectID": "posts/h5ad_conversion/index.html",
    "href": "posts/h5ad_conversion/index.html",
    "title": "Creating an anndata object from AtoMx™ exported results for interactive viewer and python-based analysis",
    "section": "",
    "text": "Annotated Data, AnnData, is a popular data structure for exploring and analyzing high-plex single-cell data, including spatial transcription data. There are quite a few open-sourced single-cell analysis tools in python, e.g. scanpy and squidpy, as well as interactive viewers, e.g. Cirrocumulus and CELLxGENE viewers, using this data structure. Converting CosMx® spatial data sets into anndata data structure allows non-coders to easily share the light-weighted data object, visualize and explore the processed data in an interactive way.\nThis post describes how to create anndata object (.h5ad) from either a post-analysis Seurat object or basic data files exported from AtoMx™ Spatial Informatics Portal (SIP). We hope this post would facilitate seamless integration of CosMx® spatial data sets into Python-based single-cell analysis workflows.\n\nSection 2 Creating an anndata object in .h5ad format from post-analysis Seurat object exported by AtoMx™ SIP\nSection 3 Visualize the post-analysis .h5ad object in an interactive viewer\nSection 4 Creating per-sample anndata object from basic data files in Python for python-based single-cell analysis\n\nLike other items in our CosMx Analysis Scratch Space, the usual caveats and license applies."
  },
  {
    "objectID": "posts/h5ad_conversion/index.html#explore-post-analysis-seurat-object-and-add-in-custom-cell-meta-data",
    "href": "posts/h5ad_conversion/index.html#explore-post-analysis-seurat-object-and-add-in-custom-cell-meta-data",
    "title": "Creating an anndata object from AtoMx™ exported results for interactive viewer and python-based analysis",
    "section": "2.1 Explore post-analysis Seurat object and add in custom cell meta data",
    "text": "2.1 Explore post-analysis Seurat object and add in custom cell meta data\n\n\n\nSetup R\n\nlibrary(Seurat)\nlibrary(SeuratObject)\nlibrary(SeuratDisk)\nlibrary(ggplot2)\n\n# load existing seurat object\nseu.obj &lt;- readRDS(\"seurat_object.Rds\")\n\n\nThe post-analysis Seurat object exported from AtoMx™ SIP should contain\n\nexpression matrices for various feature types, like RNA, RNA_normalized, negprobes and falsecodes;\ndimension reduction results, like pca and umap;\nresults for graphs, like snn and nn.\n\nYou can visualize which results are included by running names(seu.obj). The exact names of the results stored in your post-analysis Seurat object might be slightly different from what are included in the particular example here. Please adjust the code accordingly.\nYou can also add in any new cell metadata if desired. For illustration, the code below adds a new column with unique ID for each FOV.\n\n# add a new column for unique ID of each FOV\nfovNames &lt;- seu.obj@meta.data[, c('slide_ID_numeric', 'fov')]\nfovNames[['fov_names']] &lt;- paste0('fov_', fovNames[['slide_ID_numeric']], \n                            '_', fovNames[['fov']])\nfovNames &lt;- setNames(fovNames[['fov_names']], \n                     nm = rownames(fovNames))\n\nseu.obj &lt;- Seurat::AddMetaData(seu.obj, \n                               metadata = fovNames, \n                               col.name = \"fov_names\")"
  },
  {
    "objectID": "posts/h5ad_conversion/index.html#prepare-spatial-coordinates-and-visualize",
    "href": "posts/h5ad_conversion/index.html#prepare-spatial-coordinates-and-visualize",
    "title": "Creating an anndata object from AtoMx™ exported results for interactive viewer and python-based analysis",
    "section": "2.2 Prepare spatial coordinates and visualize",
    "text": "2.2 Prepare spatial coordinates and visualize\nAtoMx™ SIP stores the per-slide cell segmentation information as separate SeuratObject::FOV objects in the images slot. You can get the slide names by running names(seu.obj@images) in R.\nThe example dataset used in this section has two tissue slides in one study and each slide is in its own spatial coordinate space and thus may have xy overlapping between the slides.\n\n2.2.1 Case 1: 1 slide per anndata object\nWhen a per-slide anndata object is preferred, one should split the Seurat object by the slide name first before cleaning it up in section 2.3. The code below is for generating one anndata object per tissue slide and the resulting data is used in later sections.\n\n# extract the segmentation to separate variable\nimgList &lt;- seu.obj@images\n\n# remove segmentation in current seurat object before split\nfor (slideName in names(imgList)){\n  seu.obj[[slideName]] &lt;- NULL\n}\n\n# split Seurat object by slide name which is stored under \"Run_Tissue_name\" column of cell meta.data. \nobjList &lt;- Seurat::SplitObject(seu.obj, split.by = \"Run_Tissue_name\")\n\n# You can add the segmentation back for each per-slide object \nfor (eachSlide in names(objList)){\n  # standard names used in `images` slot\n  slideName &lt;- gsub(\"\\\\W|_\", \".\", eachSlide)\n  # add the `SeuratObject::FOV` object for current slide alone\n  objList[[eachSlide]][[slideName]] &lt;- imgList[[slideName]]\n}\n\nWe would focus on the first slide for this section.\n\n# keep data for only the 1st section for analysis in later section\neachSlide &lt;- names(objList)[1]\nslideName &lt;- gsub(\"\\\\W|_\", \".\", eachSlide)\nseu.obj1 &lt;- objList[[eachSlide]]\n\n# extract spatial coordinates of each cell for the chosen slide\nspatial_coords &lt;- seu.obj1[[slideName]]$centroids@coords\nrownames(spatial_coords) &lt;- seu.obj1[[slideName]]$centroids@cells\n\nLet’s visualize the current cell segmentation colored by cell types and the molecular positions of a few selected genes. For more visualization tricks using Seurat, please refer to earlier post and Seurat’s vignette on image-based spatial data analysis.\n\n# specify to show cell boundary \nSeuratObject::DefaultBoundary(seu.obj1[[slideName]]) &lt;- \"segmentation\"\n\nSeurat::ImageDimPlot(object = seu.obj1, \n                     fov = slideName, \n                     \n                     # column name of cell type in meta.data\n                     group.by = \"nb_clus_final\", \n                     \n                     # specify which molecules to plot\n                     molecules = c(\"Slc17a7\", \"Gad1\", \"Plp1\"), \n                     mols.size = 1.5, \n                     \n                     # fixed aspect ratio and flip xy in plotting\n                     coord.fixed = TRUE, flip_xy = TRUE)\n\n\nYou can zoom in to view a subset of cells by specifying which cells to plots.\n\n# change idents to \"fov\" for cell selection\n# note: \"fov\" here is a column in cell meta.data instead of the `SeuratObject::FOV` object. \nSeuratObject::Idents(seu.obj1) &lt;- \"fov\"\n\nSeurat::ImageDimPlot(object = seu.obj1, \n                     fov = slideName, \n                     \n                     # column name of cell type in meta.data\n                     group.by = \"nb_clus_final\", \n                     \n                     # a vector of chosen cells, plot cells in chosen fovs\n                     cells = SeuratObject::WhichCells(\n                       seu.obj1, idents = c(72:74, 90:92, 97:99, 114:116)), \n                     \n                     # crop the plots to area with cells only\n                     crop = TRUE, \n                     \n                     # fixed aspect ratio and flip xy in plotting\n                     coord.fixed = TRUE, flip_xy = TRUE)\n\n\n\n\n2.2.2 Case 2: multi-slide per anndata object\nSince AtoMx™ SIP keeps the spatial coordinates of each slide in their own spatial coordinate space, one would need to arrange the spatial coordinates of multiple sample sections to avoid overlap in XY space when exporting multiple slides in same study-level anndata object. The example code below would arrange all slides along Y axis with some spacing between the slides.\n\n# extract the segmentation to separate variable\nimgList &lt;- seu.obj@images\n\n# arrange slides along Y axis, add in spacer which is 0.2x of previous slide's coordinate span in Y direction\nspacerFactor &lt;- 0.2\nglobal_y_offset &lt;- 0 \n\nspatial_coords &lt;- lapply(imgList, function(img){\n  # coordinates of query slide\n  eachCoord &lt;- img$centroids@coords\n  rownames(eachCoord) &lt;- img$centroids@cells\n  \n  # align to lower left corner\n  ori_offsets &lt;- apply(eachCoord, 2, min)\n  eachCoord &lt;- sweep(eachCoord, 2, ori_offsets, \"-\")\n  \n  # span in y direction\n  y_span &lt;- diff(range(eachCoord[, 2]))\n\n  # add spacer in y direction \n  eachCoord[, 2] &lt;- eachCoord[, 2] + global_y_offset\n  \n  # update global offset for next slide\n  global_y_offset &lt;&lt;- global_y_offset + y_span*(1+spacerFactor)\n  \n  return(eachCoord)\n})\nspatial_coords &lt;- do.call(rbind, spatial_coords)  \n\n# use the study-level Seurat object for downstream\nseu.obj1 &lt;- seu.obj\n\n# prefix for file name\nslideName &lt;- \"StudyLevel\" \n\nLet’s visualize the coordinates of all cells after slide arrangement.\n\n# add in cell type for color\nplotData &lt;- cbind(seu.obj1[[\"nb_clus_final\"]], \n                  spatial_coords[colnames(seu.obj1), ])\n\nggplot2::ggplot(plotData, \n                # flip xy to be consistent with earlier plots\n                ggplot2::aes(x = y, y = x, color = as.factor(nb_clus_final))) +\n  ggplot2::geom_point(size = 0.1)+\n  ggplot2::coord_fixed()+\n  Seurat::NoLegend()+\n  Seurat::DarkTheme()"
  },
  {
    "objectID": "posts/h5ad_conversion/index.html#sec-cleanUp",
    "href": "posts/h5ad_conversion/index.html#sec-cleanUp",
    "title": "Creating an anndata object from AtoMx™ exported results for interactive viewer and python-based analysis",
    "section": "2.3 Clean up to keep only necessary data",
    "text": "2.3 Clean up to keep only necessary data\nNext, we would further clean up the Seurat object (single-slide object from Case 1 in section 2.2.1 or full-study-level object from Case 2 in section 2.2.2) by trimming it down to contain only the data of interested.\nTypically, one would keep the raw data counts from RNA assay (this example dataset uses Nanostring as assay name for RNA), cell embedding for umap (standard AtoMx exported object uses approximateumap as name for umap). We would also store the spatial coordinates of each cell as the cell embedding in a dimension reduction object called spatial.\n\n# clean up seurat object to only necessary data \nseu.obj2 &lt;- Seurat::DietSeurat(\n  seu.obj1, \n  \n  # subset of assays to keep, standard AtoMx object uses \"RNA\" assay\n  # of note, AtoMx stores normalized RNA counts in separate \"RNA_normalized\" assay\n  assays = \"Nanostring\",\n  \n  # keep raw counts stored in \"counts\" layer\n  # use \"data\" or \"scale.data\" if prefer to keep normalized counts before or after scaling\n  layers = \"counts\", \n  \n  # dimension reduction to keep, standard AtoMx object uses \"approximateumap\"\n  dimreducs = \"umap\")\n\n# clear the `images` slot\nallImgs &lt;- names(seu.obj1@images)\nfor (img in allImgs){\n  seu.obj2[[img]] &lt;- NULL\n}\n\n# add in spatial coordinates for current slide or study as a new dimension reduction\ncolnames(spatial_coords) &lt;- paste0(\"SPATIAL_\", seq_len(ncol(spatial_coords)))\nseu.obj2[[\"spatial\"]] &lt;- Seurat::CreateDimReducObject(\n  embeddings = spatial_coords, \n  key = \"SPATIAL_\", \n  # standard AtoMx object use \"RNA\" assay\n  assay = \"Nanostring\")"
  },
  {
    "objectID": "posts/h5ad_conversion/index.html#converting-to-h5ad-format-via-h5seurat",
    "href": "posts/h5ad_conversion/index.html#converting-to-h5ad-format-via-h5seurat",
    "title": "Creating an anndata object from AtoMx™ exported results for interactive viewer and python-based analysis",
    "section": "2.4 Converting to h5ad format via h5Seurat",
    "text": "2.4 Converting to h5ad format via h5Seurat\nLastly, we would export the cleaned Seurat object into h5Seurat format and then further convert it into h5ad format using SeuratDisk::Convert function.\n\n# export as \"h5Seurat\" object in your current working directory\nSeuratDisk::SaveH5Seurat(seu.obj2, \n                         filename = paste0(slideName, \"_subset.h5Seurat\"))\n\n Creating h5Seurat file for version 3.1.5.9900 Adding counts for Nanostring Adding data for Nanostring No variable features found for Nanostring No feature-level metadata found for Nanostring Adding cell embeddings for umap No loadings for umap No projected loadings for umap No standard deviations for umap No JackStraw data for umap Adding cell embeddings for spatial No loadings for spatial No projected loadings for spatial No standard deviations for spatial No JackStraw data for spatial\n\n# convert to h5ad format\nSeuratDisk::Convert(paste0(slideName, \"_subset.h5Seurat\"), \n                    dest = \"h5ad\")\n\n Validating h5Seurat file Adding data from Nanostring as X Adding counts from Nanostring as raw Transfering meta.data to obs Adding dimensional reduction information for spatial Adding dimensional reduction information for umap"
  },
  {
    "objectID": "posts/batchcorrection/index.html",
    "href": "posts/batchcorrection/index.html",
    "title": "Recommendations for batch correction",
    "section": "",
    "text": "This post discusses batch effects in CosMx; how they impact analyses, how to detect them, and how to correct them. We recommend Harmony (Korsunsky et al. 2019) as a useful method for correcting batch effects in dimension reduction embeddings such as PCA, and demonstrate an example of how to use the software package.\nFor those in a hurry to ‘just see the code’, feel free to jump ahead to the Harmony Analysis section of this post."
  },
  {
    "objectID": "posts/batchcorrection/index.html#plot-the-two-batches",
    "href": "posts/batchcorrection/index.html#plot-the-two-batches",
    "title": "Recommendations for batch correction",
    "section": "3.1 Plot the two batches",
    "text": "3.1 Plot the two batches\nLet’s take a quick peek at these two tissues, where unsupervised clustering has been performed independently on each:\n\n\nCode\nxyplot &lt;- function (cluster_column, x_column = \"x_slide_mm\", y_column = \"y_slide_mm\", \n                   cls = NULL, clusters = NULL, metadata, ptsize = 0.25, plotfirst = NULL, \n                   alphasize = 1){\n  pd &lt;- data.table::copy(data.table::data.table(metadata))\n  if (is.null(clusters)) \n    clusters &lt;- unique(pd[[cluster_column]])\n  if (!is.null(plotfirst)) {\n    plotfirst &lt;- intersect(clusters, plotfirst)\n    notplotfirst &lt;- setdiff(clusters, plotfirst)\n    p &lt;- ggplot(pd[pd[[cluster_column]] %in% plotfirst], \n                aes(.data[[x_column]], .data[[y_column]], color = .data[[cluster_column]])) + \n      geom_point(size = ptsize)\n    p &lt;- p + geom_point(data = pd[pd[[cluster_column]] %in% \n                                    notplotfirst], aes(.data[[x_column]], .data[[y_column]], \n                                                       color = .data[[cluster_column]]), size = ptsize, \n                        alpha = alphasize) + theme_bw()\n  }\n  else {\n    p &lt;- ggplot(pd[pd[[cluster_column]] %in% clusters], aes(.data[[x_column]], \n                                                            .data[[y_column]], color = .data[[cluster_column]])) + \n      geom_point(size = ptsize, alpha = alphasize) + theme_bw()\n  }\n  if (is.null(cls)) {\n    cls &lt;- rep(unname(pals::alphabet()), 100)\n    if (any(is.na(suppressWarnings(as.numeric(as.character(clusters)))))) {\n      clnames &lt;- sort(clusters)\n    }\n    else {\n      clnames &lt;- sort(as.numeric(as.character(clusters)))\n    }\n    cls &lt;- cls[1:length(clusters)]\n    names(cls) &lt;- clnames\n    p &lt;- p + scale_color_manual(values = cls, guide = guide_legend(override.aes = list(size = 4, \n                                                                                       alpha = 1)))\n  }\n  else {\n    p &lt;- p + scale_color_manual(values = cls, guide = guide_legend(override.aes = list(size = 4, \n                                                                                       alpha = 1)))\n  }\n  return(p)\n}\n\nxyp &lt;- \ncowplot::plot_grid(\n  xyplot(\"seurat_clusters\",metadata =  sem_v20@meta.data,ptsize = 0.02) + coord_fixed() + labs(title = \" v2.0\")\n  ,xyplot(\"seurat_clusters\",metadata =  sem_v15@meta.data,ptsize = 0.02) + coord_fixed() + labs(title = \"v1.5\")\n  ,nrow=1\n) +  theme(plot.background = element_rect(fill = 'white',color='white')) + \n  cowplot::panel_border(remove=TRUE)"
  },
  {
    "objectID": "posts/batchcorrection/index.html#differences-in-sensitivity-between-batches",
    "href": "posts/batchcorrection/index.html#differences-in-sensitivity-between-batches",
    "title": "Recommendations for batch correction",
    "section": "3.2 Differences in sensitivity between batches",
    "text": "3.2 Differences in sensitivity between batches\nHere, we can compute a few high-level summary stats like transcripts per cell and signal to noise ratio (SNR) for each batch.\nWe see ~2x increase in transcripts per cell with the v2.0 dataset, and higher signal to noise ratio (snr).\n\n## Comparing counts/cell\n\ncts_cell_1.5 &lt;- mean(Matrix::colSums(sem_v15[[\"RNA\"]]$counts))\ncts_cell_2.0 &lt;- mean(Matrix::colSums(sem_v20[[\"RNA\"]]$counts))\n\n## Comparing SNR\nsnr_1.5 &lt;- mean(Matrix::colMeans(sem_v15[[\"RNA\"]]$counts)) / mean(Matrix::colMeans(sem_v15[[\"negprobes\"]]$counts)) \nsnr_2.0 &lt;- mean(Matrix::colMeans(sem_v20[[\"RNA\"]]$counts)) / mean(Matrix::colMeans(sem_v20[[\"negprobes\"]]$counts))\n\nsummary_stats &lt;- \ndata.table(transcripts_per_cell = c(cts_cell_1.5, cts_cell_2.0)\n           ,snr = c(snr_1.5, snr_2.0)\n           ,version = c(\"v1.5\", \"v2.0\"))[]\n\n\nprint(summary_stats[])\n\n   transcripts_per_cell      snr version\n                  &lt;num&gt;    &lt;num&gt;  &lt;char&gt;\n1:             448.3808 3.770205    v1.5\n2:            1026.5255 6.043639    v2.0"
  },
  {
    "objectID": "posts/smiDE/index.html",
    "href": "posts/smiDE/index.html",
    "title": "smiDE: an open-source package for differential expression analysis with spatially correlated data",
    "section": "",
    "text": "Spatially-resolved transcriptomic (SRT) data offers unprecedented insights into gene expression patterns, but analyzing this data requires specialized approaches. Traditional differential expression (DE) methods often falter when applied to spatially correlated data, leading to unreliable results and significant rates of false discovery. To address this challenge, (Vasconcelos et al. 2024) present a comprehensive analysis of DE methodologies in their preprint, “Differential Expression Analysis for Spatially Correlated Data” . This work systematically evaluates the performance of various modeling strategies, providing clear recommendations for researchers.\nThe rest of this post aims to summarize some of the key findings from the paper and provide practical guidance on how to conduct robust DE analysis with spatial data. The accompanying smiDE R package offers readily accessible tools for implementing these recommendations.\n\n\nWhile DE analysis has long been a core component of gene expression studies, SRT data presents new opportunities for addressing fundamental questions regarding how cells respond to their local environment and interact with other cell types.\nAs a motivating example, suppose I have annotated cell type and spatial context in my dataset; I might be broadly interested in T cells, cancer cells, and how they behave within different spatial contexts.\n\n\n\n\n\n\n\n\n\nTons of interesting questions along these lines can be phrased as DE problems, for example\n\nHow does the expression of genes in T cells differ when located in stroma vs. tumor bed? (Left panel, blue vs. purple points)\nHow does expression of genes in cancer cells in the tumor bed differ based on distance to the nearest T-cell? (middle panel, cancer cells with arrow drawn to nearest T cell and colored by distance)\nHow is gene expression for T-cells in stroma modulated by distance to the tumor bed? (Right panel, rings highlight benchmarks of “distance from tumor bed”)\n\n\n\n\n\n\n\n\n\n\n\n\n\nWhile the types of questions we can tackle with DE are limitless, there are unique challenges associated with SRT technologies that can lead to false discoveries when not properly addressed.\nTwo primary issues include:\n\nsegmentation errors\n\nunmodeled auto-correlation in expression amongst spatially neighboring cells\n\nBelow, we’ll give a very brief overview of how these problems can lead to biased effects estimates and incorrect inferences in DE.\n\n\nEven minor segmentation errors can distort DE results if the analysis doesn’t properly account for them. For example, suppose I want to analyze the behavior of macrophage cells, and how gene expression differs for macrophages in tumor-infiltrated regions of tissue.\nThe picture below shows KRT17 transcripts from neighboring epithelial (cancer) cells falsely assigned to the macrophage cell inside a tumor region.\nA naiive DE analysis may identify KRT17 as DE in the tumor, while an experienced bioinformatician may immediately recognize that this gene should not be expressed in the macrophage cell type at all (the very presence of the gene would challenge the cell type identity).\n\nThe picture below shows KRT17 transcripts from neighboring cancer cells falsely assigned to the macrophage cell inside a tumor region.\n\n\n\n\n\n\n\n\n\nEven if the number of falsely assigned transcripts is small, these errors are correlated with our DE question in a way that confounds the analysis. Namely, the false positive KRT17 transcripts are more likely than not to occur in tumor regions compared to elsewhere because they come from the cancer cells!\nWe could describe this dilemma for a DE analysis through a directed-acyclic graph, where the neighboring KRT17 expression in cancer cells acts as a confounder.\n\n\n\n\n\n\n\n\n\nIn the paper, we propose two approaches to deal with this issue.\n\nA ‘overlapping cells metric’: Used to identify genes which may be expressed within specific cell types due primarily due to overlapping cells / segmentation errors , and exclude them from cell-type specific DE analysis. The metric computes the average expression in “macrophage cells”, and the average expression in spatial neighbors of macrophage cells among all non-macrophage cell types. The ratio of these two average expression vectors is a quick and useful way to discard implausible genes.\nCovariate adjustment: We can compute the total expression of ‘KRT17’ in the spatial neighbors of macrophage cells among all non-macrophage neighbors, and include this as a control variable in the regression model.\n\nBelow is a side-by-side summary of volcano plots before and after implementing these approaches, where genes are colored by their plausible cell type annotation from the Human Protein Atlas, and marked by whether or not the gene passes the overlapping cells metric.\nOn the left, a number of implausible brown genes which should be “Not detected in immune cells” are falsely identified as being upregulated in macrophages in the tumor region. Nearly all of these genes could be pre-filtered before DE is conducted, by nature of “failing the filter” metric.\nOn the right-hand side, we see the significance and fold change for a large number of genes is largely attenuated if we employ the covariate-adjustment approach; controlling for expression in neighboring cells of other cell types.\n\n\n\n\n\n\n\n\n\n\n\n\nSpatial auto-correlation is another way in which gene expression could inflate statistical significance in DE. Intuitively, neighboring cells may have more similar gene expression profiles compared to cells located at greater distances, due to factors which may be unrelated to our covariate of interest. A solution we propose is to include a spatially correlated random effect (SRE) in the DE model, which can account for the un-modeled spatial correlations in expression.\nFor example, suppose I am working with a colon-cancer dataset, and am interested in researching how gene expression changes in B cells as they approach the center of tertiary lymphoid structures.\nI may count the number of immune cells neighboring the B-cells as a continuous measurement of how close the B cell is to the center of the TLS.\nBelow, the left hand plot highlights two densely packed clusters of B cells in TLS regions, and on the right, these B cells are annotated by the covariate (# of immune cell neighbors).\n\n\n\n\n\n\n\n\n\nBelow, we show how inference can change from a naiive DE analysis (left), to a ‘segmentation-aware’ analysis (middle), to a DE analysis which also includes the spatial random effect (right). The model with SRE identifies a set of 9 high-confidence DE genes with up-regulated expression in TLS interior, down from 141 DE genes identified through the naiive approach.\n\n\n\n\n\n\n\n\n\nThe ability to visually assess the behavior of the random effects can provide further context for the analysis. For example, CD79A retains significance in the SRE model, showing several concentrated regions of high expression captured by the random effect. For WNT7A, numerous small regions of autocorrelated expression reduce the significance of the gene when taken into context of the model."
  },
  {
    "objectID": "posts/smiDE/index.html#opportunities",
    "href": "posts/smiDE/index.html#opportunities",
    "title": "smiDE: an open-source package for differential expression analysis with spatially correlated data",
    "section": "",
    "text": "While DE analysis has long been a core component of gene expression studies, SRT data presents new opportunities for addressing fundamental questions regarding how cells respond to their local environment and interact with other cell types.\nAs a motivating example, suppose I have annotated cell type and spatial context in my dataset; I might be broadly interested in T cells, cancer cells, and how they behave within different spatial contexts.\n\n\n\n\n\n\n\n\n\nTons of interesting questions along these lines can be phrased as DE problems, for example\n\nHow does the expression of genes in T cells differ when located in stroma vs. tumor bed? (Left panel, blue vs. purple points)\nHow does expression of genes in cancer cells in the tumor bed differ based on distance to the nearest T-cell? (middle panel, cancer cells with arrow drawn to nearest T cell and colored by distance)\nHow is gene expression for T-cells in stroma modulated by distance to the tumor bed? (Right panel, rings highlight benchmarks of “distance from tumor bed”)"
  },
  {
    "objectID": "posts/smiDE/index.html#unique-challenges-for-de-analyis-with-srt-data",
    "href": "posts/smiDE/index.html#unique-challenges-for-de-analyis-with-srt-data",
    "title": "smiDE: an open-source package for differential expression analysis with spatially correlated data",
    "section": "",
    "text": "While the types of questions we can tackle with DE are limitless, there are unique challenges associated with SRT technologies that can lead to false discoveries when not properly addressed.\nTwo primary issues include:\n\nsegmentation errors\n\nunmodeled auto-correlation in expression amongst spatially neighboring cells\n\nBelow, we’ll give a very brief overview of how these problems can lead to biased effects estimates and incorrect inferences in DE.\n\n\nEven minor segmentation errors can distort DE results if the analysis doesn’t properly account for them. For example, suppose I want to analyze the behavior of macrophage cells, and how gene expression differs for macrophages in tumor-infiltrated regions of tissue.\nThe picture below shows KRT17 transcripts from neighboring epithelial (cancer) cells falsely assigned to the macrophage cell inside a tumor region.\nA naiive DE analysis may identify KRT17 as DE in the tumor, while an experienced bioinformatician may immediately recognize that this gene should not be expressed in the macrophage cell type at all (the very presence of the gene would challenge the cell type identity).\n\nThe picture below shows KRT17 transcripts from neighboring cancer cells falsely assigned to the macrophage cell inside a tumor region.\n\n\n\n\n\n\n\n\n\nEven if the number of falsely assigned transcripts is small, these errors are correlated with our DE question in a way that confounds the analysis. Namely, the false positive KRT17 transcripts are more likely than not to occur in tumor regions compared to elsewhere because they come from the cancer cells!\nWe could describe this dilemma for a DE analysis through a directed-acyclic graph, where the neighboring KRT17 expression in cancer cells acts as a confounder.\n\n\n\n\n\n\n\n\n\nIn the paper, we propose two approaches to deal with this issue.\n\nA ‘overlapping cells metric’: Used to identify genes which may be expressed within specific cell types due primarily due to overlapping cells / segmentation errors , and exclude them from cell-type specific DE analysis. The metric computes the average expression in “macrophage cells”, and the average expression in spatial neighbors of macrophage cells among all non-macrophage cell types. The ratio of these two average expression vectors is a quick and useful way to discard implausible genes.\nCovariate adjustment: We can compute the total expression of ‘KRT17’ in the spatial neighbors of macrophage cells among all non-macrophage neighbors, and include this as a control variable in the regression model.\n\nBelow is a side-by-side summary of volcano plots before and after implementing these approaches, where genes are colored by their plausible cell type annotation from the Human Protein Atlas, and marked by whether or not the gene passes the overlapping cells metric.\nOn the left, a number of implausible brown genes which should be “Not detected in immune cells” are falsely identified as being upregulated in macrophages in the tumor region. Nearly all of these genes could be pre-filtered before DE is conducted, by nature of “failing the filter” metric.\nOn the right-hand side, we see the significance and fold change for a large number of genes is largely attenuated if we employ the covariate-adjustment approach; controlling for expression in neighboring cells of other cell types.\n\n\n\n\n\n\n\n\n\n\n\n\nSpatial auto-correlation is another way in which gene expression could inflate statistical significance in DE. Intuitively, neighboring cells may have more similar gene expression profiles compared to cells located at greater distances, due to factors which may be unrelated to our covariate of interest. A solution we propose is to include a spatially correlated random effect (SRE) in the DE model, which can account for the un-modeled spatial correlations in expression.\nFor example, suppose I am working with a colon-cancer dataset, and am interested in researching how gene expression changes in B cells as they approach the center of tertiary lymphoid structures.\nI may count the number of immune cells neighboring the B-cells as a continuous measurement of how close the B cell is to the center of the TLS.\nBelow, the left hand plot highlights two densely packed clusters of B cells in TLS regions, and on the right, these B cells are annotated by the covariate (# of immune cell neighbors).\n\n\n\n\n\n\n\n\n\nBelow, we show how inference can change from a naiive DE analysis (left), to a ‘segmentation-aware’ analysis (middle), to a DE analysis which also includes the spatial random effect (right). The model with SRE identifies a set of 9 high-confidence DE genes with up-regulated expression in TLS interior, down from 141 DE genes identified through the naiive approach.\n\n\n\n\n\n\n\n\n\nThe ability to visually assess the behavior of the random effects can provide further context for the analysis. For example, CD79A retains significance in the SRE model, showing several concentrated regions of high expression captured by the random effect. For WNT7A, numerous small regions of autocorrelated expression reduce the significance of the gene when taken into context of the model."
  },
  {
    "objectID": "posts/cell-typing-basics/index.html",
    "href": "posts/cell-typing-basics/index.html",
    "title": "Cell typing: what we’ve found to work",
    "section": "",
    "text": "We cell type most studies using one of the following approaches:\n\nInsitutype\nLeiden clustering\nSeurat’s label transfer algorithm\n\n\n\nWe created Insitutype for cell typing in CosMx® data. It can perform unsupervised clustering, supervised cell typing if given a matrix of reference profiles, or semi-supervised cell typing to call pre-defined cell types alongside new clusters. Insitutype models the evidence provided by every gene in a cell’s profile; this makes it excel in cells / datasets with less signal.\nInsitutype resources:\n\nInsitutype package: https://github.com/Nanostring-Biostats/insitutype (see the FAQs.md for detailed advice)\nInsitutype manuscript: https://www.biorxiv.org/content/10.1101/2022.10.19.512902v1 (Danaher et al. 2022)\nA collection of cell profile reference matrices derived from CosMx datasets\nA collection of cell profile reference matrices derived from sc-RNA-seq datasets\n\n\n\n\nA single-cell clustering mainstay. Unsupervised clustering only. Often run from principal components of the expression data. Seurat, Giotto and igraph all have convenient implementations.\n\n\n\nIf a full scRNA-seq reference dataset is available, and if no new cell types are expected in the CosMx data, then these algorithms can work well. We have found Seurat’s implementation to work in some studies.\n\n\n\n\n\nLeiden clustering and UMAP tend to see the world the same way - that is, they’re both based on networks connecting similar cells. This makes Leiden results agree well with the UMAP, whether or not they are truly more accurate. In other words, don’t take the UMAP as an impartial arbiter of cell typing truth.\nInsitutype tends to be the most resistant to batch effects; methods that rely on PCs tend to be the most easily fooled by batch effects.\nMost studies require careful scrutiny of cell typing results. Often clusters have to be merged or subclustered before results are satisfactory. See the Insitutype FAQs.md for a detailed discussion of how to QC & refine cell typing results. Many of these QCs are useful for results of other methods."
  },
  {
    "objectID": "posts/cell-typing-basics/index.html#choice-of-cell-typing-algorithm",
    "href": "posts/cell-typing-basics/index.html#choice-of-cell-typing-algorithm",
    "title": "Cell typing: what we’ve found to work",
    "section": "",
    "text": "We cell type most studies using one of the following approaches:\n\nInsitutype\nLeiden clustering\nSeurat’s label transfer algorithm\n\n\n\nWe created Insitutype for cell typing in CosMx® data. It can perform unsupervised clustering, supervised cell typing if given a matrix of reference profiles, or semi-supervised cell typing to call pre-defined cell types alongside new clusters. Insitutype models the evidence provided by every gene in a cell’s profile; this makes it excel in cells / datasets with less signal.\nInsitutype resources:\n\nInsitutype package: https://github.com/Nanostring-Biostats/insitutype (see the FAQs.md for detailed advice)\nInsitutype manuscript: https://www.biorxiv.org/content/10.1101/2022.10.19.512902v1 (Danaher et al. 2022)\nA collection of cell profile reference matrices derived from CosMx datasets\nA collection of cell profile reference matrices derived from sc-RNA-seq datasets\n\n\n\n\nA single-cell clustering mainstay. Unsupervised clustering only. Often run from principal components of the expression data. Seurat, Giotto and igraph all have convenient implementations.\n\n\n\nIf a full scRNA-seq reference dataset is available, and if no new cell types are expected in the CosMx data, then these algorithms can work well. We have found Seurat’s implementation to work in some studies."
  },
  {
    "objectID": "posts/cell-typing-basics/index.html#general-cell-typing-notes",
    "href": "posts/cell-typing-basics/index.html#general-cell-typing-notes",
    "title": "Cell typing: what we’ve found to work",
    "section": "",
    "text": "Leiden clustering and UMAP tend to see the world the same way - that is, they’re both based on networks connecting similar cells. This makes Leiden results agree well with the UMAP, whether or not they are truly more accurate. In other words, don’t take the UMAP as an impartial arbiter of cell typing truth.\nInsitutype tends to be the most resistant to batch effects; methods that rely on PCs tend to be the most easily fooled by batch effects.\nMost studies require careful scrutiny of cell typing results. Often clusters have to be merged or subclustered before results are satisfactory. See the Insitutype FAQs.md for a detailed discussion of how to QC & refine cell typing results. Many of these QCs are useful for results of other methods."
  },
  {
    "objectID": "posts/vignette-basic-analysis-updated/03_DE.html",
    "href": "posts/vignette-basic-analysis-updated/03_DE.html",
    "title": "Basic analysis vignette: differential expression",
    "section": "",
    "text": "Here we provide workflows for differential expression testing. Also see the companion posts on pre-processing and exploratory analysis. A complete analysis will typically begin with the pre-processing workflow, use exploratory analyses to generate hypotheses, then conclude by using differential expression analysis to test those hypotheses.\nWhether you crafted your study with specific hypotheses in mind or discovered interesting trends while exploring your data, most CosMx® analyses will culminate in differential expression (DE) analyses. DE is a remarkably versatile tool for posing biological questions about how cells’ behavior changes in response to exposures like spatial context or patient-level attributes. Here we provide a convenient framework for posing your biological questions as DE tests.\nCode is organized into the following sections, with the following inputs and outputs:\n\n\n\n\n\n\n\n\nStep\nInputs\nOutputs\n\n\n\n\nDefining predictor variables\nxy, cell type, custom inputs\nPredictor variables\n\n\nFind safe genes via overlap ratio metric\nRaw counts, xy, cell type\nGenes to analyze per cell type\n\n\npre-DE calculations\nxy\npreDE (object for modeling segmentation errors)\n\n\n“Standard” DE with smiDE\nPredictor variables, Raw counts, preDE, cell type, list of genes to analyze per cell type\nDE outputs: p-values, effect sizes, etc.\n\n\n“Optimal / slow” DE with smiDE\nPredictor variables, Raw counts, preDE, cell type, genes to analyze per cell type\nDE outputs: p-values, effect sizes, etc.\n\n\n“Hasty / exploratory” DE with hastyDE\nPredictor variables, Normalized counts, cell type, genes to analyze per cell type\nDE outputs: p-values, effect sizes, etc.\n\n\n“Stepwise” DE with hastyDE & smiDE\nPredictor variables, Normalized counts, Raw counts, cell type, genes to analyze per cell type\nDE outputs: p-values, effect sizes, etc.\n\n\nAnalysis of DE results\nDE results\nplots and tables\n\n\n\nThis document exists to facilitate the coding of DE analyses, not as a literature review or an unveiling of new methods. For an extensive discussion of DE in spatial data, see this ealier post. We’ll be relying on the smiDE package, described in this post and this preprint.\n\n\nTo begin, load your fully pre-processed data (including cell type annotations). We assume the format generated by the preprocessing vignette:\n\na sparse counts matrix with cells in rows and genes in columns\na data table of per-cell metadata, row-aligned with the counts matrix\na matrix of cells’ xy positions, row-aligned with the counts matrix\n\n\n\nCode\n## load necessary libraries\nlibrary(data.table) # for more memory efficient data frames\nlibrary(Matrix) # for sparse matrices like our counts matrix\nlibrary(ggplot2)\nlibrary(smiDE) # remotes::install_github(\"Nanostring-Biostats/CosMx-Analysis-Scratch-Space\", subdir = \"_code/smiDE\", ref = \"Main\")\nlibrary(pheatmap)\nlibrary(InSituCor) # devtools::install_github(\"https://github.com/Nanostring-Biostats/InSituCor\")\n\n## load data:\ncounts &lt;- readRDS(paste0(outdir, \"/processed_data/counts.RDS\"))\nmetadata &lt;- readRDS(paste0(outdir, \"/processed_data/metadata.RDS\")) # expected to have the column \"celltype\"\nxy &lt;- readRDS(paste0(outdir, \"/processed_data/xy.RDS\"))\n\n\nThen we’ll define each cell’s neighbors. This will prove useful for a variety of downstream calculations. Note that cells are not included in their own neighbors.\n\n\nCode\n## define cell neighborhoods:\n# get the 50 nearest neighbors of each cell:\nneighbors &lt;- InSituCor:::nearestNeighborGraph(\n  x = xy[, 1], y = xy[, 2], \n  N = 50,  # number of neighbors\n  subset = metadata$slide_ID_numeric)  # optional argument to ensure cells with similar xy positions in different slides aren't linked\n\n# or alternatively, get neighbors within a radius of 0.1mm:\nneighbors &lt;- InSituCor:::radiusBasedGraph(\n  x = xy[, 1], y = xy[, 2], \n  R = 0.1,  # radius\n  subset = metadata$slide_ID_numeric) # optional argument to ensure cells with similar xy positions in different slides aren't linked\n\n# see how many neighbors you're defining for each cell:\nsummary(Matrix::rowSums(1 * (neighbors20 &gt; 0)))"
  },
  {
    "objectID": "posts/vignette-basic-analysis-updated/03_DE.html#getting-started",
    "href": "posts/vignette-basic-analysis-updated/03_DE.html#getting-started",
    "title": "Basic analysis vignette: differential expression",
    "section": "",
    "text": "To begin, load your fully pre-processed data (including cell type annotations). We assume the format generated by the preprocessing vignette:\n\na sparse counts matrix with cells in rows and genes in columns\na data table of per-cell metadata, row-aligned with the counts matrix\na matrix of cells’ xy positions, row-aligned with the counts matrix\n\n\n\nCode\n## load necessary libraries\nlibrary(data.table) # for more memory efficient data frames\nlibrary(Matrix) # for sparse matrices like our counts matrix\nlibrary(ggplot2)\nlibrary(smiDE) # remotes::install_github(\"Nanostring-Biostats/CosMx-Analysis-Scratch-Space\", subdir = \"_code/smiDE\", ref = \"Main\")\nlibrary(pheatmap)\nlibrary(InSituCor) # devtools::install_github(\"https://github.com/Nanostring-Biostats/InSituCor\")\n\n## load data:\ncounts &lt;- readRDS(paste0(outdir, \"/processed_data/counts.RDS\"))\nmetadata &lt;- readRDS(paste0(outdir, \"/processed_data/metadata.RDS\")) # expected to have the column \"celltype\"\nxy &lt;- readRDS(paste0(outdir, \"/processed_data/xy.RDS\"))\n\n\nThen we’ll define each cell’s neighbors. This will prove useful for a variety of downstream calculations. Note that cells are not included in their own neighbors.\n\n\nCode\n## define cell neighborhoods:\n# get the 50 nearest neighbors of each cell:\nneighbors &lt;- InSituCor:::nearestNeighborGraph(\n  x = xy[, 1], y = xy[, 2], \n  N = 50,  # number of neighbors\n  subset = metadata$slide_ID_numeric)  # optional argument to ensure cells with similar xy positions in different slides aren't linked\n\n# or alternatively, get neighbors within a radius of 0.1mm:\nneighbors &lt;- InSituCor:::radiusBasedGraph(\n  x = xy[, 1], y = xy[, 2], \n  R = 0.1,  # radius\n  subset = metadata$slide_ID_numeric) # optional argument to ensure cells with similar xy positions in different slides aren't linked\n\n# see how many neighbors you're defining for each cell:\nsummary(Matrix::rowSums(1 * (neighbors20 &gt; 0)))"
  },
  {
    "objectID": "posts/vignette-basic-analysis-updated/03_DE.html#defining-categorical-variables",
    "href": "posts/vignette-basic-analysis-updated/03_DE.html#defining-categorical-variables",
    "title": "Basic analysis vignette: differential expression",
    "section": "2.1 Defining categorical variables",
    "text": "2.1 Defining categorical variables\nBelow we provide code for 4 different approaches to defining categorical variables for analysis:\n\nPartitioning the tissue into niches / spatial domains using the Novae algorithm. Spatial domains are a natural framework for comparing cells’ expression patterns across spatial contexts; we have found the Novae algorithm to perform well.\nSelecting custom regions of interest. Use this code to hand-select regions for comparison, e.g. distinct lobes of a tumor, or a tertiary lymphoid structure, or a region suggested by review of H&E, IF, or protein images.\nLogical combinations of existing metadata columns, including dichotomization of continuous variables, e.g. gene expression (“B2M high”), pathway score (“INFG signaling high”) or one of the continuous variables calculated below (“distance to tumor glands”).\nDefining anatomical features consisting of spatially contiguous cells.\n\n\nNovae nichesCustom ROIsCombining existing annotationsAnatomical features / groups of contiguous cells\n\n\nYou can now get Novae niches in an AtoMx pipeline module. Alternatively, compute them with the below code. Note that Novae is a python package; here we show how to call it from R, leaving details of python setup to you.\nFirst we’ll use R to prepare our data for Novae, writing it to a h5ad file:\n\n\nCode\n# create a seurat object:\n\n# Convert to single cell experiment\nsce &lt;- as.SingleCellExperiment(seu.obj)\n\n# Save as h5ad\nh5ad_path &lt;- paste0(objects_dir, \"/assay_data.h5ad\")\n#writeH5AD(se_hdf5, file = h5ad_path)\nwriteH5AD(sce, file = h5ad_path, X_name = \"counts\", assay = \"counts\")\n\n\nNow we run python code to call Novae. Note that this can easily take a day to compute on a CPU; a GPU might take 30 minutes.\n\n\nCode\nlibrary(reticulate)\n\npy_run_string(\"\n\n\nimport novae\nimport igraph\nimport matplotlib\nmatplotlib.use('Agg')\nimport matplotlib.pyplot as plt\nimport scanpy as sc\nimport numpy as np\nimport os\nimport hdf5plugin\n\nsc.settings.figdir = os.path.join(r.niche_dir, \"Plots\")\n#torch.set_float32_matmul_precision('high') \nnovae.settings.auto_preprocessing = True\n#os.environ[\"CUDA_VISIBLE_DEVICES\"] = \"0,1,2\"\n\n\n# Read in sample\nadata = sc.read_h5ad(\"analysis/Robjects/assay_data.h5ad\")\n\n## convert spatial from mm to microns for novae\n\n# Extract coordinates from obs\nx_mm = adata.obs[\"x_slide_mm\"].to_numpy()\ny_mm = adata.obs[\"y_slide_mm\"].to_numpy()\n\n# Create spatial_mm matrix\nspatial_mm = np.column_stack((x_mm, y_mm))\nadata.obsm[\"spatial_mm\"] = spatial_mm\n\n# Convert to microns\nspatial_um = spatial_mm * 1000\nadata.obsm[\"spatial_um\"] = spatial_um\n\n# Duplicate spatial_um to spatial\nadata.obsm[\"spatial\"] = spatial_um\n\n\n## Start running novae\n# Create a Delaunay graph of the data\nnovae.spatial_neighbors(adata, radius=80, coord_type='generic')\n\n# Use a quick plot to ensure that neighbors were calculated appropriately\n# Looking for very few red (unconnected) cells that are only on the edges of tissue\nnovae.plot.connectivities(adata)\n\n# Load in pre-trained model\nmodel1 = novae.Novae.from_pretrained(\"MICS-Lab/novae-human-0\")\n\n# Fine tune model based on CosMx data in this study\n#model1.fine_tune(adata, max_epochs=50, logger=True, accelerator='cuda', num_workers=4)\nmodel1.fine_tune(adata, max_epochs=50, logger=True) # Took ~24 hours on an r5b.12xlarge with CPU only\nmodel1.compute_representations(adata, zero_shot=False) # Took ~8 hrs\n\nfor i in range(1, 20):\n  model1.assign_domains(adata, i)\n\nmodel1_dir = os.path.join(r.niche_dir, \"novae_model_one\")\nmodel1.save_pretrained(save_directory=model1_dir)\n\nimport matplotlib.pyplot as plt\ndh = model1.plot_domains_hierarchy()\nplt.savefig(os.path.join(r.niche_dir, \"Plots\", \"novae_model1_hierarchy.png\"))\nplt.close()\n\nnovae.plot.paga(adata, obs_key=\"novae_domains_11\", save=\"_novae_model1_graph.png\")\n\nadata.write_h5ad(\n  os.path.join(r.objects_dir, \"anndata-plus-novae.h5ad\"),\n  compression=hdf5plugin.FILTERS[\"zstd\"],\n  compression_opts=hdf5plugin.Zstd(clevel=5).filter_options\n)\n\n\")\n\n\n\n\nHere we provide a function, defineROI, to support two workflows for selecting ROIs:\n\nClicking on points in the graphics window to define an ROI boundary (relies on the identify function, which can be buggy.)\nHard-coding the xy coordinates of the ROI boundary.\n\n\n\nCode\n#' Define roi's by Clicking on cells in a graphics window\n#' \n#' How to use:\n#' \\itemize{\n#' \\item Plot your cells in xy space. Use asp = 1. \n#' \\item Click cells around the boundary of your roi.\n#' \\item Hit enter or escape when done with your selection.\n#' }\n#' Other details:\n#' \\itemize{\n#' \\item Uses graphics::identify() to select points. \n#' \\item Only works for base graphics, not ggplots.\n#' \\item Can go wrong (draw rois in the wrong place) if the plot doesn't have asp = 1. \n#' }\n#' @param xy Matrix of xy positions used in the plot. \n#' @param show Logical, for whether to show the selected roi when you're done. \n#' @param type One of:\n#' \\itemize{\n#' \\item \"direct\" to define the boundary points in order, exactly as you click\n#' \\item \"ahull\" to draw an alpha hull around your selection\n#' } \n#' @return A list with 3 elements:\n#' \\itemize{\n#' \\item roi: The indices of the points in the roi\n#' \\item selected: The indices of the user-selected points\n#' \\item hull: The hull of the roi, either the user-selected polygon or the results of alphahull:ahull}\n#' @importFrom graphics identify\n#' @importFrom alphahull ahull\n#' @\ndefineROI &lt;- function(xy, type = \"direct\", boundary_points = NULL, show = TRUE) {\n  if (!is.null(boundary_points)) {\n    hull.x &lt;- boundary_points[, 1]\n    hull.y &lt;- boundary_points[, 2]\n    # get points in the boundary:\n    roi &lt;- sp::point.in.polygon(point.x = xy[, 1], point.y = xy[, 2], \n                                pol.x = hull.x, pol.y = hull.y) &gt; 0\n    inds &lt;- NULL\n    hull &lt;- NULL\n  }\n  if (is.null(boundary_points)) {\n    \n    if (!is.element(type, c(\"direct\", \"ahull\"))) {\n      stop(\"must either give boundary_points or set type to \\'direct\\' or \\'ahull\\'\")\n    }\n    # user identifies boundary:\n    identifyres &lt;- identify(xy, plot = FALSE, order = TRUE)\n    inds &lt;- identifyres$ind[order(identifyres$order)]\n    \n    if (type == \"direct\") {\n      # The hull is just the polygon you've selected:\n      hull.x &lt;- xy[inds, 1]\n      hull.y &lt;- xy[inds, 2]\n      hull &lt;- inds\n      # get points in the boundary:\n      roi &lt;- sp::point.in.polygon(point.x = xy[, 1], point.y = xy[, 2], \n                                  pol.x = hull.x, pol.y = hull.y) &gt; 0\n    }\n    \n    if (type == \"ahull\") {\n      # get alpha hull of boundary:\n      hull &lt;- alphahull::ahull(xy[inds, 1], xy[inds, 2], alpha = 0.05)\n      # get points in the boundary:\n      roi &lt;- alphahull::inahull(ahull.obj = hull, xy)\n    }\n    \n  }\n  # plot:\n  if (show) {\n    points(xy[inds, ], col = \"red\", cex = 0.5, pch = 16)\n    polygon(xy[hull, ])\n    points(xy[roi, ], pch = 16, cex = 1, col = scales::alpha(\"gold\", 0.3))\n  }\n  \n  out = list(roi = roi, selected = inds, hull = hull)\n  return(out)\n}\n\n\nAn example of the click-to-select workflow:\n\n\nCode\n### example usage 1: clicking the graphics window to identify a region \n# NOTE: uses the identify() function, which can be finnicky and hard to debug.\npar(mar = c(0,0,0,0))\nplot(xy, pch = 16, cex = 0.3, asp = 1,\n     xlab = \"\", ylab = \"\")\nroi &lt;- defineROI(xy, type = \"direct\", show = TRUE) \n# add to metadata: \nmetadata$inmyroi &lt;- roi$roi\n\n\n… and of the hard-coded boundary workflow:\n\n\nCode\n### example usage 2: inputing xy coordinates of the ROI's boundary:\npar(mar = c(2,2,0,0))\nplot(xy, pch = 16, cex = 0.3, asp = 1,\n     xlab = \"\", ylab = \"\")\n# place a grid over it to determine where to pick boundary points:\nabline(h = pretty(range(xy[,2]), n=30), v = pretty(range(xy[,1]), n=30), lty=3, col=\"grey20\")\n\n# hard-code boundary points:\nboundary_points &lt;- t(matrix(c(\n    1.85,7.05,\n    2,7.1,\n    2.05,6.95,\n    1.95,6.85,\n    1.87,6.9\n), nrow = 2))\nroi &lt;- defineROI(xy, type = NULL, boundary_points = boundary_points, show = TRUE) \n# add to metadata: \nmetadata$inmyroi &lt;- roi$roi\n\n\n\n\nNo example code is needed here, but here are some examples for inspiration:\n\nCondense niches: in one study, we obtained 9 niches, then condensed them into 3 broad categories (tumor, interior stroma, exterior stroma) for some analyses.\n\nDichotomize a continuous variable: for example, you could pretty accurately identify cells in glomeruli as all cells with &gt;5 native glomerular cells (podocytes/mesangial cells/glomerular endothelial cells…) in their 20 nearest neighbors. And in some tumors, you could pretty accurately define tertiary lymphoid structures as all cells with &gt;10 B/T cells in their 20 nearest neighbors. Or you could divide a tumor into glycolysis high/low zones by dichotomizing a score of cells’ mean neighborhood glycolysis pathway scores.\nCombine metadata columns: for example, combine a handful of custom ROI’s into a single annotation column like “inflamed regions” or “dysplastic regions”.\n\n\n\nOften, instead of just selecting cells belonging to a given cell type, you want cells in anatomical structures. For example, you might want to select tumor glands while omitting single isolated tumor cells, or you might want to define blood vessels as groups of contiguous endothelial cells, omitting isolated endothelial cells. The below code uses the DBSCAN algorithm to achieve this:\n\n\nCode\n# define the starting group of cells, e.g. cells of a given cell type:\ntempcells &lt;- metadata$celltype == \"Endothelial\"\ndbscancluster &lt;- dbscan::dbscan(xy[tempcells, ],\n                     eps = 0.05, # very small radius\n                     minPts = 5  # throw out clusters of less than 5 cells\n                     )$cluster\nselectedcells &lt;- dbscancluster != 0\nmetadata$selected &lt;- FALSE\nmetadata$selected[tempcells][selectedcells] &lt;- TRUE"
  },
  {
    "objectID": "posts/vignette-basic-analysis-updated/03_DE.html#defining-continuous-variables",
    "href": "posts/vignette-basic-analysis-updated/03_DE.html#defining-continuous-variables",
    "title": "Basic analysis vignette: differential expression",
    "section": "2.2 Defining continuous variables",
    "text": "2.2 Defining continuous variables\nHere we provide code for a few ways to define useful continuous variables:\n\nDistance to nearest cell in a set (e.g. nearest T-cell)\nAbundance of a cell set in a cell’s nearest neighbors (e.g. number of T-cell neighbors)\nMean value of a continuous variable in a cell’s neighborhood (e.g. neighborhood CD274 expression, or neighborhood interferon gamma pathway score)\n\n\nDistance to nearest neighborNumber of neighborsMean neighborhood expression\n\n\nThe below code shows how to find the distance to the nearest neighbor of a given set of cells, e.g. tumor cells, or cells in a given niche, or cells in a region of interest (ROI). This approach is appropriate when you expect your selected cells to impact their surroundings in a way that declines over distance, e.g. with oxygen availability dropping with distance to the nearest blood vessel.\nBy modifying the k variable below you can take the distance to the k-th closest cell in the set. This can be useful when you’re trying to get distance to anatomical features like tumor glands rather than just single isolated tumor cells.\n\n\nCode\n# collection of cells we want to take a distance to:\nistargetcell &lt;- metadata$celltype == \"Tcell\"\n# record all cells' distances to k-th nearest target cell\nk &lt;- 1\ndist2target &lt;- FNN::get.knnx(\n  data  = as.matrix(xy[istargetcell, , drop=FALSE]),\n  query = as.matrix(xy),\n  k = k\n)$nn.dist[, k]\n\n\n\n\nThe below code shows how to record how many of each cells’ nearest neighbors belong to a given set of cells, e.g. T-cells or This approach is appropriate when you expect the impact of your selected cells on their neighbors to compound. E.g., a neighborhood with more T cells might have a stronger inflammatory milieu than a neighborhood with just 1 T cell.\n\n\nCode\n# collection of cells we want to take a distance to:\nistargetcell &lt;- metadata$celltype == \"Tcell\"\n\n# count the target cells among cells' neighbors:\nneighboring.targetcells &lt;- InSituCor:::neighbor_sum(x = 1 * (istargetcell),\n                                                    neighbors = neighbors)   # calculated in the preliminaries\n\n\n\n\nThe below code shows how to measure the mean / total expression of a gene in each cells’ neighborhood.\n\n\nCode\n## examples of a variable to average over neighborhoods:\n# raw counts of a gene:\nx &lt;- counts[, \"CXCL14\"] \n# normalized expression of a gene:\nx &lt;- counts[, \"CXCL14\"] / metadata$nCount_RNA\n# or you could use a pathway score, or protein expression (if measured)\n\n## get average expression in each cell's neighborhood:\nneighbormean &lt;- InSituCor:::neighbor_sum(x = x, neighbors = neighbors)"
  },
  {
    "objectID": "posts/vignette-basic-analysis-updated/03_DE.html#transformations-on-continuous-variables",
    "href": "posts/vignette-basic-analysis-updated/03_DE.html#transformations-on-continuous-variables",
    "title": "Basic analysis vignette: differential expression",
    "section": "2.3 Transformations on continuous variables:",
    "text": "2.3 Transformations on continuous variables:\nOnce we’ve derived a continuous variable, we still have decisions to make. When we put a variable in a model, we are implicitly assume a linear relationship between the variable and our gene expression (“gene expression” occurring either on the linear or log scale, depending on the model). It often makes scientific sense to transform a variable before entering it into a model. See the code below for examples of useful transformations.\n\nMonotonic tranformationsBinningSplines\n\n\nIf you think distance to a feature matters because of some diffused signals, then concentration of those molecules will vary with 1/distance. If neighborhood expression of a molecule is strongly right-tailed, which is common, then a log transformation could prevent the end of the tail from having undue influence. To make effect sizes more interpretable, scale the variable from 0-1. For variables with strong skew or long tails, a quantile transformation can prevent extreme values from exerting excess influence on DE results.\n\n\nCode\n# inverse:\nx &lt;- 1 / pmax(x, min(x[x &gt; 0]))\n# log2-transform:\nx &lt;- log2(x + 1e-3)\n# scale from 0-1:\nx &lt;- (x - min(x)) / (max(x) - min(x))\n# scale to have unit SD:\nx &lt;- x / sd(x)\n# quantile transformation:\nx &lt;- order(order(x)) / length(x)\n# truncate at the upper extreme:\nx &lt;- pmin(x, quantile(x, 0.995))\n# truncate at the lower extreme:\nx &lt;- pmax(x, quantile(x, 0.005))\n# truncate at both extremes:\nx &lt;- pmin(pmax(x, quantile(x, 0.005)), quantile(x, 0.995))\n\n\n\n\nIf you’re unwilling to commit to the shape of a relationship between a variable and gene expression, you can take a non-parametric approach and break it into bins. Our favored DE library, smiDE, will then give you results for all pairwise comparisons between bins, and it can be useful to e.g. compare all bins to the first bin. Alteratively, using various base R packages for linear models, you can run both a full model and a “null” model omitting your binned variable, then use a likelihood ratio test (lrtest) to get a p-value for the variable as a whole rather than for individual levels.\n\n\nCode\n# break a variable into bins of equal width:\nx &lt;- cut(x, breaks = 20)\n# break a variable into bins of equal cell numbers:\nquants &lt;- quantile(x, seq(0,1,length.out = 21))\nx &lt;- cut(x, breaks = unique(quants))\n\n\nAfter the above, x is now a factor with 20 levels.\n\n\nInstead of forcing the data into discrete bins, we can use splines to get a smoother fit.\n\n\nCode\nsplinex &lt;- as.matrix(splines::ns(x, df = 20))\n\n\nThis produces a matrix with 20 columns, suitable as use as predictors for DE. Prioritize genes by their global p-values from a likelihood ratio test vs. a model excluding this matrix. (This approach is not yet supported by smiDE.)"
  },
  {
    "objectID": "posts/vignette-basic-analysis-updated/03_DE.html#confirm-your-variable",
    "href": "posts/vignette-basic-analysis-updated/03_DE.html#confirm-your-variable",
    "title": "Basic analysis vignette: differential expression",
    "section": "2.4 Confirm your variable:",
    "text": "2.4 Confirm your variable:\nOnce you’ve crafted a variable, plot it in space to confirm it’s as you hoped:\n\n\nCode\n# plotting a categorical variable:\ncols &lt;- rep(c(\n  \"#E41A1C\", \"#377EB8\", \"#4DAF4A\", \"#984EA3\", \"#FF7F00\",\n  \"#A65628\", \"#F781BF\", \"#999999\", \"#66C2A5\", \"#FC8D62\",\n  \"#8DA0CB\", \"#E78AC3\", \"#A6D854\", \"#FFD92F\", \"#E5C494\",\n  \"#B3B3B3\", \"#1B9E77\", \"#D95F02\", \"#7570B3\", \"#E7298A\",\n  \"#66A61E\", \"#E6AB02\", \"#A6761D\", \"#666666\", \"#A6CEE3\",\n  \"#1F78B4\", \"#B2DF8A\", \"#33A02C\", \"#FB9A99\", \"#E31A1C\",\n  \"#FDBF6F\", \"#FF7F00\", \"#CAB2D6\", \"#6A3D9A\", \"#FFFF99\",\n  \"#B15928\", \"#8DD3C7\", \"#FFFFB3\", \"#BEBADA\", \"#FB8072\"\n), 3)[1:length(unique(x))]\nplot(xy, cex = 0.1, pch = 16, asp = 1,\n     col = cols[as.numeric(as.factor(x))])\n\n# plotting a continuous variable that goes up from 0:\nplot(xy, cex = 0.1, pch = 16, asp = 1,\n     col = colorRampPalette(c(\"grey80\", \"#4B0082\"))(101)[\n       1 + round(100 * x / max(x))\n     ])\n\n# plotting a continuous variable centered at 0:\nplot(xy, cex = 0.1, pch = 16, asp = 1,\n     col = colorRampPalette(c(\"darkblue\", \"grey80\", \"darkred\"))(101)[\n       51 + round(50 * x / max(abs(x)))\n     ])\n\n# plotting a continous variable with arbitrary center:\nplot(xy, cex = 0.1, pch = 16, asp = 1,\n     col = colorRampPalette(c(\"darkblue\", \"grey80\", \"darkred\"))(101)[\n       1 + round(100 * (x - min(x)) / (max(x) - min(x)))\n     ])\n\n# draw a histogram of the continuous variable to confirm it's not excessively long-tailed:\nhist(x, breaks = 40)"
  },
  {
    "objectID": "posts/vignette-basic-analysis-updated/03_DE.html#preliminaries-for-smide",
    "href": "posts/vignette-basic-analysis-updated/03_DE.html#preliminaries-for-smide",
    "title": "Basic analysis vignette: differential expression",
    "section": "3.1 Preliminaries for smiDE",
    "text": "3.1 Preliminaries for smiDE\nTo harden our DE results against bias from segmentation errors, we take two countermeasures before running DE.\nFirst, we identify genes at risk of bias from segmentation errors, and omit them from our analysis. The intuition is simple: if a gene is more highly expressed in the neighbors of a cell type than in the cell type itself, then it’s at risk of meaningful bias from segmentation errors. We formalize this intuition in the function smiDE::overlap_ratio_metric, demonstrated below:\n\n\nCode\n# obtain the overlap ratio metrics:\nif (TRUE) {\n  overlapres &lt;- smiDE::overlap_ratio_metric(\n    assay_matrix = Matrix::t(counts),\n    metadata = cbind(xy, metadata),\n    cellid_col = \"cell_id\",\n    cluster_col = \"celltype\",\n    sdimx_col = colnames(xy)[1],\n    sdimy_col = colnames(xy)[2],\n    radius = 0.05)\n  saveRDS(overlapres, file = \"processed_data/overlapres.RDS\")\n} else {\n  overlapres &lt;- readRDS(\"processed_data/overlapres.RDS\")\n}\n\n# extract the genes to analyze for your cell type (in this example, \"macrophage\"):\ngenes_to_analyze &lt;- overlapres[celltype==\"macrophage\"][ratio &lt; 1][[\"target\"]]\n\n\nSecond, we record cells’ spatial neighbors, which smiDE uses to adjust for any lingering bias from segmentation errors:\n\n\nCode\n# required preliminary for smiDE:\nif (TRUE) {\n  pre_de_obj &lt;- \n  pre_de(metadata = cbind(xy, metadata),\n         cell_type_metadata_colname = \"celltype\",\n         cellid_colname = \"cell_id\",\n         split_neighbors_by_colname = \"tissue\",\n         mm_radius = 0.05,\n         sdimx_colname = colnames(xy)[1],\n         sdimy_colname = colnames(xy)[2],\n         verbose=TRUE)\n  saveRDS(pre_de_obj, file = \"processed_data/pre_de_obj.RDS\")\n} else {\n  pre_de_obj &lt;- readRDS(\"processed_data/pre_de_obj.RDS\")\n}"
  },
  {
    "objectID": "posts/vignette-basic-analysis-updated/03_DE.html#running-smide",
    "href": "posts/vignette-basic-analysis-updated/03_DE.html#running-smide",
    "title": "Basic analysis vignette: differential expression",
    "section": "3.2 running smiDE",
    "text": "3.2 running smiDE\nNow, at last, we’re ready to run DE. Here we’re faced with tradeoffs between model thoroughness and computation time. The best models to date are prohibitively slow in large studies, while the fastest models compute in moments but suffer more false positives.\nWhat do we mean by the “best models?” DE in spatial data runs into two challenges:\nFirst, errors in cell segmentation bias cells to resemble their neighbors. This can cause false positive results when comparing across different spatial contexts. We already screened out genes at unacceptable risk of segmentation errors, but ideally we’ll take the further step of directly adjusting for this bias in the genes that remain.\nSecond, we would ideally model the spatial correlation in our data. Expression among spatially neighboring cells is often correlated due to some spatially smooth factor unrelated to our predictor variable. This can lead to biased effect estimates, and potentially inflated statistical significance. We can model this correlation and get more accurate p-values by including a spatial random effect. This works best when the magnitude of variation in the spatial random effect is small, or when the correlation between the random effect and the covariate is small. In addition, it’s helpful for the DE predictor to be more spatially nuanced than the smooth random effect. Unfortunately, modeling spatial correlation becomes very computationally intensive over large numbers of cells.\nOur recommended modeling approaches for different settings are below:\n\n\n\n\n\n\n\n\n\nApproach\nModel bias from segmentation errors?\nModel spatial correlation?\nSpeed\n\n\n\n\nStandard\nYes\nNo\nmoderate\n\n\nOptimal/slow\nYes\nYes\nvery slow\n\n\nHasty/exploratory\nNo\nNo\nvery fast\n\n\nStepwise: screen with hasty, validate with optimal\nYes\nYes\nmoderate\n\n\n\n\nStandardOptimal/slowHasty/exploratoryStepwise\n\n\n\n\nCode\n## define the problem:\n# which cells to analyze: (a logical vector over all cells)\ninds &lt;- metadata$celltype == \"macrophage\"\ntotalcounts &lt;- metadata$nCount_RNA\nnames(totalcounts) &lt;- metadata$cell_id\n## run smiDE with a Negative Binomial model and no spatial correlation modeling:\nde_obj &lt;- \n   smi_de(assay_matrix = Matrix::t(counts),\n          metadata = metadata[inds, ],\n          formula = ~RankNorm(otherct_expr) + offset(log(nCount_RNA)) + distance_to_tumor,   # &lt;----- first two terms adjust for segmentation errors and per-cell signal strength, final term is the variable to be analyzed, must be a column in metadata\n          pre_de_obj = pre_de_obj,  # depends on pre_de_obj calculated earlier\n          cellid_colname = \"cell_id\",\n          neighbor_expr_cell_type_metadata_colname = \"celltype\",\n          neighbor_expr_overlap_weight_colname = NULL,\n          neighbor_expr_overlap_agg =\"sum\",\n          neighbor_expr_totalcount_normalize = FALSE,    #&lt;--------- @Dan: correct, since I have that offset term above?\n          neighbor_expr_totalcount_scalefactor = NULL,\n          family=\"nbinom2\",\n          targets=genes_to_analyze     # calculated in earlier code block\n   ) \nres &lt;- smiDE::results(de_obj)  # use res$pairwise for most cases. res$one.vs.rest can also be useful. \nstr(res) \n\n\n\n\n\n\nCode\n## define the problem:\n# which cells to analyze: (a logical vector over all cells)\ninds &lt;- metadata$celltype == \"macrophage\"\nmetadata$sdimx &lt;- xy[, 1]\nmetadata$sdimy &lt;- xy[, 2]\ntotalcounts &lt;- metadata$nCount_RNA\nnames(totalcounts) &lt;- metadata$cell_id\n\n# which genes: (this method is SLOW, so don't just test everything)\nselected_genes &lt;- c(\"KRT16\", \"EPCAM\")\n\n## run smiDE with a Negative Binomial model and no spatial correlation modeling:\nde_obj &lt;- \n   smi_de(assay_matrix = Matrix::t(counts),\n          metadata = metadata[inds, ],\n          formula = ~RankNorm(otherct_expr) + offset(log(nCount_RNA)) + distance_to_tumor,   # &lt;----- first two terms adjust for segmentation errors and per-cell signal strength, final term is the variable to be analyzed, must be a column in metadata\n          pre_de_obj = pre_de_obj,  # depends on pre_de_obj calculated earlier\n          cellid_colname = \"cell_id\",\n          neighbor_expr_cell_type_metadata_colname = \"celltype\",\n          neighbor_expr_overlap_weight_colname = NULL,\n          neighbor_expr_overlap_agg =\"sum\",\n          neighbor_expr_totalcount_normalize = TRUE,\n          neighbor_expr_totalcount_scalefactor = totalcounts,\n          family=\"nbinom2\",\n          targets=selected_genes,    \n          spatial_model = list(name=\"GP_INLA\",\n                               x_coord_col = \"sdimx\",  \n                               y_coord_col = \"sdimy\",\n                               quantiles = c(0.025/nrow(targs), 0.025, 0.5, 0.975, 1-0.025/nrow(targs)),\n                               num.threads=1)          \n   ) \nres &lt;- smiDE::results(de_obj)$pairwise    # use res$pairwise for most cases. res$one.vs.rest can also be useful. \nstr(res) \n\n\n\n\n\n\nCode\n## define the problem:\n# which cells to analyze: (a logical vector over all cells)\ninds &lt;- metadata$celltype == \"macrophage\"\n# variable to analyze (defined over all cells):\nx &lt;- distance_to_tumor\n# normalized data:\nnormfactor &lt;- mean(metadata$nCount_RNA) / metadata$nCount_RNA \nnorm &lt;- counts\nnorm@x &lt;- counts@x * normfactor[ counts@i + 1L ]\n## to put genes on similar scales, scale the columns of norm:\ngenefactors &lt;- 1 / pmax(0.05, Matrix::colMeans(norm))  \nnormscaled &lt;- norm %*% Matrix::Diagonal(x = genefactors)\ncolnames(normscaled) &lt;- colnames(norm)\n\n## source the fast DE function:\nsource(\"https://raw.githubusercontent.com/Nanostring-Biostats/CosMx-Analysis-Scratch-Space/refs/heads/Main/_code/PatchDE/DEutils.R\")\n\n## run fast DE:\nfastres &lt;- hastyDE(y = normscaled[, genes_to_analyze], df = data.frame(distance2tumor = x))\n\n## extract estimates and p-values:\nests &lt;- fastres$effect\nps &lt;- fastres$p\n\n\n\n\nWhen it’s vital to adjust for spatial correlation, but our dataset’s size makes that impractical, we can run a very efficient but spatially blind model to prioritize the most useful genes, then validate them with a proper spatial correlation model in smiDE.\nAn important caveat: because we’ve selected the genes for the smiDE run based on their evidence in the spatial-free DE model, calculating proper adjusted p-values becomes very complicated - we can neither ignore the omitted genes, nor can we use their (presumably over-optimistic) spatial-free p-values.\nAs a solution, we propose the following procedure, which will produce conservative adjusted p-values:\n\nKeep the smiDE p-values from the screened genes.\nFor the remaining genes, throw out the “hasty” p-values, and generate p-values from the null distribution, i.e. uniformly between 0-1.\nRun your preferred p-value adjustment method on the resulting vector of p-values.\n\n\n\nCode\n## define the problem:\n# which cells to analyze: (a logical vector over all cells)\ninds &lt;- metadata$celltype == \"macrophage\"\n# variable to analyze (defined over all cells):\nx &lt;- distance_to_tumor\n# normalized data:\nnormfactor &lt;- mean(metadata$nCount_RNA) / metadata$nCount_RNA \nnorm &lt;- counts\nnorm@x &lt;- counts@x * normfactor[ counts@i + 1L ]\n# to put genes on similar scales, scale the columns of norm:\ngenefactors &lt;- 1 / pmax(0.05, Matrix::colMeans(norm))  \nnormscaled &lt;- norm %*% Matrix::Diagonal(x = genefactors)\ncolnames(normscaled) &lt;- colnames(norm)\n\n## source the fast DE function:\nsource(\"https://raw.githubusercontent.com/Nanostring-Biostats/CosMx-Analysis-Scratch-Space/refs/heads/Main/_code/PatchDE/DEutils.R\")\n\n## run fast DE:\nfastres &lt;- hastyDE(y = normscaled[, genes_to_analyze], df = data.frame(distance2tumor = x))\n\n# Extract top genes:\n# This example takes the top 10 genes by effect size from the top 1% of p-values.\n# We recommend extracting top genes with some human oversight. \ntopgenes &lt;- names(fastres$p)[order(abs(fastres$effect) * (fastres$p &lt;= quantile(fastres$p, 0.01)), 1:5)]  \n\n# Run smiDE on the top genes with the optimal / spatial-aware call to smiDE:\n## define the problem:\nmetadata$sdimx &lt;- xy[, 1]\nmetadata$sdim2 &lt;- xy[, 2]\ntotalcounts &lt;- metadata$nCount_RNA\nnames(totalcounts) &lt;- metadata$cell_id\n\n## run smiDE with a Negative Binomial model and with spatial correlation modeling:\nde_obj &lt;- \n   smi_de(assay_matrix = Matrix::t(counts),\n          metadata = metadata[inds, ],\n          formula = ~RankNorm(otherct_expr) + offset(log(nCount_RNA)) + distance_to_tumor,   # &lt;----- first two terms adjust for segmentation errors and per-cell signal strength, final term is the variable to be analyzed, must be a column in metadata\n          pre_de_obj = pre_de_obj,  # depends on pre_de_obj calculated earlier\n          cellid_colname = \"cell_id\",\n          neighbor_expr_cell_type_metadata_colname = \"celltype\",\n          neighbor_expr_overlap_weight_colname = NULL,\n          neighbor_expr_overlap_agg =\"sum\",\n          neighbor_expr_totalcount_normalize = TRUE,\n          neighbor_expr_totalcount_scalefactor = totalcounts,\n          family=\"nbinom2\",\n          targets=topgenes,     # only analyze the genes of greatest interest\n          spatial_model = list(name=\"GP_INLA\",\n                               x_coord_col = \"sdimx\",  \n                               y_coord_col = \"sdimy\",\n                               quantiles = c(0.025/nrow(targs), 0.025, 0.5, 0.975, 1-0.025/nrow(targs)),\n                               num.threads=1)          \n   ) \nres &lt;- results(de_obj)$pairwise   \n\n# get conservative adjusted p-values for the top genes, replacing hasty p-values with the null distribution:\nps.spatial &lt;- res$pairwise$p.value[grepl(\"distance_to_tumor\", res$pairwise$contrast)]\nnames(ps.spatial) &lt;- res$pairwise$target[grepl(\"distance_to_tumor\", res$pairwise$contrast)]\nps.null &lt;- seq(0, 1, length.out = length(genes_to_analyze) - length(topgenes))\n\nps.spatial.adjusted &lt;- p.adjust(c(ps.spatial, ps.null), method = \"BH\")[1:length(ps.spatial)]"
  },
  {
    "objectID": "posts/vignette-basic-analysis-updated/03_DE.html#prioritizing-genes",
    "href": "posts/vignette-basic-analysis-updated/03_DE.html#prioritizing-genes",
    "title": "Basic analysis vignette: differential expression",
    "section": "4.1 Prioritizing genes",
    "text": "4.1 Prioritizing genes\nHow you prioritize genes depends on your setting. There are two basic cases:\nHigh power settings: when your model has high N (e.g. &gt;10000 cells) and no adjusting for spatial correlation, it’s common to get very tiny p-values, e.g. &lt; 10^-50. In these cases, apply a reasonable p-value cutoff, say the top 20% of genes, then rank genes by effect size.\nLow power settings: when p-values aren’t infinitesimal, rank genes as you would in other DE settings, i.e. considering both p-value and effect size."
  },
  {
    "objectID": "posts/vignette-basic-analysis-updated/03_DE.html#exploring-results",
    "href": "posts/vignette-basic-analysis-updated/03_DE.html#exploring-results",
    "title": "Basic analysis vignette: differential expression",
    "section": "4.2 Exploring results",
    "text": "4.2 Exploring results\nThe usual DE tools, like volcano plots and GSEA, apply directly to spatial data, and your existing workflows should work without modification. A few additional techniques bear mention. Since these explorations are highly custom, we leave it to you to code these final plots however you like.\nFor continuous variables like distance to a cell type or local abundance of a cell type, it can be helpful to show mean expression across bins of the variable. E.g. in the below image, we show selected genes’ mean expression in tumor cells at different distances from blood vessels. This lets us see in more nuance how genes change over space, and it lets us cluster together genes with similar spatial patterns.\n\n\n\n\n\n\n\n\n\nSecond, unlike in single cell data, we can easily verify our results by plotting a gene’s expression in our given cell type over space. We favor plots that both show the “exposure” you’re studying and color the cells we’re studying by gene expression. E.g., in the below image, we were studying how tumor cells respond to proximity to blood vessels. Most cells are in a mute grey. Then we brightly color the exposure (blood vessels) blue, and use a yellow-red color scale to show a target gene’s expression in tumor cells.\n\n\n\n\n\n\n\n\n\nFinally, we can plot a single gene’s mean expression across values of a continuous variable. E.g., below we plot VEGFA expression vs. distance from vessels, with lines showing trends in 4 different cell types:\n\n\n\n\n\n\n\n\n\nFor categorical variables, we can use polygons over space to denote predictor category, while using color to show expression:\n\n\n\n\n\n\n\n\n\nAnd we can use standard bar plots (or better, bar-and-whisker plots), or violin plots, to summarize expression across categories:\n\n\n\n\n\n\n\n\n\nOr we can use a heatmap to show the mean expression per category of many genes at once:"
  },
  {
    "objectID": "posts/vignette-basic-analysis-updated/02_exploratory_analysis.html",
    "href": "posts/vignette-basic-analysis-updated/02_exploratory_analysis.html",
    "title": "Basic analysis vignette: exploratory analysis",
    "section": "",
    "text": "Here we provide workflows for exploratory analysis. Also see the companion posts on pre-processing and confirmatory analysis with differential expression testing. A complete analysis will typically begin with the pre-processing workflow, use exploratory analyses to generate hypotheses, then conclude by using differential expression analysis to test those hypotheses.\nCosMx datasets, with thousands of genes and hundreds of thousands of cells, contain an incomprehensible richness of biological trends. Even when you have a primary hypothesis in mind, it’s worth seeing what unexpected findings your data holds. To this end, various exploratory analysis tools exist to help you answer the basic question, “what in this dataset might be worth paying attention to?”\nA great many tools exist for exploring spatial data, and we do not attempt to catalog them here. Instead, we’ll share a few techniques we’ve found useful. The four tools we discuss are:\n\n\n\nApproach\nInputs\nOutputs\n\n\n\n\nScore pathway activity with AUCell\nraw counts\npathway scores\n\n\nLook for spatially variable genes (or pathways)\nnormalized counts, xy, cell type\nper-gene Moran’s I stats\n\n\nLook for spatially correlated genes using InSituCor\nnormalized counts, xy, cell type\nmodules of spatially correlated genes\n\n\nLook for perturbations from baseline using InSituDiff\nnormalized counts, xy\ndiverse outputs\n\n\n\n\n\nTo begin, load your fully pre-processed data (including cell type annotations). We assume the format generated by the preprocessing vignette:\n\na sparse counts matrix with cells in rows and genes in columns\na data table of per-cell metadata, row-aligned with the counts matrix\na matrix of cells’ xy positions, row-aligned with the counts matrix\n\n\n\nCode\n## load necessary libraries\nlibrary(data.table) # for more memory efficient data frames\nlibrary(Matrix) # for sparse matrices like our counts matrix\nlibrary(InSituCor) # devtools::install_github(\"https://github.com/Nanostring-Biostats/InSituCor\")\nlibrary(InSituDiff) # remotes::install_github(\"Nanostring-Biostats/CosMx-Analysis-Scratch-Space\", subdir = \"_code/InSituDiff\", ref = \"Main\")\nlibrary(AUCell) # BiocManager::install(\"AUCell\")\nlibrary(msigdbr) # BiocManager::install(\"msigdbr\")\n\n## load data:\ncounts &lt;- readRDS(paste0(outdir, \"/processed_data/counts.RDS\"))\nmetadata &lt;- readRDS(paste0(outdir, \"/processed_data/metadata.RDS\")) # expected to have the column \"celltype\"\nxy &lt;- readRDS(paste0(outdir, \"/processed_data/xy.RDS\"))\n\n## normalize counts matrix using efficient sparse matrix calls:\nscale_row &lt;- mean(metadata$nCount_RNA) / metadata$nCount_RNA\nnorm &lt;- counts\nnorm@x &lt;- norm@x * scale_row[norm@i + 1L]"
  },
  {
    "objectID": "posts/vignette-basic-analysis-updated/02_exploratory_analysis.html#getting-started",
    "href": "posts/vignette-basic-analysis-updated/02_exploratory_analysis.html#getting-started",
    "title": "Basic analysis vignette: exploratory analysis",
    "section": "",
    "text": "To begin, load your fully pre-processed data (including cell type annotations). We assume the format generated by the preprocessing vignette:\n\na sparse counts matrix with cells in rows and genes in columns\na data table of per-cell metadata, row-aligned with the counts matrix\na matrix of cells’ xy positions, row-aligned with the counts matrix\n\n\n\nCode\n## load necessary libraries\nlibrary(data.table) # for more memory efficient data frames\nlibrary(Matrix) # for sparse matrices like our counts matrix\nlibrary(InSituCor) # devtools::install_github(\"https://github.com/Nanostring-Biostats/InSituCor\")\nlibrary(InSituDiff) # remotes::install_github(\"Nanostring-Biostats/CosMx-Analysis-Scratch-Space\", subdir = \"_code/InSituDiff\", ref = \"Main\")\nlibrary(AUCell) # BiocManager::install(\"AUCell\")\nlibrary(msigdbr) # BiocManager::install(\"msigdbr\")\n\n## load data:\ncounts &lt;- readRDS(paste0(outdir, \"/processed_data/counts.RDS\"))\nmetadata &lt;- readRDS(paste0(outdir, \"/processed_data/metadata.RDS\")) # expected to have the column \"celltype\"\nxy &lt;- readRDS(paste0(outdir, \"/processed_data/xy.RDS\"))\n\n## normalize counts matrix using efficient sparse matrix calls:\nscale_row &lt;- mean(metadata$nCount_RNA) / metadata$nCount_RNA\nnorm &lt;- counts\nnorm@x &lt;- norm@x * scale_row[norm@i + 1L]"
  },
  {
    "objectID": "posts/vignette-basic-analysis-updated/02_exploratory_analysis.html#morans-by-cell-type",
    "href": "posts/vignette-basic-analysis-updated/02_exploratory_analysis.html#morans-by-cell-type",
    "title": "Basic analysis vignette: exploratory analysis",
    "section": "3.1 Moran’s by cell type",
    "text": "3.1 Moran’s by cell type\nMoran’s I and similar approaches have one disappointing feature: they often just highlight cell type marker genes. We don’t need to look for spatial variability to learn that a cell type has spatial patterns; we can just look at the cell type’s spatial distribution. One way to avoid wasting time on trivial discoveries like marker genes is to calculate Moran’s I within a cell type of interest. The top genes from such an analysis will suggest ways the cell type is changing over space.\n\n\nCode\n## calculate Moran's within a cell type:\n# select just the cell type's cells:\ninds &lt;- celltype == \"macrophage\"\n# Get the neighbor relationships within just the cell type:\n# (Here we'll use a radius-based approach to account for the fact that cells from a given cell type may fall quite far from their nearest neighbors from the same cell type.)\ntempneighbors &lt;- InSituCor:::radiusBasedGraph(xy[inds, 1], xy[inds, 2], R = 0.25, subset = metadata$slide_ID)  \n# check there's a reasonable number of neighbors per cell:\nhist(Matrix::rowSums(tempneighbors &gt; 0))\n\n# compute moran's:\nmorans_mycelltype &lt;- moransMultiFast(X = norm[inds, ], W = neighbors[inds, inds], perm = 10, compute_sparse = TRUE, compute_perm = FALSE)\n\n# plot moran's vs. mean expression\nmeanexpr_mycelltype &lt;- Matrix::colMeans(counts[inds, ])\nplot(log2(1e-2 + meanexpr_mycelltype), \n     morans_mycelltype$I[match(names(meanexpr_mycelltype), morans_mycelltype$gene)], col = 0, \n     xlab = \"Log2 mean counts\", ylab = \"Moran's I\")\ntext(log2(1e-2 + meanexpr_mycelltype), \n     morans_mycelltype$I[match(names(meanexpr_mycelltype), morans_mycelltype$gene)], \n     names(meanexpr_mycelltype), cex = 0.5)"
  },
  {
    "objectID": "posts/multiomics-alignment/index.html",
    "href": "posts/multiomics-alignment/index.html",
    "title": "Aligning CosMx® Same-Cell Multiomics Data",
    "section": "",
    "text": "CosMx® SMI allows users to acquire protein and RNA data from the same tissue as consecutive experiments. These data are acquired as independent runs and therefore need to be aligned, post-acquisition, to combine them into a multiomic study. This alignment process brings the decoded RNA transcripts into the coordinate system of protein data. To accomplish this, we have developed a standalone alignment tool that can be used to align CosMx data exported from AtoMx® SIP. The tool has a 2-step workflow represented in Figure 1:\nStep 1: Align the RNA morphology fields of view (FOVs) to protein references.\nStep 2: Assign the RNA transcripts to the protein cell segmentation labels.\n\n\n\n\n\n\n\n\nFigure 1: Multiomics alignment workflow\n\n\n\n\n\n\nLike other items in our CosMx Analysis Scratch Space, the multiomics alignment tool presented here is experimental so the usual caveats and license applies."
  },
  {
    "objectID": "posts/multiomics-alignment/index.html#step-1-calculate-2d-shift",
    "href": "posts/multiomics-alignment/index.html#step-1-calculate-2d-shift",
    "title": "Aligning CosMx® Same-Cell Multiomics Data",
    "section": "3.1 Step 1: Calculate 2D Shift",
    "text": "3.1 Step 1: Calculate 2D Shift\nTo launch image alignment, select the Morphology2D folders for both the protein and RNA runs and click Perform Alignment. The standard search area used for the alignment is by default 500 pixels or roughly 60 microns. This range is large enough to account for shifts introduced by slide replacement. This search area is editable and can be increased to 750 if the user suspects a larger shift (though adjustment is typically not needed – the software makes an assessment of search range need prior to alignment).\nDuring alignment a new folder called AlignmentQC is created within the RNA data folder structure and is populated with the outputs from the alignment. Occasionally, certain FOVs may be discarded from the multiomic analysis if they fail alignment. This can happen in cases of tissue peeling or significant cell loss. These FOVs, identified as outliers, are recorded in the Alignment_Stats_Curated.csv file and are excluded from the transcript re-assignment process. Refer to Table 1 for a list of AlignmentQC folder outputs and descriptions of the individual files.\n\n\n\nTable 1: Folder outputs and descriptions\n\n\n\n\n\n\n\n\n\nAlignmentQC Folder Outputs\nDescription of individual files\n\n\n\n\nAlignment_Stats.csv\nList of the paired Protein and RNA FOVs along with the computed XY shift (in pixels) between them.\n\n\nFOV_mask.TIF\nBinary Map of the FOV Locations.\n\n\nFOV_Cluster.TIF\nVisualization of FOV Clusters.\n\n\nDisplacement_Vectors.png\nVisualization of the FOV displacement with marker outliers.\n\n\nAlignment_Stats_Curated.csv\nUpdated Stats file with associated cluster label and outlier flag.\n\n\nStats_Report.txt\nReports the percentage of FOVs that were successfully aligned, along with a list of FOVs that failed alignment and were excluded from target re-assignment."
  },
  {
    "objectID": "posts/multiomics-alignment/index.html#step-2-shift-and-assign-transcripts",
    "href": "posts/multiomics-alignment/index.html#step-2-shift-and-assign-transcripts",
    "title": "Aligning CosMx® Same-Cell Multiomics Data",
    "section": "3.2 Step 2: Shift and Assign Transcripts",
    "text": "3.2 Step 2: Shift and Assign Transcripts\nOnce the alignment process has been completed for all the FOVs, the path of the final alignment will appear in the GUI Alignment box (Figure 5 ). The user can review the computed alignment to verify accuracy of the results.\n\n\n\n\n\n\n\n\nFigure 5: Alignment tool generates XY registration between the protein and RNA images\n\n\n\n\n\nOnce the image registration is complete, the next step is to apply the computed shifts to transcripts and re-assign them to protein segmentation labels. For this step, select the Protein CellStatsDir and the location of the RNA transcripts folder (Figure 6 ). If the original folder structure of export is maintained, these folders will be automatically populated when the RNA and protein morphology folders are selected. Once the inputs have been chosen, click Assign transcripts as shown in Figure 6 (a).\n\n\n\n\n\n\n\n\nFigure 6: (a) Alignment tool shifts and re-assigns RNA transcripts to protein segmentation labels. (b) Final output fo the alignment.\n\n\n\n\n\nFor every FOV, the assignment process takes as input the calculated shift and applies it to the transcript locations and then updates the cell id based on the associated protein cell label data. Once the re-assignment is complete, the final output is a folder with the updated transcripts data as shown in Figure 6 (b)."
  },
  {
    "objectID": "posts/napari-protein-stitching/napari-cosmx-protein-stitching.html",
    "href": "posts/napari-protein-stitching/napari-cosmx-protein-stitching.html",
    "title": "Programmatic stitching of protein images with napari-cosmx",
    "section": "",
    "text": "Figure 1: A small section of CosMx SMI data showing DNA (blue), PanCK (green) and the CD3 protein (yellow).\n\n\n\n\n\nThe napari-cosmx plugin can be used to view CosMx® Spatial Molecular Imager (SMI) RNA and protein data. In a previous post, I showed users how to programmatically stitch RNA exports from AtoMx® Spatial Informatics Platform (SIP). The process used to stitch protein is similar to RNA with some adjustments that are found below.\nThis tutorial uses version 0.4.17.3 of the napari-cosmx plugin. This version is available as a whl file in the assets folder of the Scratch Space repository. The tutorial below also builds upon the RNA-based post that more broadly covers how to create the napari environment, installing the plugin, and running scripts.\nWhen napari-cosmx is installed, we get a few package scripts that can be called directly. The ones needed to stitch protein are:\n\nstitch-images, which builds the IF zarr stores\nstitch-expression, which creates the zarr stores for each protein\n\n\n1 Exporting protein data\nWhen exporting data from AtoMx SIP, be sure to select “Raw Files” and include Morphology2D, Miscellaneous, and ProteinDir (Figure 2).\n\n\n\n\n\n\n\n\nFigure 2: Export these components to stitch protein.\n\n\n\n\n\n\n\n2 Stitching immunofluorescence images\nThis step is identical for RNA and protein.\nstitch-images --help\nusage: stitch-images [-h] [-i INPUTDIR] [--imagesdir IMAGESDIR] [-o OUTPUTDIR] [-f OFFSETSDIR] [-l] [-u UMPERPX] [-z ZSLICE] [--dotzarr]\n\nTile CellLabels and morphology TIFFs.\n\noptional arguments:\n  -h, --help            show this help message and exit\n  -i INPUTDIR, --inputdir INPUTDIR\n                        Required: Path to CellLabels and morphology images.\n  --imagesdir IMAGESDIR\n                        Optional: Path to morphology images, if different than inputdir.\n  -o OUTPUTDIR, --outputdir OUTPUTDIR\n                        Required: Where to create zarr output.\n  -f OFFSETSDIR, --offsetsdir OFFSETSDIR\n                        Required: Path to directory location containing a file ending in FOV_Locations.csv or legacy format latest.fovs.csv.\n  -l, --labels          \n                        Optional: Only stitch labels.\n  -u UMPERPX, --umperpx UMPERPX\n                        Optional: Override image scale in um per pixel.\n                        Instrument-specific values to use:\n                        -&gt; beta04 = 0.1228\n  -z ZSLICE, --zslice ZSLICE\n                        Optional: Z slice to stitch.\n  --dotzarr             \n                        Optional: Add .zarr extension on multiscale pyramids.\nExample:\nstitch-images -i path/to/CellStatsDir -o path/to/napari_zarr -f /path/to/RunSummary\n\n\n3 Stitch Protein Images\nRNA uses read-targets to create a file that stores the spatial location of RNA transcripts. In contrast, Protein SMI data are more similar to IF TIFF files and so we use the stitch-expression package script to stitch together individual protein files. When complete, protein data will be found in the images/protein subfolder.\nstitch-expression --help\nusage: stitch-expression [-h] [-i INPUTDIR] [-o OUTPUTDIR] [-t TAG] [-u UMPERPX] [-s SCALE] [-c CYCLE] [--dotzarr]\n\nTile protein expression images\n\noptional arguments:\n  -h, --help            show this help message and exit\n  -i INPUTDIR, --inputdir INPUTDIR\n                        Required: Path to parent directory containing CellStatsDir, RunSummary, AnalysisResults, and ProteinDir.\n  -o OUTPUTDIR, --outputdir OUTPUTDIR\n                        Required: Where to create zarr output.\n  -t TAG, --tag TAG     \n                        Optional: Tag to append to end of protein names.\n  -u UMPERPX, --umperpx UMPERPX\n                        Optional: Override image scale in um per pixel.\n                        Instrument-specific values to use:\n                        -&gt; beta04 = 0.1228\n  -s SCALE, --scale SCALE\n                        Optional: Scale of expression images relative to raw,\n                          use if decoded images are binned.\n  -c CYCLE, --cycle CYCLE\n                        Optional: Cycle to use, default is 1.\n  --dotzarr             \n                        Optional: Add .zarr extension on multiscale pyramids.\nExample:\nstitch-expression -i path/to/parent/slide_folder -o path/to/napari_zarr"
  },
  {
    "objectID": "posts/immune-cell-typing-smooth/index.html",
    "href": "posts/immune-cell-typing-smooth/index.html",
    "title": "Using marker gene driven metagene scores for granular hierarchical cell typing.",
    "section": "",
    "text": "This post showcases a hierarchical cell typing method (HieraType) optimized for detection and sub-clustering of immune cells. HieraType:\n\nIs organized around canonical marker genes, but harnesses cells’ complete expression profiles.\nCan be adapted to any arbitrary cell type hierarchy.\n\nCode for the method and utility functions used in this post can be found in the R package HieraType. The package contains carefully designed pipelines for:\n\nSubclassifying T-cells into 12 categories\nClassifying a whole dataset into broad categories (epithelial, fibroblast, immune, endothelial), then subclassifying immune cells into 9 categories\nClassifying native brain cells\n\nIt is also possible to assemble pipelines for custom applications, e.g. focused on a specific tissue type.\nIn this post, we use a 6K-plex colon-cancer dataset to demonstrate two common use cases for the method:\n\nSubtyping T cells\nBroad immune cell typing."
  },
  {
    "objectID": "posts/immune-cell-typing-smooth/index.html#tldr",
    "href": "posts/immune-cell-typing-smooth/index.html#tldr",
    "title": "Using marker gene driven metagene scores for granular hierarchical cell typing.",
    "section": "5.1 ‘Just The Code’",
    "text": "5.1 ‘Just The Code’\nHere’s the code for classifying leiden cluster ‘6’ into cd8t and cd4t cell types , followed by more granular T cell subtyping. We use the R package HieraType with a prespecified tcell_pipeline, and corresponding lists of marker genes included as package datasets. A pipeline specifies the hierarchical order we want to do our cell typing, and which cell types go in each level of the hierarchy. Each cell type has a list of associated marker genes.\n\ndata(\"pipeline_tcell\")\n\n\nstr(pipeline_tcell, max.level = 2)\n\nList of 3\n $ markerslists   :List of 3\n  ..$ tmajor :List of 2\n  .. ..- attr(*, \"class\")= chr [1:2] \"list\" \"markerslist\"\n  ..$ t4minor:List of 7\n  .. ..- attr(*, \"class\")= chr [1:2] \"list\" \"markerslist\"\n  ..$ t8minor:List of 5\n  .. ..- attr(*, \"class\")= chr [1:2] \"list\" \"markerslist\"\n $ priors         :List of 2\n  ..$ t4minor: chr \"tmajor\"\n  ..$ t8minor: chr \"tmajor\"\n $ priors_category:List of 2\n  ..$ t4minor: chr \"cd4t\"\n  ..$ t8minor: chr \"cd8t\"\n - attr(*, \"class\")= chr [1:2] \"list\" \"pipeline\"\n\nnames(pipeline_tcell$markerslists$tmajor)\n\n[1] \"cd8t\" \"cd4t\"\n\nnames(pipeline_tcell$markerslists$t4minor)\n\n[1] \"cd4_naive\" \"cd4_tem\"   \"cd4_tcm\"   \"cd4_th1\"   \"cd4_th2\"   \"cd4_th17\" \n[7] \"cd4_treg\" \n\nnames(pipeline_tcell$markerslists$t8minor)\n\n[1] \"cd8_naive\"     \"cd8_tem\"       \"cd8_tcm\"       \"cd8_cytotoxic\"\n[5] \"cd8_exhausted\"\n\n\n\n### these are cells I want to subcluster\ntcell_ids &lt;- sem@meta.data[sem@meta.data$clusters_unsup==6,\"cell_ID\"]\n\n### Run a 'tcell'-typing pipeline, which \n### first classifies into T8/T4 categories (using the `tmajor` markerslist), \n### then runs subclassification for T4 and T8 using the t4minor and t8minor markerslists.\ntcell_typing &lt;- \nrun_pipeline(pipeline = pipeline_tcell\n             ,counts_matrix = Matrix::t(sem[[\"RNA\"]]@counts[,tcell_ids])\n             ,adjacency_matrix = as(sem@graphs$umapgrph\n                                    ,\"CsparseMatrix\")[tcell_ids,tcell_ids]\n             ,celltype_call_threshold = 0.5\n             )\n\nThe data table post_probs in our tcell_typing object holds the high-level cell typing results; the celltype_thresh column shows the most granular cell type call where posterior probability is \\(&gt; 0.5\\) (our celltype_call_threshold). We can see the posterior probablity for the celltype_thresh category in best_score_thresh.\nThe best granular cell type call (regardless of score) is given by the celltype_granular column, with best_score_granular indicating the corresponding posterior probability.\n\nstr(tcell_typing, max.level = 2)\n\nList of 3\n $ post_probs     :List of 1\n  ..$ tmajor:Classes 'data.table' and 'data.frame': 7356 obs. of  5 variables:\n  .. ..- attr(*, \".internal.selfref\")=&lt;externalptr&gt; \n  .. ..- attr(*, \"sorted\")= chr \"cell_ID\"\n $ models         :List of 3\n  ..$ tmajor :List of 3\n  ..$ t4minor:List of 3\n  ..$ t8minor:List of 3\n $ metagene_scores:List of 3\n  ..$ tmajor :List of 2\n  ..$ t4minor:List of 7\n  ..$ t8minor:List of 5\n\ntcell_typing$post_probs$tmajor[1:10][]\n\nKey: &lt;cell_ID&gt;\n        cell_ID celltype_thresh celltype_granular best_score_granular\n         &lt;char&gt;          &lt;char&gt;            &lt;char&gt;               &lt;num&gt;\n 1: c_1_12_1014            cd8t     cd8_exhausted           0.4691963\n 2: c_1_12_1066            cd4t           cd4_th1           0.3352265\n 3: c_1_12_1091         cd4_th2           cd4_th2           0.9683195\n 4: c_1_12_1175   cd8_cytotoxic     cd8_cytotoxic           0.8777777\n 5: c_1_12_1270         cd8_tem           cd8_tem           0.5882417\n 6: c_1_12_1286        cd4_treg          cd4_treg           0.9909980\n 7: c_1_12_1325            cd4t           cd4_tcm           0.4647576\n 8: c_1_12_1346        cd4_treg          cd4_treg           0.8298557\n 9: c_1_12_1349            cd8t           cd8_tem           0.3939835\n10: c_1_12_1394   cd8_cytotoxic     cd8_cytotoxic           0.9587283\n    best_score_thresh\n                &lt;num&gt;\n 1:         0.9999999\n 2:         0.6751557\n 3:         0.9683195\n 4:         0.8777777\n 5:         0.5882417\n 6:         0.9909980\n 7:         0.9984388\n 8:         0.8298557\n 9:         0.9999814\n10:         0.9587283\n\n\nNow lets take a closer look at the details and describe the methodology for each step."
  },
  {
    "objectID": "posts/immune-cell-typing-smooth/index.html#detailed-walkthrough",
    "href": "posts/immune-cell-typing-smooth/index.html#detailed-walkthrough",
    "title": "Using marker gene driven metagene scores for granular hierarchical cell typing.",
    "section": "5.2 Detailed walkthrough",
    "text": "5.2 Detailed walkthrough\n\n5.2.1 Part 1: Specifying genes associated with my cell types based on prior biology\nWe’ll describe the first level of cell type classification from our example above to illustrate the method, where we suppose we want to classify cd4t vs. cd8t. Creating a marker list, by specifying genes I expect might be associated with my cell types is the first step of this algorithm. For each of my cell types, cd4t and cd8t, I specify\n\na set of primary defining markers or “index genes” (these are genes that should be fairly exclusive to the cell type if possible)\na set of other marker genes which I expect could be expressed as “predictors”\n\nIn this case, we’ll use [CD4], and [CD8A, CD8B], as “index genes” for cd4t and cd8t respectively. The other genes we’ll specify as predictors are based on the literature. For example, FOXP3 is often associated with cd4t ‘Treg’ cells, so we include it as a predictor here for cd4t. In general, it’s okay to include a gene as a “predictor” even if we only expect to see it in a subset of cells (like FOXP3 in this example, which we expect to be present in a ‘Treg’ subtype, but not all cd4t cells).\nIt’s okay to include markers in multiple cell types if that fits our mental model. For example, CD3D, CD3E, and CD3G are general T cell markers, and so are included as predictors for both subtypes, as are other genes like IL7R, CD27, SELL which could be seen in either cd4t or cd8t cells. When manually creating a marker list, consider “more predictors is better” as a general rule of thumb; a larger number of predictor genes can help build more accurate metagene models for celltype index markers.\nWe can create our marker list manually like this:\n\nmarkerslist_tcellmajor &lt;- \nHieraType::make_markerslist(\n  index_marker = list(\n    \"cd8t\" = c(\"CD8B\", \"CD8A\")\n    ,\"cd4t\" = c(\"CD4\")\n  )\n  ,predictors = list(\n    \"cd8t\" =  c(\"CD3D\", \"CD3E\", \"CD3G\", \"CD8A\", \"CD8B\", \"IL7R\", \"CD27\", \"SELL\", \"CCR7\", \"TCF7\", \"LEF1\", \n                    \"FOXP1\", \"BACH2\", \"KLF2\", \"CD28\", \"ICOS\", \"STAT3\", \"STAT5\", \"RUNX3\", \"BATF\", \"EOMES\", \n                    \"TBX21\", \"PRDM1\", \"PDCD1\", \"LAG3\", \"TIGIT\", \"HAVCR2\", \"GZMK\", \"GZMA\", \"GZMB\", \"PRF1\", \n                    \"GNLY\", \"KLRG1\", \"KLRD1\", \"IFNG\", \"CCL5\", \"CX3CR1\", \"NKG7\", \"FAS\", \"FASLG\", \"IL2\", \"CD244\", \n                    \"CXCR3\", \"KLRB1\", \"TOX\", \"NR4A2\", \"BCL6\", \"CXCL13\")\n    ,\"cd4t\" = c(\"CD3D\", \"CD3E\", \"CD3G\", \"CD4\", \"IL7R\", \"CD27\", \"SELL\", \"CCR7\", \"TCF7\", \"LEF1\", \"FOXP1\", \n                     \"BACH2\", \"KLF2\", \"CD28\", \"ICOS\", \"CD40LG\", \"STAT3\", \"STAT5\", \"RUNX1\", \"RUNX3\", \"BATF\", \n                     \"GATA3\", \"TBX21\", \"RORC\", \"FOXP3\", \"IL2RA\", \"CTLA4\", \"PDCD1\", \"LAG3\", \"TIGIT\", \"HAVCR2\", \n                     \"IL2\", \"IFNG\", \"IL4\", \"IL5\", \"IL13\", \"IL17A\", \"IL17F\", \"IL10\", \"CCL5\", \"CXCR3\", \"CCR6\", \n                     \"CXCR5\", \"PRDM1\", \"BCL6\", \"EOMES\", \"CXCL13\", \"TOX\")\n  )\n)\n\nThe object created looks like this below\n\nstr(markerslist_tcellmajor)\n\nList of 2\n $ cd8t:List of 3\n  ..$ index_marker                               : chr [1:2] \"CD8B\" \"CD8A\"\n  ..$ predictors                                 : chr [1:48] \"CD3D\" \"CD3E\" \"CD3G\" \"CD8A\" ...\n  ..$ use_offclass_markers_as_negative_predictors: logi TRUE\n $ cd4t:List of 3\n  ..$ index_marker                               : chr \"CD4\"\n  ..$ predictors                                 : chr [1:48] \"CD3D\" \"CD3E\" \"CD3G\" \"CD4\" ...\n  ..$ use_offclass_markers_as_negative_predictors: logi TRUE\n - attr(*, \"class\")= chr [1:2] \"list\" \"markerslist\"\n\n\nIn practice, we can save and reuse our marker lists for different cell types. While it should be easy to create/modify a custom list from the literature, this particular list is included as a package dataset markerslist_tcellmajor to facilitate ease of use.\n\ndata(\"markerslist_tcellmajor\")\n\n\nstr(markerslist_tcellmajor)\n\nList of 2\n $ cd8t:List of 3\n  ..$ index_marker                               : chr [1:2] \"CD8B\" \"CD8A\"\n  ..$ predictors                                 : chr [1:48] \"CD3D\" \"CD3E\" \"CD3G\" \"CD8A\" ...\n  ..$ use_offclass_markers_as_negative_predictors: logi TRUE\n $ cd4t:List of 3\n  ..$ index_marker                               : chr \"CD4\"\n  ..$ predictors                                 : chr [1:48] \"CD3D\" \"CD3E\" \"CD3G\" \"CD4\" ...\n  ..$ use_offclass_markers_as_negative_predictors: logi TRUE\n - attr(*, \"class\")= chr [1:2] \"list\" \"markerslist\"\n\n\n\n\n5.2.2 Part 2: Estimating a metagene score for each cell type\nBecause single count values marker genes can be noisy, we seek to derive variables that more stably estimate marker expression. To do so, we’ll exploit biologically relevant genes (e.g. CD8A expression is predictive of CD8B expression), and cells with similar expression patterns. To do so, we fit a model for each cell type, using the primary index marker as the response variable and covariates derived from the predictor genes. The predicted values of the primary index marker for this model make a continuous “metagene score” that will later be used for probabilistic cell type assignment. You can think of each metagene score as estimating the canonical marker gene’s expression for a single cell type; e.g. we will produce a FOXP3-estimating metagene to capture Treg’s, a CD68-estimating metagene to capture macrophages, etc…\nWe fit our models for each cell type class using the fit_metagene_scores function. This function uses ‘smoothing’ (averaging over a set of similar cells), as well as our prior biology / assumptions about which markers are associated with each celltype to predict the pearson residuals of the index gene.\nThe default regression model setup looks like this: \\[Y = WY\\eta  + WX\\beta + X\\gamma + \\epsilon \\] where\n\n\\(Y:=\\) pearson residuals of the index marker (our response variable)\n\\(X:=\\) (totalcount-normalized) matrix of predictor genes\n\\(W:=\\) a cells \\(\\times\\) cells neighborhood matrix, denoting cells with similar expression profiles.\n\\(\\eta\\), \\(\\beta\\), and \\(\\gamma\\) are the regression coefficients associated with the ‘neighbor-averaged’ index gene, ‘neighbor-averaged’ predictor genes, and predictor genes within the cell respectively.\n\nOne way to think about this model specification could be as an implementation of a ‘smoothing model’, which leverages information across multiple dimensions:\n\nthe index gene’s mean expression in similar cells (\\(WY\\)) (roughly, neighbors in UMAP space)\nexpression of other expected marker genes (\\(X\\)) (our predictor genes defined from biological knowledge)\nexpression of other expected marker genes in similar cells (\\(WX\\))\n\nWe use a non-negative least squares (Slawski and Hein 2013) (NNLS) regression to estimate our models. The NNLS model enforces that all of the covariates based on predictor genes we specified must have positive regression coefficients (in practice we’ll observe that a number of regression coefficients may shrink to zero).\nBy specifying use_offclass_markers_as_negative_predictors = TRUE in the section above, we further assume that predictors for other celltypes that we haven’t listed can be used as negative predictors of our index gene. For example, genes like like “GZMA” and “GZMB”, which are markers associated with cd8t, will be assumed to be negative predictors of the other classes (cd4t) where they are not listed. This argument should in general be set to TRUE, as it’s useful to specify which genes we don’t expect to see in a celltype. If your markers list has extensive genes expected to be enriched in multiple cell types, and those genes are for some reason omitted from many of the other cell types, then a user might consider specifying this argument as FALSE; e.g. if many genes like CD3E are specified in markers lists for some T cell subtypes but not all (despite being ubiquitously expressed).\nEstimating this model from the dataset at hand rather than using a reference model could make this framework more robust to platform effects or batch effects compared to pre-trained models or reference profiles which used different technology or data with slightly different biology.\nGenes not included in the marker gene lists will not be considered in assigning cell types. Because the model is only using genes we’ve specified in our ‘markers list’, we have complete control over which genes influence the metadata scores, reducing the chance that noisy or irrelevant genes can have an impact on our cell type classifications. Furthermore, by estimating the metagenes directly from the dataset at hand, we are not reliant on reference datasets or pre-trained models influenced by different technology (example: scRNA-seq) or underlying biology (example: different tissue type or disease status, etc).\nHere I call the fit_metagene_scores function to estimate these models for cells corresponding to the unsupervised cluster I’ve identified to be T cells.\nFor the cells \\(\\times\\) cells adjacency_matrix, I’ve used the nearest neighbor matrix in my Seurat object. This is the same graph that was used to generate my UMAP and my unsupervised leiden clusters. After fitting our regression models for each cell type, we’ll use the predicted scores as ‘metagenes’ that can be clustered in the next step.\n\ntcell_ids &lt;- sem@meta.data[sem@meta.data$clusters_unsup==6,\"cell_ID\"]\nmetagenes_t &lt;- \n  fit_metagene_scores(\n    markerslist = markerslist_tcellmajor\n    ,counts_matrix = Matrix::t(sem[[\"RNA\"]]@counts[,tcell_ids])\n    ,adjacency_matrix = as(sem@graphs$umapgrph\n                           ,\"CsparseMatrix\")[tcell_ids,tcell_ids]\n  )\n\nThe metagenes_t object we’ve created has an element for each celltype, including the regression coefficients (bhat), and predicted values we’ll use for clustering (yhat) for each index marker gene for cell type.\n\nstr(metagenes_t,max.level = 2)\n\nList of 2\n $ cd8t:List of 7\n  ..$ CD8B   :List of 5\n  ..$ CD8A   :List of 5\n  ..$ yhat   : Named num [1:7356] 0.593 1.32 2.959 1.375 2.478 ...\n  .. ..- attr(*, \"names\")= chr [1:7356] \"c_1_12_1066\" \"c_1_12_1175\" \"c_1_12_1270\" \"c_1_12_1349\" ...\n  ..$ y      : Named num [1:7356] -0.208 -0.178 2.047 -0.207 -0.242 ...\n  .. ..- attr(*, \"names\")= chr [1:7356] \"c_1_12_1066\" \"c_1_12_1175\" \"c_1_12_1270\" \"c_1_12_1349\" ...\n  ..$ ypost  : Named num [1:7356] -0.1796 -0.0223 1.5179 -0.0269 0.1805 ...\n  .. ..- attr(*, \"names\")= chr [1:7356] \"c_1_12_1066\" \"c_1_12_1175\" \"c_1_12_1270\" \"c_1_12_1349\" ...\n  ..$ bhat   : num [1:125, 1:2] 0.1904 0.1342 0.1113 0.1057 0.0912 ...\n  .. ..- attr(*, \"dimnames\")=List of 2\n  ..$ nnpcfit:List of 7\n  .. ..- attr(*, \"class\")= chr [1:2] \"nsprcomp\" \"prcomp\"\n $ cd4t:List of 6\n  ..$ CD4    :List of 5\n  ..$ yhat   : Named num [1:7356] 0.29 -1.426 -0.968 -0.692 -1.945 ...\n  .. ..- attr(*, \"names\")= chr [1:7356] \"c_1_12_1066\" \"c_1_12_1175\" \"c_1_12_1270\" \"c_1_12_1349\" ...\n  ..$ y      : Named num [1:7356] -0.271 -0.235 -0.418 -0.27 -0.312 ...\n  .. ..- attr(*, \"names\")= chr [1:7356] \"c_1_12_1066\" \"c_1_12_1175\" \"c_1_12_1270\" \"c_1_12_1349\" ...\n  ..$ ypost  : Named num [1:7356] -0.294 -0.366 -0.469 -0.321 -0.507 ...\n  .. ..- attr(*, \"names\")= chr [1:7356] \"c_1_12_1066\" \"c_1_12_1175\" \"c_1_12_1270\" \"c_1_12_1349\" ...\n  ..$ bhat   : num [1:125, 1] 0.3763 0.2525 0.1551 0.1283 0.0749 ...\n  .. ..- attr(*, \"dimnames\")=List of 2\n  ..$ nnpcfit:List of 7\n  .. ..- attr(*, \"class\")= chr [1:2] \"nsprcomp\" \"prcomp\"\n\n\nFor cell types using multiple ‘index marker genes’, like cd8t here (using CD8A and CD8B), metagene scores are combined together using non-negative sparse pca (implemented in the nsprcomp R package) (Sigg and Buhmann 2008). This allows for summarizing an overall cell type metagene score, using a constrained non-negative combination of individual index-gene scores that explains maximal variation across individual index gene scores. Below, we see the PCA rotation representing the individual weights given to CD8A and CD8B metagene scores.\n\nmetagenes_t$cd8t$nnpcfit\n\nStandard deviations (1, .., p=1):\n[1] 1.020128\n\nRotation (n x k) = (2 x 1):\n           PC1\nCD8B 0.6578375\nCD8A 0.7531599\n\n\nWe can get a better understanding of the metagene model outputs by looking at a few diagnostics plots. In the below, we plot the regression coefficients for each model, ordering them on the x-axis by their ranking. For each cell type, the positive \\(\\hat{\\beta}\\) correspond to genes we specified as predictors, and negative \\(\\hat{\\beta}\\) were predictors for either of the other two cell types.\nA lot of the covariates which have the largest magnitudes have “lag.” in their name indicating they correspond to a smoothed (or neighbor-averaged) covariate for that gene.\nWe also see that many genes end up with weights of 0. These genes failed to be predictive in the direction our biological priors expected.\nFor cd4t, we see that smoothed CD4 (indicated by ‘lag.y.CD4’ in the plot) is the strongest predictor of observed ‘CD4’. For cd8t, ‘lag.y.CD8A’ and ‘lag.y.CD8B’ (indicating smoothed CD8A and CD8B) are also among the strongest predictors, but not first in rank.\n\n\nCode\ncoefplots &lt;- metagene_coefficients_plot(metagenes_t)\ncoefplots &lt;- lapply(coefplots, function(x){x +   theme(text=element_text(face='bold',size=18))\n  }) ## just make the text bigger and bold\ncowplot::plot_grid(plotlist = coefplots, nrow = 1)\n\n\n\n\n\nA pairsplot can show us how well the metagene scores we’ve created are distinct from each other. Ideally, if our cell type classes are mutually exclusive, we’d want to not see too many cells which are ‘positive’ for multiple cell types at the same time.\nHere, we see that cd4t and cd8t metagene scores are negatively correlated with each other, which is good to see.\n\n\nCode\nmetagene_pairsplot(metagenes_t, var= \"yhat\")\n\n\n\n\n\n\n\n\n\n\n\n\n\n5.2.3 Part 3: Assigning cell types based on metagene scores\nNow we use the metagene scores to classify cell types. To do so, we estimate the multivariate distribution of metagene scores that characterize each cell type. This allows us to compute the likelihoods for a cell belonging to any of these types, and infer a posterior probability of T-cell subtype for each cell. The cluster_metagenes function we run below estimates a mixture of overfitted multivariate gaussian mixture models (Aragam et al. 2020) to estimate the distribution of metagene scores.\n\nmodel_t &lt;- \nHieraType::cluster_metagenes(metagenes = metagenes_t)\n\nAt a high level, the cluster_metagenes() function first identifies all cells with positive metagene scores for a particular cell type. We might loosely interpret these cells as ‘anchor cells’. The data may look like this for example, where here I have subset my original data to cells which have positive scores for my celltype cd8t.\n\nyh &lt;- make_scores_matrix(metagenes = metagenes_t, \"yhat\")\nyh[yh[,\"cd8t\"] &gt; 0,][1:10,]\n\nThen, a mixture model is fit to these (2-dimensional) scores, by default using 6 components. The estimates corresponding to the individual mixture models for each cell type are found in the models list, with the means (mu_hat), covariance matrices (sigma_hat), and prior probability (pihat) corresponding to each mixture component.\n\nstr(model_t$models, max.level = 2)\n\nList of 2\n $ cd8t:List of 6\n  ..$ post_probs  :Classes 'data.table' and 'data.frame':   2528 obs. of  9 variables:\n  .. ..- attr(*, \".internal.selfref\")=&lt;externalptr&gt; \n  ..$ pihat       : Named num [1:6] 0.2785 0.103 0.0437 0.3024 0.0747 ...\n  .. ..- attr(*, \"names\")= chr [1:6] \"k1\" \"k2\" \"k3\" \"k4\" ...\n  ..$ llmat       : num [1:2528, 1:6] -2.97 -2.87 -2.95 -3.42 -2.43 ...\n  .. ..- attr(*, \"dimnames\")=List of 2\n  ..$ mu_hat      : num [1:6, 1:2] 2.136 0.136 2.966 1.196 0.645 ...\n  .. ..- attr(*, \"dimnames\")=List of 2\n  ..$ sigma_hat   :List of 6\n  ..$ loglik_iters: num [1:262] -4920 -4891 -4883 -4879 -4876 ...\n $ cd4t:List of 6\n  ..$ post_probs  :Classes 'data.table' and 'data.frame':   2623 obs. of  9 variables:\n  .. ..- attr(*, \".internal.selfref\")=&lt;externalptr&gt; \n  ..$ pihat       : Named num [1:6] 0.1544 0.1398 0.2798 0.0414 0.0677 ...\n  .. ..- attr(*, \"names\")= chr [1:6] \"k1\" \"k2\" \"k3\" \"k4\" ...\n  ..$ llmat       : num [1:2623, 1:6] -2.03 -56.28 -126.91 -3.61 -5.12 ...\n  .. ..- attr(*, \"dimnames\")=List of 2\n  ..$ mu_hat      : num [1:6, 1:2] -1.074 -0.779 -1.13 -1.796 -1.429 ...\n  .. ..- attr(*, \"dimnames\")=List of 2\n  ..$ sigma_hat   :List of 6\n  ..$ loglik_iters: num [1:173] -5230 -5189 -5167 -5155 -5147 ...\n\n\nTypically we shouldn’t need to interact with this part of the output. After the mixture models for each cell type are fitted, we can score all cells, and get an overall posterior probability that a cell belongs to any of the two major classes using Bayes rule.\nLet \\(y_c\\) be the cell type category for cell \\(c\\), \\(scores_c\\) the corresponding metagene scores, and \\(t\\) denoting a possible cell ‘type’ or category (for \\(t = 1,...,T\\)).\nWe compute the overall posterior probability that \\(y_c\\) is a particular type \\(t\\), as\n\\[P(y_c = t | scores_c) = \\frac{P(scores_c | y_c = t)P(y_c = t)}{\\sum_{l=1}^T P(scores_c | y_c = l)P(y_c = l)}\\]\nUsing the individual mixture models for a particular cell type with \\(K\\) mixture components, we have \\[P(scores_c | y_c = t) = \\sum_{j=1}^K P(scores_c | k=j, y_c = t) P(k=j | y_c = t)\\]\nThe prior probability for a particular cell type class \\(t\\) can be estimated by counting the number of cells used to estimate the mixture model in each cell type, and computing a proportion amongst all possible cell type classes, i.e., \\[P(y_c = t) = \\frac{\\sum_{c=1}^C I(scores_{c,t} &gt; 0)}{\\sum_{l=1}^T \\sum_{c=1}^C I(scores_{c,l} &gt; 0)}\\] These probabilities are in the post_probs data.table object of the model. The “best class” column gives each cell’s best-fitting cell type.\n\nmodel_t$post_probs[1:10][]\n\n        cell_ID best_class best_score        cd8t         cd4t\n         &lt;char&gt;     &lt;char&gt;      &lt;num&gt;       &lt;num&gt;        &lt;num&gt;\n 1: c_1_12_1066       cd4t  0.6751557 0.324844253 6.751557e-01\n 2: c_1_12_1175       cd8t  0.9999986 0.999998637 1.363123e-06\n 3: c_1_12_1270       cd8t  0.9999989 0.999998939 1.060938e-06\n 4: c_1_12_1349       cd8t  0.9999814 0.999981384 1.861648e-05\n 5: c_1_12_1394       cd8t  1.0000000 0.999999986 1.438074e-08\n 6:  c_1_12_172       cd4t  0.9979380 0.002061995 9.979380e-01\n 7:  c_1_12_228       cd4t  0.9955272 0.004472831 9.955272e-01\n 8:  c_1_12_246       cd4t  0.9933210 0.006679029 9.933210e-01\n 9:  c_1_12_285       cd4t  0.9986854 0.001314640 9.986854e-01\n10:  c_1_12_511       cd4t  0.9911673 0.008832705 9.911673e-01\n\n\n\n\n5.2.4 Granular hierarchical subtyping and using a pipeline\nThese posterior-probability scores can be passed directly to subtyping models for cd4t and cd8t, via the prior_level_weights arguments. For example, if I wanted to go ahead and cluster the cd4t cells into subtypes, I could follow the same process, passing in the prior probability of the cell being cd4t as a weight.\nIn the example below, the probability of cd4t is used as a weight in the NNLS regression fitting (akin to weighted least squares) when constructing metagene scores. Cells with high probability of cd4t are emphasized, while cells with lower probability of cd4t have less influence on the regression coefficients used to generate metagene scores.\nIn the clustering stage, probability of cd4t is again used as a weight (or prior probability), that factors into the expectation step of the EM algorithm. Letting s(t) denote the subtype of cd4t, then we have the below, where \\(P(y_c = t)\\) would be the probability of cd4t from the previous stage of modeling.\nThe final returned probability for each cd4t subtype is a joint probability of both being the subtype \\(s(t)\\) and the major celltype \\(t\\).\n\\[P(y_c = s(t) \\cap y_c = t  | scores_c) = P(y_c = s(t) | scores_c, y_c = t)P(y_c = t)\\]\nBelow is an example of this syntax using the cd4t subtypes in the package dataset “markerslist_cd4tminor”.\n\nstr(HieraType::markerslist_cd4tminor, max.level=2)\n\n\n\nList of 7\n $ cd4_naive:List of 3\n  ..$ index_marker                               : chr [1:4] \"TCF7\" \"LEF1\" \"SELL\" \"CCR7\"\n  ..$ predictors                                 : chr [1:30] \"CD3D\" \"CD3E\" \"CD3G\" \"CD4\" ...\n  ..$ use_offclass_markers_as_negative_predictors: logi TRUE\n $ cd4_tem  :List of 3\n  ..$ index_marker                               : chr [1:4] \"CD44\" \"CCR6\" \"CXCR3\" \"IL7R\"\n  ..$ predictors                                 : chr [1:35] \"CD3D\" \"CD3E\" \"CD3G\" \"CD4\" ...\n  ..$ use_offclass_markers_as_negative_predictors: logi TRUE\n $ cd4_tcm  :List of 3\n  ..$ index_marker                               : chr [1:3] \"CCR7\" \"IL7R\" \"SELL\"\n  ..$ predictors                                 : chr [1:27] \"CD3D\" \"CD3E\" \"CD3G\" \"CD4\" ...\n  ..$ use_offclass_markers_as_negative_predictors: logi TRUE\n $ cd4_th1  :List of 3\n  ..$ index_marker                               : chr [1:4] \"TBX21\" \"IFNG\" \"CXCR3\" \"STAT4\"\n  ..$ predictors                                 : chr [1:30] \"CD3D\" \"CD3E\" \"CD3G\" \"CD4\" ...\n  ..$ use_offclass_markers_as_negative_predictors: logi TRUE\n $ cd4_th2  :List of 3\n  ..$ index_marker                               : chr [1:5] \"GATA3\" \"IL4\" \"IL5\" \"IL13\" ...\n  ..$ predictors                                 : chr [1:30] \"CD3D\" \"CD3E\" \"CD3G\" \"CD4\" ...\n  ..$ use_offclass_markers_as_negative_predictors: logi TRUE\n $ cd4_th17 :List of 3\n  ..$ index_marker                               : chr [1:4] \"RORC\" \"IL17A\" \"IL17F\" \"IL23R\"\n  ..$ predictors                                 : chr [1:28] \"CD3D\" \"CD3E\" \"CD3G\" \"CD4\" ...\n  ..$ use_offclass_markers_as_negative_predictors: logi TRUE\n $ cd4_treg :List of 3\n  ..$ index_marker                               : chr [1:4] \"FOXP3\" \"IL2RA\" \"CTLA4\" \"TNFRSF18\"\n  ..$ predictors                                 : chr [1:29] \"CD3D\" \"CD3E\" \"CD3G\" \"CD4\" ...\n  ..$ use_offclass_markers_as_negative_predictors: logi TRUE\n - attr(*, \"class\")= chr [1:2] \"list\" \"markerslist\"\n\n\n\n#### Classify cd4t subtypes\nmetagenes_t4 &lt;-\n  HieraType::fit_metagene_scores(\n    markerslist = HieraType::markerslist_cd4tminor\n    ,counts_matrix = Matrix::t(sem[[\"RNA\"]]@counts[,tcell_ids])\n    ,adjacency_matrix = as(sem@graphs$umapgrph\n                           ,\"CsparseMatrix\")[tcell_ids,tcell_ids]\n    ,prior_level_weights = model_t$post_probs$cd4t ## prior probability of cd4t\n  )\nmodel_t4 &lt;- \nHieraType::cluster_metagenes(metagenes = metagenes_t4, prior_prob_level = model_t$post_probs$cd4t)\n\nA convenient way to simplify this process with minimal code is to use a pipeline object. A custom hierarchical cell typing pipeline could be created like this below, where\n\nmarkerslists is a named list, with a markerslist for each stage of cell typing. “tmajor” will classify cd8t vs. cd4t, while “t8minor” and “t4minor” will subclassify those cell types respectively.\npriors, a list specifying ‘parent’ celltyping stage. Here , t4minor and t8minor both need to run after “tmajor”, as they will use the estimated probabilities of “cd4t” and “cd8t” as inputs.\n“tmajor” runs first, and does not have prior probability inputs.\npriors_category, a list specifying ‘parent’ / major categories of each celltype. Here , t4minor is a subset of \"cd4t\". “tmajor” runs first, and does not have a prior.\n\n\npipeline_tcell &lt;- \n  make_pipeline(markerslists = list(\"tmajor\" = HieraType::markerslist_tcellmajor\n                    ,\"t4minor\" = HieraType::markerslist_cd4tminor\n                    ,\"t8minor\" = HieraType::markerslist_cd8tminor\n                    )\n                 ,priors = list(\"t4minor\" = \"tmajor\"\n                               ,\"t8minor\" = \"tmajor\")\n                 ,priors_category = list(\"t4minor\" = \"cd4t\"\n                                         ,\"t8minor\" = \"cd8t\"\n                                         )\n    )\n\n\nclass(pipeline_tcell)\n\n[1] \"list\"     \"pipeline\"\n\n\nThis particular pipeline is also saved as a package dataset.\n\nstr(HieraType::pipeline_tcell, max.level=2)\n\n\n\nList of 3\n $ markerslists   :List of 3\n  ..$ tmajor :List of 2\n  .. ..- attr(*, \"class\")= chr [1:2] \"list\" \"markerslist\"\n  ..$ t4minor:List of 7\n  .. ..- attr(*, \"class\")= chr [1:2] \"list\" \"markerslist\"\n  ..$ t8minor:List of 5\n  .. ..- attr(*, \"class\")= chr [1:2] \"list\" \"markerslist\"\n $ priors         :List of 2\n  ..$ t4minor: chr \"tmajor\"\n  ..$ t8minor: chr \"tmajor\"\n $ priors_category:List of 2\n  ..$ t4minor: chr \"cd4t\"\n  ..$ t8minor: chr \"cd8t\"\n - attr(*, \"class\")= chr [1:2] \"list\" \"pipeline\"\n\n\nThe code to run the pipeline is shown below. Additional arguments to be passed to fit_metagene_scores or cluster_metagenes functions can be passed as additional arguments to run_pipeline() .\n\n### Run a 'tcell'-typing pipeline, which \n### first classifies into T8/T4 categories (using the `tmajor` markerslist), \n### then runs subclassification for T4 and T8 using the t4minor and t8minor markerslists.\ntcell_typing &lt;- \nrun_pipeline(pipeline = pipeline_tcell\n    ,counts_matrix = Matrix::t(sem[[\"RNA\"]]@counts[,tcell_ids])\n    ,adjacency_matrix = as(sem@graphs$umapgrph\n                           ,\"CsparseMatrix\")[tcell_ids,tcell_ids]\n    ,celltype_call_threshold = 0.5\n    ,return_all_columns_postprobs = FALSE\n    )\n\nWe could take a look at individual models and metagenes objects if needed within our tcell_typing result. Below, we show that the outputted objects are the same in the pipeline format, as if we had ran them individually like in the method demonstration.\n\nall.equal(model_t, tcell_typing$models$tmajor)\n\n[1] TRUE\n\nall.equal(metagenes_t, tcell_typing$metagene_scores$tmajor)\n\n[1] TRUE\n\n\nBy default, two possible cell type classifications are returned in the overall post_probs data.table object from our pipeline. Below, celltype_granular shows the most granular classification for each cell, carrying the ‘best possible’ classification at each stage of the pipeline. For example, the first cell below was first identified as cd8t being the best category. The best subcategory of cd8t was cd8_exhausted, and the posterior probability score for cd8t_exhausted was ~0.47.\nWe set the the cutoff celltype_call_threshold=0.5 when we ran the pipeline, so that the celltype_thresh classification shows the most granular cell type with probability scores at least this threshold. The first cell below has cd8_exhausted score ~0.47 (less than 0.5), and so takes the higher level category of cd8t, which is above the threshold at ~0.99999.\n\ntcell_typing$post_probs[[\"tmajor\"]][1:10]\n\nKey: &lt;cell_ID&gt;\n        cell_ID celltype_thresh celltype_granular best_score_granular\n         &lt;char&gt;          &lt;char&gt;            &lt;char&gt;               &lt;num&gt;\n 1: c_1_12_1014            cd8t     cd8_exhausted           0.4691963\n 2: c_1_12_1066            cd4t           cd4_th1           0.3352265\n 3: c_1_12_1091         cd4_th2           cd4_th2           0.9683195\n 4: c_1_12_1175   cd8_cytotoxic     cd8_cytotoxic           0.8777777\n 5: c_1_12_1270         cd8_tem           cd8_tem           0.5882417\n 6: c_1_12_1286        cd4_treg          cd4_treg           0.9909980\n 7: c_1_12_1325            cd4t           cd4_tcm           0.4647576\n 8: c_1_12_1346        cd4_treg          cd4_treg           0.8298557\n 9: c_1_12_1349            cd8t           cd8_tem           0.3939835\n10: c_1_12_1394   cd8_cytotoxic     cd8_cytotoxic           0.9587283\n    best_score_thresh\n                &lt;num&gt;\n 1:         0.9999999\n 2:         0.6751557\n 3:         0.9683195\n 4:         0.8777777\n 5:         0.5882417\n 6:         0.9909980\n 7:         0.9984388\n 8:         0.8298557\n 9:         0.9999814\n10:         0.9587283\n\n\nWe can remake this table with a different cutoff in mind as needed, depending on how conservative / aggressive we are comfortable being with the cell type call, using the combine_postprob_tables function.\nAs demonstration, we can look at the output if we were to raise our threshold from 0.5 to 0.8.\nWe can “return_all_columns” to show a more verbose result, with individual columns showing the joint probability scores for all possible cell type categories in each cell.\n\nHieraType::combine_postprob_tables(pipeline = pipeline_tcell\n                                   ,models = tcell_typing$models\n                                   ,celltype_call_threshold = 0.8\n                                   ,return_all_columns = TRUE)[[\"tmajor\"]][1:10]\n\n\n\n        cell_ID best_class_tmajor best_score_tmajor        cd8t         cd4t\n         &lt;char&gt;            &lt;char&gt;             &lt;num&gt;       &lt;num&gt;        &lt;num&gt;\n 1: c_1_12_1014              cd8t         0.9999999 0.999999904 9.619835e-08\n 2: c_1_12_1066              cd4t         0.6751557 0.324844253 6.751557e-01\n 3: c_1_12_1091              cd4t         0.9988244 0.001175604 9.988244e-01\n 4: c_1_12_1175              cd8t         0.9999986 0.999998637 1.363123e-06\n 5: c_1_12_1270              cd8t         0.9999989 0.999998939 1.060938e-06\n 6: c_1_12_1286              cd4t         0.9981013 0.001898693 9.981013e-01\n 7: c_1_12_1325              cd4t         0.9984388 0.001561222 9.984388e-01\n 8: c_1_12_1346              cd4t         0.9982395 0.001760536 9.982395e-01\n 9: c_1_12_1349              cd8t         0.9999814 0.999981384 1.861648e-05\n10: c_1_12_1394              cd8t         1.0000000 0.999999986 1.438074e-08\n    celltype_thresh celltype_granular best_score_granular best_score_thresh\n             &lt;char&gt;            &lt;char&gt;               &lt;num&gt;             &lt;num&gt;\n 1:            cd8t     cd8_exhausted           0.4691963         0.9999999\n 2:          tmajor           cd4_th1           0.3352265         0.6751557\n 3:         cd4_th2           cd4_th2           0.9683195         0.9683195\n 4:   cd8_cytotoxic     cd8_cytotoxic           0.8777777         0.8777777\n 5:            cd8t           cd8_tem           0.5882417         0.9999989\n 6:        cd4_treg          cd4_treg           0.9909980         0.9909980\n 7:            cd4t           cd4_tcm           0.4647576         0.9984388\n 8:        cd4_treg          cd4_treg           0.8298557         0.8298557\n 9:            cd8t           cd8_tem           0.3939835         0.9999814\n10:   cd8_cytotoxic     cd8_cytotoxic           0.9587283         0.9587283\n    best_class_t4minor best_score_t4minor    cd4_naive      cd4_tem\n                &lt;char&gt;              &lt;num&gt;        &lt;num&gt;        &lt;num&gt;\n 1:            cd4_tem       7.408648e-08 1.251116e-10 7.408648e-08\n 2:            cd4_th1       3.352265e-01 7.836058e-05 2.443358e-01\n 3:            cd4_th2       9.683195e-01 1.152001e-03 7.841427e-05\n 4:           cd4_treg       1.262446e-06 3.588638e-09 1.405697e-11\n 5:            cd4_th1       6.094740e-07 1.213471e-09 2.245479e-07\n 6:           cd4_treg       9.909980e-01 1.289310e-06 8.622134e-08\n 7:            cd4_tcm       4.647576e-01 1.677040e-01 1.226034e-02\n 8:           cd4_treg       8.298557e-01 3.002300e-07 1.581774e-01\n 9:           cd4_treg       1.092955e-05 4.486025e-09 8.873803e-09\n10:           cd4_treg       6.985845e-09 1.273443e-10 5.957512e-09\n         cd4_tcm      cd4_th1      cd4_th2     cd4_th17     cd4_treg\n           &lt;num&gt;        &lt;num&gt;        &lt;num&gt;        &lt;num&gt;        &lt;num&gt;\n 1: 1.195101e-11 2.129543e-08 4.029363e-15 7.197487e-13 6.786477e-10\n 2: 1.867806e-04 3.352265e-01 6.040219e-03 1.158038e-02 7.770771e-02\n 3: 1.148814e-02 9.695413e-03 9.683195e-01 2.286910e-11 8.090952e-03\n 4: 5.892169e-10 6.060104e-08 3.049262e-08 5.391101e-09 1.262446e-06\n 5: 9.412377e-10 6.094740e-07 7.486703e-10 1.940035e-07 3.000945e-08\n 6: 1.653479e-08 1.018626e-08 7.094111e-03 7.843421e-06 9.909980e-01\n 7: 4.647576e-01 7.313584e-04 2.508449e-01 9.533710e-02 6.803462e-03\n 8: 1.020607e-02 6.923060e-14 1.491775e-13 6.882974e-12 8.298557e-01\n 9: 6.009531e-08 8.601937e-07 6.614330e-06 1.389513e-07 1.092955e-05\n10: 1.844918e-10 1.378047e-10 9.658852e-10 2.186144e-11 6.985845e-09\n    best_class_t8minor best_score_t8minor    cd8_naive      cd8_tem\n                &lt;char&gt;              &lt;num&gt;        &lt;num&gt;        &lt;num&gt;\n 1:      cd8_exhausted       0.4691962886 6.011871e-05 1.860347e-01\n 2:      cd8_cytotoxic       0.1649358419 3.833792e-06 1.311043e-01\n 3:            cd8_tcm       0.0005912820 4.489162e-04 2.336174e-08\n 4:      cd8_cytotoxic       0.8777776850 2.319425e-06 3.868444e-07\n 5:            cd8_tem       0.5882416885 1.162076e-05 5.882417e-01\n 6:      cd8_exhausted       0.0018765126 1.183680e-06 1.782040e-06\n 7:          cd8_naive       0.0009770069 9.770069e-04 2.507600e-05\n 8:      cd8_exhausted       0.0017514060 1.019562e-06 1.789781e-07\n 9:            cd8_tem       0.3939834697 2.279564e-04 3.939835e-01\n10:      cd8_cytotoxic       0.9587282579 5.255921e-06 3.696543e-02\n         cd8_tcm cd8_cytotoxic cd8_exhausted\n           &lt;num&gt;         &lt;num&gt;         &lt;num&gt;\n 1: 2.514628e-12  3.447088e-01  4.691963e-01\n 2: 1.210775e-11  1.649358e-01  2.880030e-02\n 3: 5.912820e-04  1.352937e-04  8.823050e-08\n 4: 9.247577e-09  8.777777e-01  1.222182e-01\n 5: 1.619476e-14  2.342515e-01  1.774941e-01\n 6: 1.656608e-07  1.904865e-05  1.876513e-03\n 7: 3.768608e-04  5.270201e-05  1.295761e-04\n 8: 1.001439e-07  7.830808e-06  1.751406e-03\n 9: 1.169891e-06  2.354990e-01  3.702698e-01\n10: 7.792592e-09  9.587283e-01  4.301033e-03\n\n\n\n\n5.2.5 Examining and validating clustering results\nNow we can evaluate the cell typing performance. In particular, we want to check that the genes we specified as the index marker and predictors are in fact marker genes in the corresponding cell types.\nFirst, we can look at a marker gene heatmap made with just the t-cells, and show the genes we specified as the most important ‘index genes’ for each of the cd8t and cd4t subtypes. Looking closely, we see that CD8A and CD8B are much higher in cd8_ compared to cd4_ types. Similarly, CD4 is higher expressed in cd4_ subtypes compared to cd8_ subtypes. Looking at the specific index markers for each subtype, we see good agreement between marker gene specified for each subtype reflected in our heatmap.\n\nfct &lt;- clusterwise_foldchange_metrics(counts = sem[[\"RNA\"]]@counts[,tcell_ids]\n                                      ,metadata = tcell_typing$post_probs[[\"tmajor\"]]\n                                      ,cluster_column = \"celltype_granular\")\nidxs &lt;- unique(unname(c(unlist(lapply(HieraType::markerslist_cd4tminor, \"[[\", \"index_marker\"))\n               ,unlist(lapply(HieraType::markerslist_cd8tminor, \"[[\", \"index_marker\")))))\n\nnms &lt;- c(\"cd4t\", names(HieraType::markerslist_cd4tminor), \"cd8t\", names(HieraType::markerslist_cd8tminor))\nhmsubtype &lt;- marker_heatmap(fct, featsuse = c(\"CD8A\", \"CD8B\", \"CD4\", idxs), clusterorder = nms, orient_diagonal = TRUE)\nprint(hmsubtype)\n\n\n### The key index markers for cd4 subtypes\nlapply(HieraType::markerslist_cd4tminor, \"[[\", \"index_marker\")\n\n### The key index markers for cd8 subtypes\nlapply(HieraType::markerslist_cd8tminor, \"[[\", \"index_marker\")\n\n\n\n$cd4_naive\n[1] \"TCF7\" \"LEF1\" \"SELL\" \"CCR7\"\n\n$cd4_tem\n[1] \"CD44\"  \"CCR6\"  \"CXCR3\" \"IL7R\" \n\n$cd4_tcm\n[1] \"CCR7\" \"IL7R\" \"SELL\"\n\n$cd4_th1\n[1] \"TBX21\" \"IFNG\"  \"CXCR3\" \"STAT4\"\n\n$cd4_th2\n[1] \"GATA3\" \"IL4\"   \"IL5\"   \"IL13\"  \"CCR4\" \n\n$cd4_th17\n[1] \"RORC\"  \"IL17A\" \"IL17F\" \"IL23R\"\n\n$cd4_treg\n[1] \"FOXP3\"    \"IL2RA\"    \"CTLA4\"    \"TNFRSF18\"\n\n\n$cd8_naive\n[1] \"TCF7\" \"LEF1\" \"CCR7\" \"SELL\" \"IL7R\"\n\n$cd8_tem\n[1] \"GZMK\"  \"GZMA\"  \"CXCR3\" \"CD69\"  \"IL7R\" \n\n$cd8_tcm\n[1] \"CCR7\" \"IL7R\" \"SELL\"\n\n$cd8_cytotoxic\n[1] \"GZMB\"  \"PRF1\"  \"GNLY\"  \"KLRD1\" \"IFNG\" \n\n$cd8_exhausted\n[1] \"PDCD1\"  \"LAG3\"   \"TIGIT\"  \"HAVCR2\" \"TOX\"   \n\n\n\n\n\nHere we can attach our T-cell annotations back onto our metadata, and remake our marker heatmap.\n\nmet &lt;- \nmerge(data.table(sem@meta.data), tcell_typing$post_probs[[\"tmajor\"]][,.(cell_ID, celltype = celltype_granular, best_score_granular)]\n      ,by=\"cell_ID\", all.x=TRUE)\nmet[is.na(celltype),celltype:=clusters_unsup]\n\nfc_t_all &lt;- \nHieraType::clusterwise_foldchange_metrics(normed = sem[[\"RNA\"]]@data\n                   ,metadata = met\n                   ,cluster_column = \"celltype\"\n                   )\n\nhm_tcell &lt;- HieraType::marker_heatmap(fc_t_all\n                           ,extras = c(\"CD4\", \"CD8A\", \"CD8B\")\n                          )\nprint(hm_tcell)\n\n\n\n\nTreating the ‘posterior probability’ as a confidence that the cell belongs to the corresponding cluster, we can show that the proportion of cells that express the expected marker genes generally increases with higher confidence.\nIn the figure below, we compare the major cd4t and cd8t T cell types in terms of some of their marker genes which are specific to each. We see that CD8A and CD8B increase in cd8t cells as we gain confidence in the cell type call, along with other cd8t specific markers (GZMB, GNLY, PRF1).\nSimilarly, we see that CD4 increases in cd4t calls with higher posterior probability scores, along with cd4t subtype-specific markers like FOXP3, CTLA4, TIGIT (cd4_treg marker genes), IL17A and IL17F (cd4_th17 markers) and GATA3 (cd4_th2 marker).\n\np &lt;- \nmarker_threshold_plot(normed = sem[[\"RNA\"]]@data\n                      ,metadata = tcell_typing$models$tmajor$post_probs\n                      ,clusters = c(\"cd4t\", \"cd8t\")\n                      ,markers = c(\"CD3D\", \"CD4\", \"IL17A\", \"IL17F\", \"GATA3\", \"FOXP3\",  \"IL2RA\", \"CTLA4\", \"TIGIT\",\"CD8A\", \"CD8B\", \"GNLY\", \"GZMB\",\"PRF1\")\n                      ,thresholds = c(0.3, 0.5, 0.7, 0.9, 0.99, 0.995)\n                      ,score_column = \"best_score\"\n                      ,cluster_column = \"best_class\"\n                      )\n\np &lt;- p + theme(text=element_text(size=14,face='bold')) + \n  labs(title = \"Proportion of cells expressing marker gene increases with \\nposterior probability confidence scores\")\nprint(p)\n\n\n\n\nHere’s another look at the pairsplot for our metagene scores,this time coloring the cells based on their classification.\n\nmetagene_pairsplot(metagenes_t, \"yhat\", obs = model_t$post_probs[,.(cell_ID, best_class)], colorvar = \"best_class\")"
  },
  {
    "objectID": "posts/immune-cell-typing-smooth/index.html#tldr2",
    "href": "posts/immune-cell-typing-smooth/index.html#tldr2",
    "title": "Using marker gene driven metagene scores for granular hierarchical cell typing.",
    "section": "6.1 ‘Just The Code’",
    "text": "6.1 ‘Just The Code’\nHere’s the code to produce the set of cell types. The next section will cover the details and discuss a few choices that were made.\n\n### Pipeline, with \n### level-1 ('l1') being major categorization \n### level-2 ('l2') being classification of major immune cell categories\n### level-t ('lt') being T8/T4 classification\n\npipeline_io &lt;- HieraType::make_pipeline(\n  markerslists = list(\"l1\" = HieraType::markerslist_l1\n                      ,\"l2\" = HieraType::markerslist_immunemajor\n                      ,\"lt\" = HieraType::markerslist_tcellmajor)\n  ,priors = list(\"lt\" = \"l2\"\n                 ,\"l2\" = \"l1\") \n  ,priors_category = list(\"lt\" = \"tcell\"\n                          ,\"l2\" = \"immune\")\n)\n\n\n### run my pipeline (using all cells)\nimmune_typing &lt;- \nrun_pipeline(pipeline = pipeline_io\n             ,counts_matrix = Matrix::t(sem[[\"RNA\"]]@counts)\n             ,adjacency_matrix = as(sem@graphs$umapgrph\n                                    ,\"CsparseMatrix\")\n             ,celltype_call_threshold = 0.5\n             ,return_all_columns_postprobs = FALSE\n             )"
  },
  {
    "objectID": "posts/immune-cell-typing-smooth/index.html#evaluation",
    "href": "posts/immune-cell-typing-smooth/index.html#evaluation",
    "title": "Using marker gene driven metagene scores for granular hierarchical cell typing.",
    "section": "6.2 Evaluation",
    "text": "6.2 Evaluation\nLike previously, this pipeline, and the corresponding markerslists are saved as package datasets.\n\nstr(HieraType::pipeline_io,max.level=3)\n\n\n\nList of 3\n $ markerslists   :List of 3\n  ..$ l1:List of 6\n  .. ..$ epithelial   :List of 3\n  .. .. ..$ index_marker                               : chr [1:4] \"EPCAM\" \"KRT18\" \"KRT19\" \"CDH1\"\n  .. .. ..$ predictors                                 : chr [1:167] \"EPCAM\" \"KRT18\" \"KRT8\" \"KRT19\" ...\n  .. .. ..$ use_offclass_markers_as_negative_predictors: logi TRUE\n  .. ..$ endothelial  :List of 3\n  .. .. ..$ index_marker                               : chr [1:3] \"PECAM1\" \"VWF\" \"CDH5\"\n  .. .. ..$ predictors                                 : chr [1:129] \"PECAM1\" \"VWF\" \"CDH5\" \"CLDN5\" ...\n  .. .. ..$ use_offclass_markers_as_negative_predictors: logi TRUE\n  .. ..$ fibroblast   :List of 3\n  .. .. ..$ index_marker                               : chr [1:3] \"COL1A1\" \"DCN\" \"PDGFRA\"\n  .. .. ..$ predictors                                 : chr [1:131] \"COL1A2\" \"VIM\" \"S100A4\" \"PDGFRB\" ...\n  .. .. ..$ use_offclass_markers_as_negative_predictors: logi TRUE\n  .. ..$ plasma       :List of 3\n  .. .. ..$ index_marker                               : chr [1:5] \"IGHG1\" \"IGHG1/2\" \"IGHA1\" \"MZB1\" ...\n  .. .. ..$ predictors                                 : chr [1:29] \"IGHG1\" \"IGHG1/2\" \"IGHA1\" \"MZB1\" ...\n  .. .. ..$ use_offclass_markers_as_negative_predictors: logi TRUE\n  .. ..$ immune       :List of 3\n  .. .. ..$ index_marker                               : chr [1:6] \"PTPRC\" \"ITGB2\" \"SPI1\" \"CD52\" ...\n  .. .. ..$ predictors                                 : chr [1:142] \"PTPRC\" \"CD3E\" \"CD3D\" \"CD4\" ...\n  .. .. ..$ use_offclass_markers_as_negative_predictors: logi TRUE\n  .. ..$ smooth_muscle:List of 3\n  .. .. ..$ index_marker                               : chr [1:4] \"MYH11\" \"ACTA2\" \"TAGLN\" \"DES\"\n  .. .. ..$ predictors                                 : chr [1:64] \"MYH11\" \"ACTA2\" \"TAGLN\" \"DES\" ...\n  .. .. ..$ use_offclass_markers_as_negative_predictors: logi TRUE\n  .. ..- attr(*, \"class\")= chr [1:2] \"list\" \"markerslist\"\n  ..$ l2:List of 7\n  .. ..$ tcell     :List of 3\n  .. .. ..$ index_marker                               : chr [1:6] \"CD3D\" \"CD3G\" \"CD3E\" \"IL7R\" ...\n  .. .. ..$ predictors                                 : chr [1:117] \"CD3D\" \"CD3E\" \"CD3G\" \"CD8A\" ...\n  .. .. ..$ use_offclass_markers_as_negative_predictors: logi TRUE\n  .. ..$ bcell     :List of 3\n  .. .. ..$ index_marker                               : chr [1:4] \"CD19\" \"MS4A1\" \"CD79A\" \"CD79B\"\n  .. .. ..$ predictors                                 : chr [1:84] \"CD19\" \"MS4A1\" \"CD79A\" \"CD79B\" ...\n  .. .. ..$ use_offclass_markers_as_negative_predictors: logi TRUE\n  .. ..$ macrophage:List of 3\n  .. .. ..$ index_marker                               : chr [1:4] \"CD163\" \"CD68\" \"MARCO\" \"CSF1R\"\n  .. .. ..$ predictors                                 : chr [1:100] \"CD68\" \"CD163\" \"MARCO\" \"CSF1R\" ...\n  .. .. ..$ use_offclass_markers_as_negative_predictors: logi TRUE\n  .. ..$ neutrophil:List of 3\n  .. .. ..$ index_marker                               : chr [1:4] \"MPO\" \"FCGR3B\" \"S100A8\" \"S100A9\"\n  .. .. ..$ predictors                                 : chr [1:100] \"MPO\" \"FCGR3B\" \"S100A8\" \"S100A9\" ...\n  .. .. ..$ use_offclass_markers_as_negative_predictors: logi TRUE\n  .. ..$ mast      :List of 3\n  .. .. ..$ index_marker                               : chr [1:5] \"KIT\" \"TPSAB1\" \"TPSB2\" \"TPSAB1/2\" ...\n  .. .. ..$ predictors                                 : chr [1:92] \"KIT\" \"TPSAB1\" \"CPA3\" \"TPSB2\" ...\n  .. .. ..$ use_offclass_markers_as_negative_predictors: logi TRUE\n  .. ..$ monocyte  :List of 3\n  .. .. ..$ index_marker                               : chr [1:4] \"CD14\" \"FCGR3A\" \"CCR2\" \"LYZ\"\n  .. .. ..$ predictors                                 : chr [1:130] \"CD14\" \"FCGR3A\" \"CCR2\" \"LYZ\" ...\n  .. .. ..$ use_offclass_markers_as_negative_predictors: logi TRUE\n  .. ..$ dendritic :List of 3\n  .. .. ..$ index_marker                               : chr [1:5] \"ITGAX\" \"CLEC9A\" \"FLT3\" \"XCR1\" ...\n  .. .. ..$ predictors                                 : chr [1:103] \"ITGAX\" \"CLEC9A\" \"FLT3\" \"XCR1\" ...\n  .. .. ..$ use_offclass_markers_as_negative_predictors: logi TRUE\n  .. ..- attr(*, \"class\")= chr [1:2] \"list\" \"markerslist\"\n  ..$ lt:List of 2\n  .. ..$ cd8t:List of 3\n  .. .. ..$ index_marker                               : chr [1:2] \"CD8B\" \"CD8A\"\n  .. .. ..$ predictors                                 : chr [1:48] \"CD3D\" \"CD3E\" \"CD3G\" \"CD8A\" ...\n  .. .. ..$ use_offclass_markers_as_negative_predictors: logi TRUE\n  .. ..$ cd4t:List of 3\n  .. .. ..$ index_marker                               : chr \"CD4\"\n  .. .. ..$ predictors                                 : chr [1:48] \"CD3D\" \"CD3E\" \"CD3G\" \"CD4\" ...\n  .. .. ..$ use_offclass_markers_as_negative_predictors: logi TRUE\n  .. ..- attr(*, \"class\")= chr [1:2] \"list\" \"markerslist\"\n $ priors         :List of 2\n  ..$ lt: chr \"l2\"\n  ..$ l2: chr \"l1\"\n $ priors_category:List of 2\n  ..$ lt: chr \"tcell\"\n  ..$ l2: chr \"immune\"\n - attr(*, \"class\")= chr [1:2] \"list\" \"pipeline\"\n\n\nWe can look at a heatmap showing the marker genes for our cell types to check whether the algorithm produced sensible results. Because I have a lot of cell type categories, and some of them are not totally exclusive (for example, macrophage/monocyte are very similar and share many markers), I don’t necessarily expect all my cells to have very high confidence scores for every cell type; I’m okay here with taking the most granular cell type calls and running with them.\nThese clusters show more granularity in a first pass than my original set of unsupervised clusters. The heatmap below also shows very sane-looking results, with marker genes corresponding to many of the genes I specified in markerslists.\n\nfc_l1 &lt;- \n  clusterwise_foldchange_metrics(normed = sem[[\"RNA\"]]@data\n                     ,metadata =immune_typing$post_probs[[1]]\n                     ,cluster_column = \"celltype_granular\"\n  )\nhm_l1 &lt;- marker_heatmap(fc_l1, extras = c(\"CD3D\", \"CD4\", \"CD8A\", \"CD8B\", \"FOXP3\"))\nprint(hm_l1)\n\n\n\n\n\nlapply(HieraType::markerslist_immunemajor, \"[[\", \"index_marker\")\n\n\n\n$tcell\n[1] \"CD3D\"  \"CD3G\"  \"CD3E\"  \"IL7R\"  \"TRBC1\" \"CD2\"  \n\n$bcell\n[1] \"CD19\"  \"MS4A1\" \"CD79A\" \"CD79B\"\n\n$macrophage\n[1] \"CD163\" \"CD68\"  \"MARCO\" \"CSF1R\"\n\n$neutrophil\n[1] \"MPO\"    \"FCGR3B\" \"S100A8\" \"S100A9\"\n\n$mast\n[1] \"KIT\"      \"TPSAB1\"   \"TPSB2\"    \"TPSAB1/2\" \"CPA3\"    \n\n$monocyte\n[1] \"CD14\"   \"FCGR3A\" \"CCR2\"   \"LYZ\"   \n\n$dendritic\n[1] \"ITGAX\"  \"CLEC9A\" \"FLT3\"   \"XCR1\"   \"CD1C\"  \n\n\nHere’s a spatial plot of the cell types we’ve called so far. We could stop here, or continue in the same manner for subclassifying any other cell types.\n\n\nCode\nmet &lt;- merge(data.table(sem@meta.data)\n             ,immune_typing$post_probs$l1[,.(cell_ID, celltype_supervised = celltype_granular)]\n             ,by=\"cell_ID\")\n\ncolorpal &lt;- c('#F0A0FF','#E0FF66','#C20088','#00998F','#426600'\n              , \"#4C005C\" \n              ,'#191919'\n              ,'#003380', '#005C31','#94FFB5','#990000','#0075DC','#FFA405')\nnames(colorpal) &lt;- sort(unique(met[[\"celltype_supervised\"]]))\n\nxyplist_sup &lt;- \n  lapply(split(met, by=\"portion\"), function(xx){\n    HieraType:::xyplot(cluster_column = \"celltype_supervised\", metadata = xx\n                       , ptsize = 0.1, cls = colorpal\n                       #,clusters = c(\"cd4t\", \"cd8t\", \"bcell\")\n#                       , ptsize = 0.01, cls = colorpal\n                       ,plotfirst = c(\"epithelial\", \"endothelial\", \"fibroblast\", \"smooth_muscle\", \"plasma\")\n                       ) + coord_fixed()\n  })  \nxyplot_sup &lt;- \ncowplot::plot_grid(plotlist = xyplist_sup,nrow = 1) + \n  theme(plot.background = element_rect(fill = 'white',color='white')) + \n  cowplot::panel_border(remove=TRUE) \nprint(xyplot_sup)\n\n\n\n\n\nBelow, we notice several interesting things about the spatial distribution of cd8t, cd4t, and bcell types. The cd4t cells tend to show higher colocalization with bcells in tertiary lymphoid type structures, while cd8t spatial distribution are more dispersed throughout the tissue. This reflects the role of cd8t cells in seeking out and killing tumor cells, compared to the role of cd4t cells in local antigen presentation.\n\n\nCode\nxyplist_lymph &lt;- \n  lapply(split(met, by=\"portion\"), function(xx){\n    HieraType:::xyplot(cluster_column = \"celltype_supervised\", metadata = xx\n                       , ptsize = 0.05, cls = colorpal\n                       ,clusters = c(\"cd4t\", \"cd8t\", \"bcell\")\n                       ) + coord_fixed()\n  })\n\nlymphplot &lt;- \ncowplot::plot_grid(\nxyplist_lymph[[1]]  + \n  facet_wrap(~celltype_supervised) + ggdark::dark_theme_bw() + theme(text=element_text(size=12,face='bold'))\n,xyplist_lymph[[2]]  + \n  facet_wrap(~celltype_supervised) + ggdark::dark_theme_bw() + theme(text=element_text(size=12,face='bold'))\n,nrow=2\n,rel_heights  = c(1.3,1)\n)  + \n  theme(plot.background = element_rect(fill = 'black',color='black')) + \n  cowplot::panel_border(remove=TRUE) \n\n\nprint(lymphplot)"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "CosMx® Analysis Scratch Space",
    "section": "",
    "text": "Interactive Spatial Analysis with LLMs\n\n\n\n\n\n\nAtoMx SIP\n\n\nLLMs\n\n\n\n\n\n\n\n\n\nJan 28, 2026\n\n\nEvelyn Metzger\n\n\n\n\n\n\n\n\n\n\n\n\nBasic analysis vignette: differential expression\n\n\n\n\n\n\nrecommended\n\n\ndifferential expression\n\n\noverview\n\n\nhow-tos\n\n\n\nBest practices for CosMx RNA analysis. Post 3 of 3, covering strategies for differential expression analysis. Covers both how to define useful variables for DE and strategies for running DE.\n\n\n\n\n\nDec 24, 2025\n\n\nPatrick Danaher\n\n\n\n\n\n\n\n\n\n\n\n\nBasic analysis vignette: exploratory analysis\n\n\n\n\n\n\nrecommended\n\n\nexploratory analysis\n\n\noverview\n\n\nhow-tos\n\n\n\nBest practices for CosMx RNA analysis. Post 2 of 3, covering exploratory analysis techniques - pathway scoring, Moran’s I for finding spatially dependent genes, InSituCor for finding modules of spatially correlated genes, and InSituDiff for analyzing perturbations from control samples.\n\n\n\n\n\nDec 23, 2025\n\n\nPatrick Danaher\n\n\n\n\n\n\n\n\n\n\n\n\nBasic analysis vignette: QC, normalization, dimension reduction and cell typing\n\n\n\n\n\n\nrecommended\n\n\nquality control\n\n\ncell typing\n\n\nnormalization\n\n\noverview\n\n\nhow-tos\n\n\n\nBest practices for CosMx RNA analysis. Post 1 of 3, covering data loading through cell typing.\n\n\n\n\n\nDec 22, 2025\n\n\nPatrick Danaher\n\n\n\n\n\n\n\n\n\n\n\n\nCosMx® Multiomics: Deriving an expression matrix from aligned CosMx RNA data\n\n\n\n\n\n\nmultiomics\n\n\nRNA\n\n\nalignment\n\n\n\nBrief code to derive an RNA expression matrix from aligned RNA files\n\n\n\n\n\nNov 26, 2025\n\n\nClaire Williams\n\n\n\n\n\n\n\n\n\n\n\n\nIntegrated RNA + protein multiomic cell typing using HieraType\n\n\n\n\n\n\ncell typing\n\n\nalgorithms\n\n\nmultiomics\n\n\n\nEfficient cell typing using multiple analytes\n\n\n\n\n\nNov 4, 2025\n\n\nDan McGuire\n\n\n\n\n\n\n\n\n\n\n\n\nscPearsonPCA: An R package for efficient Principal Components decomposition of pearson residual normalized single cell data\n\n\n\n\n\n\nnormalization\n\n\npearson residuals\n\n\nprincipal component analysis\n\n\nbatch correction\n\n\nmultiomics\n\n\n\nBetter dimension reduction techniques for spatial data.\n\n\n\n\n\nOct 30, 2025\n\n\nDan McGuire\n\n\n\n\n\n\n\n\n\n\n\n\nDifferential expression: best practices and advanced techniques\n\n\n\n\n\n\ndifferential expression\n\n\n\nA broad review of topics in differential expression, including extensive examples of how to set up well-crafted DE questions.\n\n\n\n\n\nOct 21, 2025\n\n\nPatrick Danaher\n\n\n\n\n\n\n\n\n\n\n\n\nAligning CosMx® Same-Cell Multiomics Data\n\n\n\n\n\n\nmultiomics\n\n\nalgorithms\n\n\nprotein\n\n\nRNA\n\n\nalignment\n\n\n\nStand-alone tool for aligning protein and RNA data\n\n\n\n\n\nOct 2, 2025\n\n\nMithra Korukonda, Claire Williams\n\n\n\n\n\n\n\n\n\n\n\n\nVisualizing Spatial Transcriptomics: A Guide to Effective Plotting\n\n\n\n\n\n\nvisualization\n\n\n\nPlotting ideas for spatial transcriptomics with CosMx data\n\n\n\n\n\nAug 20, 2025\n\n\nClaire Williams, Felicia New\n\n\n\n\n\n\n\n\n\n\n\n\nAligning H&E and CosMx Images in napari\n\n\n\n\n\n\nnapari\n\n\nvisualization\n\n\npython\n\n\nhow-tos\n\n\n\nDemonstration of how to align H&E and CosMx images in napari viewer.\n\n\n\n\n\nAug 11, 2025\n\n\nYi Cui, Lidan Wu\n\n\n\n\n\n\n\n\n\n\n\n\nAnalyzing genes’ subcellular localization\n\n\n\n\n\n\noverview\n\n\n\nDemonstration of how to analyze genes’ subcellular locations in a cell pellet array.\n\n\n\n\n\nAug 11, 2025\n\n\nPatrick Danaher\n\n\n\n\n\n\n\n\n\n\n\n\nAdvancing cell segmentation in spatial omics: new models for diverse morphologies\n\n\n\n\n\n\nsegmentation\n\n\nalgorithms\n\n\nCosMx 2.0\n\n\n\nThis post introduces three newly developed deep learning models for nuclear, whole-cell, and neural segmentation in spatial omics, highlighting innovations in training data diversity, multi-channel input design, and post-processing techniques to improve segmentation accuracy across diverse tissue types.\n\n\n\n\n\nJul 16, 2025\n\n\nLidan Wu\n\n\n\n\n\n\n\n\n\n\n\n\nA practical guide to transcript-based cell segmentation in spatial transcriptomics\n\n\n\n\n\n\nsegmentation\n\n\nalgorithms\n\n\nCosMx 2.0\n\n\nhow-tos\n\n\n\nA practical walk-through of transcript-based analysis techniques for cell segmentation and refinement using CosMx data as inputs. This post also introduces the AtoMx custom module for FastReseg analysis.\n\n\n\n\n\nJul 15, 2025\n\n\nLidan Wu\n\n\n\n\n\n\n\n\n\n\n\n\nRecommendations for batch correction\n\n\n\n\n\n\nbatch correction\n\n\ndata integration\n\n\nCosMx 2.0\n\n\n\nThis post discusses batch effects in CosMx; how they impact analyses, how to detect them, and how to correct them.\n\n\n\n\n\nJul 10, 2025\n\n\nDan McGuire\n\n\n\n\n\n\n\n\n\n\n\n\nGuide to comparing data from different CosMx® panels\n\n\n\n\n\n\nquality control\n\n\ndifferential expression\n\n\n\nOur recommended analysis for choosing which panel will be best for your research. We assume you have data from the same tissue from two panels, e.g. the 1k and 6k panels.\n\n\n\n\n\nJun 23, 2025\n\n\nPatrick Danaher\n\n\n\n\n\n\n\n\n\n\n\n\nUsing marker gene driven metagene scores for granular hierarchical cell typing.\n\n\n\n\n\n\ncell typing\n\n\n\nCell typing using metagenes and smoothing.\n\n\n\n\n\nJun 20, 2025\n\n\nDan McGuire\n\n\n\n\n\n\n\n\n\n\n\n\nsmiDE: an open-source package for differential expression analysis with spatially correlated data\n\n\n\n\n\n\ndifferential expression\n\n\nDE\n\n\n\n\n\n\n\n\n\nMay 21, 2025\n\n\nDan McGuire\n\n\n\n\n\n\n\n\n\n\n\n\nCheat sheets for cell typing, powered by LLMs and the Human Protein Atlas\n\n\n\n\n\n\ncell typing\n\n\n\nTo assist with cell typing: links to HPA images of cell type marker proteins for various tissues. This resource lets you compare a cell cluster’s spatial distribution with IHC stains from the Human Protein Atlas.\n\n\n\n\n\nMay 2, 2025\n\n\nPatrick Danaher\n\n\n\n\n\n\n\n\n\n\n\n\nProgrammatic stitching of protein images with napari-cosmx\n\n\n\n\n\n\nnapari\n\n\nhow-tos\n\n\npython\n\n\nprotein\n\n\n\nThis post shows how to stitch CosMx® SMI protein images\n\n\n\n\n\nFeb 21, 2025\n\n\nEvelyn Metzger\n\n\n\n\n\n\n\n\n\n\n\n\nExporting napari-cosmx Zarr stores to OME-TIFF\n\n\n\n\n\n\nnapari\n\n\nhow-tos\n\n\npython\n\n\nOME-TIFF\n\n\n\nThis post shows you how to generate OME-TIFF files from napari-cosmx-generated Zarr stores.\n\n\n\n\n\nFeb 21, 2025\n\n\nEvelyn Metzger\n\n\n\n\n\n\n\n\n\n\n\n\nCell typing with CosMx® SMI Cell Profiles\n\n\n\n\n\n\ncell typing\n\n\n\n\n\n\n\n\n\nJan 23, 2025\n\n\nMegan Vandenberg\n\n\n\n\n\n\n\n\n\n\n\n\nCell typing: advanced strategies\n\n\n\n\n\n\ncell typing\n\n\n\n\n\n\n\n\n\nDec 18, 2024\n\n\nPatrick Danaher\n\n\n\n\n\n\n\n\n\n\n\n\nUsing a tree-based approach to cell type CosMx® datasets\n\n\n\n\n\n\ncell typing\n\n\nalgorithms\n\n\n\nUse a tree-based approach to sequentially cluster cells into finer cell types.\n\n\n\n\n\nDec 12, 2024\n\n\nClaire Williams\n\n\n\n\n\n\n\n\n\n\n\n\nInSituDiff: perturbation analysis for spatial transcriptomics\n\n\n\n\n\n\nexploratory analysis\n\n\n\nPerturbation analysis of disease vs. control cellular neighborhoods.\n\n\n\n\n\nNov 25, 2024\n\n\nPatrick Danaher\n\n\n\n\n\n\n\n\n\n\n\n\nDefining Regions of Interest in CosMx® SMI data using napari\n\n\n\n\n\n\nnapari\n\n\nhow-tos\n\n\npython\n\n\nROIs\n\n\nsubsetting\n\n\ninsitutype\n\n\n\nThis post shows you how to manually select ROIs in python to enhance your your analysis workflow.\n\n\n\n\n\nNov 21, 2024\n\n\nEvelyn Metzger\n\n\n\n\n\n\n\n\n\n\n\n\nCellular neighborhoods: a useful, simple and flexible analysis framework\n\n\n\n\n\n\noverview\n\n\n\nAn introduction to “cellular neighborhoods” and their many uses in analysis.\n\n\n\n\n\nOct 30, 2024\n\n\nPatrick Danaher\n\n\n\n\n\n\n\n\n\n\n\n\nProgrammatic stitching with napari-cosmx\n\n\n\n\n\n\nnapari\n\n\nhow-tos\n\n\npython\n\n\n\nDid you know that napari-cosmx can stitch images from AtoMx® SIP programmatically? In this post I show users who are comfortable with scripting how to stitch without directly using napari’s GUI.\n\n\n\n\n\nOct 18, 2024\n\n\nEvelyn Metzger\n\n\n\n\n\n\n\n\n\n\n\n\nStay up-to-date with our blog using your favorite RSS reader\n\n\n\n\n\n\nrss\n\n\n\nDon’t miss a post! This post shows you how to get automatic updates when there’s a new post.\n\n\n\n\n\nOct 17, 2024\n\n\nEvelyn Metzger\n\n\n\n\n\n\n\n\n\n\n\n\nNew Features of AtoMx® SIP v1.3.2\n\n\n\n\n\n\nnanoU\n\n\n\nNanoString University New Course Alert!\n\n\n\n\n\nOct 17, 2024\n\n\nEvelyn Metzger\n\n\n\n\n\n\n\n\n\n\n\n\nHow does background impact CosMx data, and when does it matter?\n\n\n\n\n\n\nquality control\n\n\noverview\n\n\n\n\n\n\n\n\n\nAug 21, 2024\n\n\nPatrick Danaher\n\n\n\n\n\n\n\n\n\n\n\n\nCreating reference profiles for InSituType\n\n\n\n\n\n\ncell typing\n\n\n\nA short guide to creating reference profiles, and to merging profiles from different sources.\n\n\n\n\n\nAug 21, 2024\n\n\nPatrick Danaher\n\n\n\n\n\n\n\n\n\n\n\n\nInSituCor: an open-source package and AtoMx custom module for exploratory data analysis\n\n\n\n\n\n\nAtoMx\n\n\nexploratory analysis\n\n\n\n\n\n\n\n\n\nJul 18, 2024\n\n\nPatrick Danaher\n\n\n\n\n\n\n\n\n\n\n\n\nUsing Squidpy with AtoMx® SIP exports\n\n\n\n\n\n\nSquidpy\n\n\npython\n\n\nvisualization\n\n\nAnnData\n\n\n\nIn this blog post, I’ll show how to prepare and analyze AtoMx® SIP-exported CosMx® SMI data with python's squidpy package.\n\n\n\n\n\nJul 3, 2024\n\n\nEvelyn Metzger\n\n\n\n\n\n\n\n\n\n\n\n\nComparing AtoMx® SIP flat files with the legacy format\n\n\n\n\n\n\nflat files\n\n\n\nThis short post shows differences between the AtoMx® SIP-exported and legacy CosMx® SMI \"flat files\"\n\n\n\n\n\nJul 3, 2024\n\n\nEvelyn Metzger\n\n\n\n\n\n\n\n\n\n\n\n\nApplications for visualization and cell typing using ‘smoothed’ marker genes\n\n\n\n\n\n\nvisualization\n\n\ncell typing\n\n\n\nApplications for visualization and cell typing using ‘smoothed’ marker genes based on expression nearest neighbors\n\n\n\n\n\nJun 19, 2024\n\n\nDan McGuire\n\n\n\n\n\n\n\n\n\n\n\n\nnapari-cosmx essentials\n\n\n\n\n\n\nnapari\n\n\nhow-tos\n\n\nvisualization\n\n\npython\n\n\n\nIn this post, I walk through some of the basic ways I use napari-cosmx to view and analyze SMI data. I will make use of this GUI/scripting duality and share a combination of GUI and programmatic tips and tricks.\n\n\n\n\n\nJun 17, 2024\n\n\nEvelyn Metzger\n\n\n\n\n\n\n\n\n\n\n\n\nGeoMx® mask generation for marker-based single-cell application\n\n\n\n\n\n\nGeoMx\n\n\nhow-tos\n\n\nimage processing\n\n\npython\n\n\n\nThis post introduces a pipeline for automatic generating GeoMx® Digital Spatial Profiler (DSP)-ready binary masks in batch for marker-based single-cell application. Given the query marker protein of interest, the pipeline would take morphology images and generate binary masks for negative-stained cells and cells connecting to positive-stained regions, respectively. The pipeline runs as a command line and this post would serve as a guide to how it works and how to use it.\n\n\n\n\n\nJun 12, 2024\n\n\nLidan Wu\n\n\n\n\n\n\n\n\n\n\n\n\nMaking composite images from layered morphology 2D images\n\n\n\n\n\n\nSquidpy\n\n\nGiotto\n\n\npre-processing\n\n\npython\n\n\n\nIn this post, we describe a developmental python script that creates composite images from layered morphology 2D images.\n\n\n\n\n\nJun 12, 2024\n\n\nEvelyn Metzger, Vikram Kohli\n\n\n\n\n\n\n\n\n\n\n\n\nCreating an anndata object from AtoMx® exported results for interactive viewer and python-based analysis\n\n\n\n\n\n\nhow-tos\n\n\nvisualization\n\n\nSeurat\n\n\nAnnData\n\n\npython\n\n\n\nThis post describes how to create anndata object from AtoMx® exported results. The resulting oject in ‘.h5ad’ format could be further analyzed using various python-based single-cell analysis tools, like scanpy and squidpy. Non-coders could also share the light-weighted data object, visualize and explore the processed data in several open-sourced interactive viewers, like Cirrocumulus and CELLxGENE viewers. \n\n\n\n\n\nJun 5, 2024\n\n\nLidan Wu\n\n\n\n\n\n\n\n\n\n\n\n\nVignette: Basics of CosMx Analysis in R\n\n\n\n\n\n\nrecommended\n\n\noverview\n\n\nquality control\n\n\nnormalization\n\n\ncell typing\n\n\npre-processing\n\n\n\n\n\n\n\n\n\nMay 24, 2024\n\n\nPatrick Danaher\n\n\n\n\n\n\n\n\n\n\n\n\nFOV QC from single-cell gene expression in spatial dataset\n\n\n\n\n\n\nquality control\n\n\npre-processing\n\n\n\n\n\n\n\n\n\nMay 20, 2024\n\n\nPatrick Danaher\n\n\n\n\n\n\n\n\n\n\n\n\nEvaluating Cell Segmentation Error based on Transcriptional Spatial Profiles using FastReseg\n\n\n\n\n\n\nsegmentation\n\n\nalgorithms\n\n\n\nFastReseg algorithm scores individual transcripts for the goodness-of-fit within their respective cells based on the probability of each gene belonging to each cell type and the spatial dependency of transcript score. FastReseg can flag cells with putative cell segmentation errors and perform corrections rapidly. \n\n\n\n\n\nMay 15, 2024\n\n\nLidan Wu\n\n\n\n\n\n\n\n\n\n\n\n\nIntroduction to visualizing CosMx SMI data in Seurat\n\n\n\n\n\n\nvisualization\n\n\nSeurat\n\n\n\nRecommendations for spatial plots in Seurat\n\n\n\n\n\nMay 10, 2024\n\n\nClaire Williams\n\n\n\n\n\n\n\n\n\n\n\n\nGetting Started with the napari-cosmx plugin\n\n\n\n\n\n\nvisualization\n\n\nnapari\n\n\npython\n\n\n\n\n\n\n\n\n\nMay 1, 2024\n\n\nEvelyn Metzger\n\n\n\n\n\n\n\n\n\n\n\n\nThe spatial algorithms zoo: recommended algorithms and efficient code\n\n\n\n\n\n\nalgorithms\n\n\n\n\n\n\n\n\n\nMar 20, 2024\n\n\nPatrick Danaher\n\n\n\n\n\n\n\n\n\n\n\n\nCell typing: what we’ve found to work\n\n\n\n\n\n\ncell typing\n\n\n\n\n\n\n\n\n\nMar 12, 2024\n\n\nPatrick Danaher\n\n\n\n\n\n\n\n\n\n\n\n\nOn the use of marker genes\n\n\n\n\n\n\ncell typing\n\n\n\n\n\n\n\n\n\nMar 12, 2024\n\n\nPatrick Danaher\n\n\n\n\n\n\n\n\n\n\n\n\nBig datasets: strategies for memory-efficient analysis\n\n\n\n\n\n\nbig data\n\n\n\n\n\n\n\n\n\nMar 4, 2024\n\n\nPatrick Danaher\n\n\n\n\n\n\n\n\n\n\n\n\nQC and normalization of RNA data\n\n\n\n\n\n\nquality control\n\n\nnormalization\n\n\npre-processing\n\n\n\n\n\n\n\n\n\nJan 29, 2024\n\n\nPatrick Danaher\n\n\n\n\n\n\n\n\n\n\n\n\nFunctions for condensing FOVs and tissues to minimize whitespace\n\n\n\n\n\n\nvisualization\n\n\n\n\n\n\n\n\n\nJan 26, 2024\n\n\nPatrick Danaher\n\n\n\n\n\n\n\n\n\n\n\n\nVisualize cellular neighborhood in gallery mode\n\n\n\n\n\n\nvisualization\n\n\nnapari\n\n\n\n\n\n\n\n\n\nJan 24, 2024\n\n\nLidan Wu, Patrick Danaher\n\n\n\n\n\n\n\n\n\n\n\n\nThe impact of segmentation error on differential expression analyses\n\n\n\n\n\n\nsegmentation\n\n\n\n\n\n\n\n\n\nJan 24, 2024\n\n\nPatrick Danaher\n\n\n\n\n\n\n\n\n\n\n\n\nInferring cell polygons from transcript locations\n\n\n\n\n\n\nvisualization\n\n\n\n\n\n\n\n\n\nJan 5, 2024\n\n\nPatrick Danaher\n\n\n\n\n\n\n\n\n\n\n\n\nWhat is high-plex spatial transcriptomics for?\n\n\n\n\n\n\noverview\n\n\n\n\n\n\n\n\n\nJan 5, 2024\n\n\nPatrick Danaher\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "link-to-code.html",
    "href": "link-to-code.html",
    "title": "Blog",
    "section": "",
    "text": "Code for this repository is publicly available on github."
  },
  {
    "objectID": "link-to-code.html#code",
    "href": "link-to-code.html#code",
    "title": "Blog",
    "section": "",
    "text": "Code for this repository is publicly available on github."
  },
  {
    "objectID": "posts/normalization/index.html#qc",
    "href": "posts/normalization/index.html#qc",
    "title": "QC and normalization of RNA data",
    "section": "QC",
    "text": "QC\nQC in CosMx is motivated by known error modes. Here’s a list of major things that can go wrong:\n\nA cell might be undersampled, leading to excessively low counts (Either only a tip of it is in the slide, or detection efficiency is poor within it.) Solution: remove the cell.\nA cell might suffer extremely high background, either due to intrinsic tissue stickiness (e.g. associated with necrosis) or due to optical artifacts. Solution: remove the cell.\nErrors in cell segmentation might assign multiple cells to the same “cell”. Solution: remove these multiplets.\nA FOV might have low counts overall. This can be caused by imaging trouble, tissue peeling, and probably other causes. Solution: remove FOVs with low quality data. (Removing low quality cells isn’t good enough. If a bad FOV has half its cells removed, the spatial pattern implied by the remaining cells, those lucky enough to survive the cell QC, won’t be representative.)\nA FOV’s expression profile can be distorted by image registration errors or by imaging artifacts, e.g. fluorescence hiding spots of one color. These FOVs can be analyzable if you’re careful, but given the uncertainty they pose it’s usually best to remove them.\n\nQC logic would then proceed as follows:\n\nRemove cells with too few counts. We use fairly generous thresholds of 20 counts for our 1000plex assay and 50 counts for the 6000plex assay. Higher / more stringent thresholds would also be reasonable.\n\n\n# counts is the matrix of raw expression profiles, cells in rows, genes in columns\ntotalcounts &lt;- Matrix::rowSums(counts)  \ndrop &lt;- totalcounts &lt; 20\n\n\nRemove cells with high outlier areas. You can use Grubb’s test to detect outliers, or you can draw a histogram of cell areas and choose a cutoff on your own.\nRemove FOVs with poor counts. AtoMx removes FOVs based on their mean count per cell, or by a user-specified quantile of counts per cell. Filtering on % of cells flagged by the above criteria would also be reasonable.\nFlag FOVs with distorted expression profiles. AtoMx now flags FOVs where z-stack registration is highly unstable, but older runs won’t benefit from this update, and other effects, namely background fluorescence, can still distort FOV expression profiles. To implement steps 3 and 4, you can find our FOV QC tool here."
  },
  {
    "objectID": "posts/normalization/index.html#normalization",
    "href": "posts/normalization/index.html#normalization",
    "title": "QC and normalization of RNA data",
    "section": "Normalization",
    "text": "Normalization\nUnlike scRNA-seq data, where cells tend to have somewhat consistent expression levels, spatial platforms vary widely in how much of a cell’s RNA they detect. Normalizing out this effect is important for some analyses. We make the reasonable assumption that a cell’s detection efficiency is well-estimated by its total counts, which implies we can scale each cell’s profile by its total counts:\n\n# counts is the matrix of raw expression profiles, cells in rows, genes in columns\ntotalcounts &lt;- Matrix::rowSums(counts)  \nnorm &lt;- sweep(counts, 1, pmax(totalcounts, 20), \"/\")\n\nNote the pmax(totalcounts, 20) term in the above. This puts a floor on how much we’ll up-scale a cell. This prevents us from taking cells with very few counts and drastically scaling them up, which gives them misleadingly distinct expression profiles.\n(Note: some authors have pointed out that there’s information to be had in a cell’s total counts. For example, cancer cells tend to have high overall RNA expression. When we normalize, we lose this information. But we’ve usually found that a small price to pay to control the variability in total counts that arises from unwanted technical sources. Discerning between highly distinct cell types like cancer vs. immune cells is generally easy, while uncovering trends within a cell type is a harder task where controlling technical variability can be enabling.)"
  },
  {
    "objectID": "posts/normalization/index.html#other-transformations",
    "href": "posts/normalization/index.html#other-transformations",
    "title": "QC and normalization of RNA data",
    "section": "Other transformations",
    "text": "Other transformations\nFor most cases, we recommend keeping data on the linear scale, i.e. normalizing without further transformation. This approach keeps the data on an easily-interpretable scale and tends to perform well in analyses.\nFor some purposes, further transformations can make sense. Transformations like square root or “log1p” (log(1 + x)) inflate the variability of low counts and shrink the variability of high counts. In some datasets, this can make UMAPs and distance-based clustering methods like Leiden and Louvain perform better. Seurat and AtoMx both offer a log1p transformation.\nAtoMx also offers a “Pearson residuals” transformation. This transformation can produce great UMAPs, but is only viable in small studies: because it creates a dense (not sparse) expression matrix, it produces an expression matrix with a huge memory footprint, potentially crashing your analysis environment.\nIf you do perform a non-linear transformation to run UMAP or Leiden clustering, consider using linear-scale data elsewhere in your analysis."
  },
  {
    "objectID": "posts/DE-guide/index.html",
    "href": "posts/DE-guide/index.html",
    "title": "Differential expression: best practices and advanced techniques",
    "section": "",
    "text": "CosMx (R) SMI analyses often culminate in a differential expression (DE) analysis. Exploratory analyses uncover all manner of interesting trends, and then these trends suggest hypotheses that can be tested with DE. A surprising breadth of questions can be framed as DE problems. To give a few examples:\n\nHow do tumor cells respond to the presence of T-cells?\nHow do microglia activate in regions of inflammation?\nHow do microglia differ across brain regions?\nHow do T-cells change as they get farther from blood vessels?\nHow do fibroblasts respond to signaling from ligands in nearby cells?\nHow are macrophages different in inflamed tissue regions?\nHow do beta cells in pancreatic islets respond to local inflammation?\n\nOr, in the general form:\n“How does my favorite cell type change in response to some aspect of its environment?”\nThis post reviews major topics in DE in spatial transcriptomics, providing code when necessary."
  },
  {
    "objectID": "posts/DE-guide/index.html#introduction",
    "href": "posts/DE-guide/index.html#introduction",
    "title": "Differential expression: best practices and advanced techniques",
    "section": "",
    "text": "CosMx (R) SMI analyses often culminate in a differential expression (DE) analysis. Exploratory analyses uncover all manner of interesting trends, and then these trends suggest hypotheses that can be tested with DE. A surprising breadth of questions can be framed as DE problems. To give a few examples:\n\nHow do tumor cells respond to the presence of T-cells?\nHow do microglia activate in regions of inflammation?\nHow do microglia differ across brain regions?\nHow do T-cells change as they get farther from blood vessels?\nHow do fibroblasts respond to signaling from ligands in nearby cells?\nHow are macrophages different in inflamed tissue regions?\nHow do beta cells in pancreatic islets respond to local inflammation?\n\nOr, in the general form:\n“How does my favorite cell type change in response to some aspect of its environment?”\nThis post reviews major topics in DE in spatial transcriptomics, providing code when necessary."
  },
  {
    "objectID": "posts/DE-guide/index.html#setting-up-a-de-question",
    "href": "posts/DE-guide/index.html#setting-up-a-de-question",
    "title": "Differential expression: best practices and advanced techniques",
    "section": "2 Setting up a DE question",
    "text": "2 Setting up a DE question\nOur experience suggests that most studies demand a highly custom DE question whose framing depends on the investigator’s primary questions and working assumptions about the biological system. To assist with this framing, we present below a collection of examples which, with slight modifications and remixing, covers most DE investigations you are likely to find productive. In each case we’ll define a variable that can be used as a predictor in DE models.\n\n2.1 Important note: treatment of continuous variables\nSay we want to run DE against a continuous variable like distance to a cell type, or the expression level of a cytokine in a cell’s neighbors. We can calculate that distance (or neighborhood expression level) and use it as a predictor in our model. However, in doing so we implicitly assume a linear relationship between the variable and our outcome (either linear or log-scale gene expression, depending on the model). Other models might be more appropriate: we could consider transforming the variable, or we could break it into bins for a non-parametric approach. In particular, we have often found that binning of continuous variables produces satisfactory results.\n\n2.1.1 Transformations:\n\nIf you think distance to a feature matters because of some diffused signals, then concentration of those molecules will vary with 1/distance.\nIf neighborhood expression of a molecule is strongly right-tailed, which is likely, then a log transformation could prevent the end of the tail from having undue influence.\nTo make effect sizes more interpretable, scale the variable from 0-1.\nFor variables with strong skew or long tails, a quantile transformation can prevent extreme values from exerting excess influence on DE results.\n\n\n\n2.1.2 Binning / discretizing:\nYou can avoid assumptions about the shape of a variable by binning it, e.g. assigning cells to 20 bins of “distance to nearest T-cell”. Then, you can use a likelihood ratio test against a null model (intercept-only) to test the compound null hypothesis that “this variable predicts expression.” Because we usually have so many cells to work with, the slight loss in statistical power that comes with this approach is usually a cheap tradeoff to make for its flexibility. Also nice: you can use plots like the below to show how each gene changes expression across bins:\n\n\n\n\n\n\n\n\n\nNote: When binning, examine the number of cells per bin. If some bins have too few cells to produce stable results, either consider discarding them, or take wider bins.\n\n\n2.1.3 Splines: flexibility without bins\nDiscretizing / binning has one drawback: the fit to discretized variables can be highly discontinuous, e.g. with a single bin having a large estimated effect size. It often makes sense to assume your design variable’s impact on gene expression varies smoothly across its range. To achieve this, you can use splines:\n\n\nCode\n# define a continuous variable:\nx &lt;- rnorm(5000)\n# fit splines to it, producing a matrix of 10 dimensions:\nsplinex &lt;- as.matrix(splines::ns(x, df = 20))\n# the \"splinex\" matrix can now be input into DE models\n\n# how splinex relates to x:\no = order(x)\nplot(x, splinex[,1], col = 0, xlab = \"variable\", ylab = \"spline values\", cex.lab = 1.3)\n# draw each spline as a line:\nfor (i in 1:ncol(splinex)) {\n  lines(x[o], splinex[o, i], col = scales::alpha(\"darkblue\", 0.3))\n}\n\n\n\n\n\n\n\n\n\n\n\nTo measure a gene’s significance when using splines, use a likelihood ratio test against an intercept-only null model, just as you would with a binned variable. To explore your results, plot mean values across bins for your most significant genes as in the above heatmap.\n\n\n\n2.2 Example data\nFirst, let’s pull in data in a standard format. We’ll assume you’re starting with flat files exported from AtoMx, read into R as demonstrated in our basic analysis vignettes.\n\n\nCode\n## Expected inputs:\n# - counts: a sparse matrix of expression in cells * genes\n# - metadata: a data frame or data table of cell metadata, aligned by row to counts\n# - xy: a 2-column matrix of xy positions, aligned by row to counts\n\n## Further calculations: get normalized counts:\nnorm_factors &lt;- mean(meta_data$nCount_RNA) / meta_data$nCount_RNA \nnorm &lt;- Matrix::Diagonal(x = norm_factors) %*% counts\n\n\nFor our examples, we’ll look at a subset of data from a breast tumor. Our metadata picks up midway through an analysis: we already have cell types and niche calls in the metadata. Here’s a glance at all the metadata we’ll use:\n\n\nCode\nhead(meta_data)\n\n\n\n\n\n\n\n\n\n\n\n…and the sample itself:\n\n\nCode\nclustcols  &lt;- c(Tumor=\"#C4B7A6\",Macrophage=\"#D55E00\",Fibroblast=\"#009E73\",dendritic=\"#CC79A7\",`Necrotic cells`=\"#999999\",Tcell=\"#0072B2\",Plasma=\"#56B4E9\",neutrophil=\"#E69F00\",innate_lymphoid=\"#F0E442\",Vasculature=\"#800000\",nk=\"#117733\",mast=\"#A65628\",bcell=\"#6A3D9A\",Unknown=\"#666666\")\n\npar(mar = c(0,0,0,0))\nplot(xy, pch = 16, cex = 0.3, asp = 1,\n     col = clustcols[meta_data$celltype], xlab = \"\", ylab = \"\")\nlegend(\"topleft\", pch = 16, col = clustcols, legend = names(clustcols), cex = 0.7)\n\n\n\n\n\n\n\n\n\n\n\n\n\n2.3 Gallery of Differential Expression setups\nBelow we demonstrate a variety of ways to define predictor variables for DE. In each case, we’ll plot the variable spatially and provide code for defining it.\n\n2.3.1 Niche / spatial domain (unsupervised)\nA great many algorithms exist for clustering cellular neighborhoods into niches / spatial domains. Lately we favor the Novae algorithm. However you define niches, they’re often a reasonable basis for a DE analysis.\n\n\nCode\n## (use pre-calculated niche)\n## plot niche:\ninds &lt;- meta_data$celltype == \"Tumor\"\npar(mar = c(0,0,2,0))\nplot(xy[inds, ], pch = 16, cex = 0.3, asp = 1,\n     main = \"Tumor cells colored by niche\",\n     col = c(\"dodgerblue3\", \"orange\")[as.numeric(as.factor(meta_data$niche[inds]))],\n     xlab = \"\", ylab = \"\")\npoints(xy[!inds, ], pch = 16, cex = 0.1, col = \"grey80\")\nlegend(\"topleft\", pch = 16, col = c(\"dodgerblue3\", \"orange\"), legend = paste0(\"niche = \", levels(as.factor(meta_data$niche[inds]))), cex = 0.7)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n2.4 Custom-defined niche\nNiches defined through a spatial clustering algorithm are useful for exploring a dataset, but often they are not perfectly aligned to your understanding of a tissue. It is therefore often necessary to define niches by hand, to capture precisely the biology you want. Examples include anatomical structures like cortical layers in the brain, disease states like areas of inflammation, or custom constructs like “near vs. far from glomeruli”.\nIn general, such partitions of the data can be built by applying the code of the following examples, using thresholds to dichotomize continuous variables as needed.\nFor example, in a past anaylsis of a kidney, we defined niches as follows:\n\n“glomeruli”: cells with &gt;30% of their nearest neighbors being glomerulus-specific cell types (podocyte, mesangial cell, glomerular endothelial cells).\n“glomerular boundary”: cells within a fixes distance of glomeruli\n“tubulointerstitium”: everything else\n“immune hotspots”: cells with &gt;10 immune cells in their nearest neighbors. This overrode all the above annotations.\n\nThis approach was driven by our knowledge of the tissue and by our biological questions.\n\n\n2.5 Distance to nearest cell from a given cluster / group\nA common and productive DE question is: how does my favorite cell type change with proximity to another cell type?\nTo demonstrate how to ask this kind of question, below we score tumor cells by their distance to the nearest T-cell:\n\n\nCode\n## Calculate tumor cells' distance to nearest T-cell:\ninds.tumor &lt;- meta_data$celltype == \"Tumor\"\ninds.t     &lt;- meta_data$celltype == \"Tcell\"\nstopifnot(any(inds.tumor), any(inds.t))\ndist2tcell &lt;- FNN::get.knnx(\n  data  = as.matrix(xy[inds.t, , drop=FALSE]),\n  query = as.matrix(xy),\n  k = 1\n)$nn.dist[, 1]\n# store in metadata:\nmeta_data$dist2tcell &lt;- dist2tcell\n\n## plot tumor cells, coloring by distance to T-cell:\npar(mar = c(0,0,2,0))\nplot(xy[inds.tumor, ], pch = 16, cex = 0.3, asp = 1,\n     main = \"Tumor cells colored by distance to T-cell\",\n     col = colorRampPalette(c(c(\"#A6CEE3\",\"#1F78B4\",\"#081D58\", \"black\")))(101)[\n       1 + round(100 * dist2tcell / max(dist2tcell))\n     ][inds.tumor],\n     xlab = \"\", ylab = \"\")\npoints(xy[!inds.tumor, ], pch = 16, cex = 0.1, col = \"wheat\")\npoints(xy[inds.t, ], pch = 16, cex = 0.3, col = \"red\")\n\nlegend(\"topleft\", pch = 16, col = c(\"#1F78B4\", \"red\", \"wheat\"), \n       legend = c(\"Tumor cells (colored by distance to T-cells)\", \"T-cells\", \"other cells\"), cex = 0.7)\n\n\n\n\n\n\n\n\n\n\n\n\n\n2.6 Distance to nearest cell from an anatomical structure\nMany cell types fall in structures, e.g. blood vessels, tumor glands, or glomeruli. When calculating distance to a structure, it is tempting to simply record distance to the nearest relevant cell type, e.g. endothelial cells for blood vessels, or tumor cells for tumor glands, or podocytes and mesangial cells for glomeruli. However, this approach is easily distorted by sporadic cell typing errors. It is more robust to look at distance to the nearest spatially contiguous group of the target cell type.\nBelow, we’ll define an annotation for ‘vascular structure’, based on contiguous groups of endothelial cells. We use DBSCAN algorithm, an incredibly fast algorithm which can cluster together cells within a fixed radius of each other. We’ll keep only cells that fall in clusters of at least 3.\nFirst let’s look at our target cell type:\n\n\nCode\n## show the target cell type: vasculature\ninds &lt;- meta_data$celltype == \"Vasculature\"\npar(mar = c(0,0,2,0))\nplot(xy[, ], pch = 16, cex = 0.1, asp = 1,\n     main = \"Vasculature\", col = \"grey80\",\n     xlab = \"\", ylab = \"\")\npoints(xy[inds, ], pch = 16, cex = 0.3, col = \"darkred\")\n\n\n\n\n\n\n\n\n\n\n\nThen retain only the spatially-contiguous groups:\n\n\nCode\n## use dbscan to isolate clusters of Vasculature cells:\ndb &lt;- dbscan::dbscan(xy[inds, ],\n                     eps = 0.05, # very small radius\n                     minPts = 3)$cluster\ninds.in.clusters &lt;- db != 0\nis.vessel &lt;- inds\nis.vessel[which(inds)] &lt;- inds.in.clusters\n# store in metadata:\nmeta_data$is.vessel &lt;- is.vessel\n\n## show the result:\npar(mar = c(0,0,2,0))\nplot(xy[, ], pch = 16, cex = 0.1, asp = 1,\n     main = \"Vasculature after filter with dbscan\", col = \"grey80\",\n     xlab = \"\", ylab = \"\")\npoints(xy[inds & !is.vessel,], pch = 16, cex = 0.3, col = \"blue\")\npoints(xy[is.vessel, ], pch = 16, cex = 0.3, col = \"red\")\nlegend(\"topleft\", pch = 16, col = c(\"red\", \"blue\"), \n       legend = c(\"Blood vessel cells\", \"Vasculature cells excluded by dbscan\"))\n\n\n\n\n\n\n\n\n\n\n\nAfter obtaining this cleaned up annotation, we could then take the distance to it using\ncode from the tumor distance to T-cell example earlier.\n\n\n2.7 Number of a given cell type in a neighborhood\nAnother common question: how does a cell type change in response to the abundance of another cell type in its neighborhood? Here we’ll log-transform our predictor to acknowledge the probability of diminishing effects of each new T-cell in a tumor cell’s neighborhood.\n\n\nCode\n## Calculate the number of T-cells in each tumor cell's neighborhood:\ninds.tumor &lt;- meta_data$celltype == \"Tumor\"\ninds.t &lt;- meta_data$celltype == \"Tcell\"\n\n# get the 50 nearest neighbors of each cell:\nneighbors &lt;- InSituCor:::nearestNeighborGraph(x = xy[, 1], y = xy[, 2], N = 50)\n# (or alternatively, get neighbors within a radius of 0.1mm):\nneighbors.radius &lt;- InSituCor:::radiusBasedGraph(x = xy[, 1], y = xy[, 2], R = 0.1)\n\n# count the T-cells among cells' neighbors:\nneighboring.tcells &lt;- InSituCor:::neighbor_sum(x = 1 * (meta_data$celltype == \"Tcell\"),\n                                               neighbors = neighbors)\nlog.neighboring.tcells &lt;- log2(1 + neighboring.tcells)\n# store in metadata:\nmeta_data$log.neighboring.tcells &lt;- log.neighboring.tcells\n\n# color tumor cells by the number of T-cell neighbors:\npar(mar = c(0,0,2,0))\nplot(xy[inds.tumor, ], pch = 16, cex = 0.3, asp = 1,\n     main = \"Tumor cells colored by log2(number of T-cell neighbors)\",\n     col = colorRampPalette(c(c(\"#A6CEE3\",\"#1F78B4\",\"#081D58\", \"black\")))(101)[\n       1 + round(100 * log.neighboring.tcells / max(log.neighboring.tcells))\n     ][inds.tumor],\n     xlab = \"\", ylab = \"\")\npoints(xy[!inds.tumor, ], pch = 16, cex = 0.1, col = \"wheat\")\npoints(xy[inds.t, ], pch = 16, cex = 0.3, col = \"red\")\nlegend(\"topleft\", pch = 16, col = c(\"#1F78B4\", \"red\", \"wheat\"), \n       legend = c(\"Tumor cells colored by log2(number of neighboring T-cells)\", \"T-cells\", \"other cells\"), cex = 0.7)\n\n\n\n\n\n\n\n\n\n\n\n\n\n2.8 Gene expression in cells’ neighborhoods\nTo investigate how a gene impacts nearby cells, we can run differential expression against the gene’s total expression in each cell’s neighborhood. Below, we score macrophages for the total abundance of CXCL14 in their neighborhoods. This sets us up for DE studies of how macrophages respond to signaling from CXCL14. In the below example, we take the additional step of log-transforming neighborhood CXCL14.\n\n\nCode\n## get average CXCL14 expression in each cell's neighborhood:\n\n# get the 50 nearest neighbors of each cell:\nneighbors &lt;- InSituCor:::nearestNeighborGraph(x = xy[, 1], y = xy[, 2], N = 50)\n# (or alternatively, get neighbors within a radius of 0.1mm):\nneighbors.radius &lt;- InSituCor:::radiusBasedGraph(x = xy[, 1], y = xy[, 2], R = 0.1)\n\n# normalized CXCL14:\nnormvals &lt;- counts[, \"CXCL14\"] / meta_data$nCount_RNA\n# get average CXCL14 expression in each cell's neighborhood:\nneighboring.cxcl14 &lt;- InSituCor:::neighbor_sum(x = normvals,\n                                               neighbors = neighbors)\nlog2.neighboring.cxcl14 &lt;- log2(1 + neighboring.cxcl14)\n# add to metadata:\nmeta_data$log2.neighboring.cxcl14 &lt;- log2.neighboring.cxcl14\n\n## plot macrophages, coloring by local CXCL14 expression:\ninds.mac &lt;- meta_data$celltype == \"Macrophage\"\npar(mar = c(0,0,2,0))\nplot(xy, pch = 16, cex = 0.1, asp = 1, col = \"wheat\",\n     main = \"Macrophages colored by log2(neighborhood CXCL14 expression)\",\n     xlab = \"\", ylab = \"\")\npoints(xy[inds.mac, ], pch = 16, cex = 0.4, \n            col = colorRampPalette(c(c(\"#A6CEE3\",\"#1F78B4\",\"#081D58\", \"black\")))(101)[\n       1 + round(100 * log2.neighboring.cxcl14 / max(log2.neighboring.cxcl14))\n     ][inds.mac])\nlegend(\"topleft\", pch = 16, col = c(\"#1F78B4\", \"wheat\"), \n       legend = c(\"Macrophages colored by log2(neighborhood CXCL14 expression)\", \"other cells\"), cex = 0.7)\n\n\n\n\n\n\n\n\n\n\n\n\n\n2.9 Distance to a hand-selected region\nSometimes it’s easier to select a region of a tissue by hand than to devise a computational rule to do so. If your study has e.g. hundreds of glomeruli, you probably want a rule to define in/out of a glomerulus. But if your study has e.g. just a few tertiary lymphoid structures, it’s probably simpler to circle them by hand. Below is code for hand-drawing Regions Of Interest (ROIs) and flagging cells as in/out of them:\n\n\nCode\n#' Define roi's by Clicking on cells in a graphics window\n#' \n#' How to use:\n#' \\itemize{\n#' \\item Plot your cells in xy space. Use asp = 1. \n#' \\item Click cells around the boundary of your roi.\n#' \\item Hit enter or escape when done with your selection.\n#' }\n#' Other details:\n#' \\itemize{\n#' \\item Uses graphics::identify() to select points. \n#' \\item Only works for base graphics, not ggplots.\n#' \\item Can go wrong (draw rois in the wrong place) if the plot doesn't have asp = 1. \n#' }\n#' @param xy Matrix of xy positions used in the plot. \n#' @param show Logical, for whether to show the selected roi when you're done. \n#' @param type One of:\n#' \\itemize{\n#' \\item \"direct\" to define the boundary points in order, exactly as you click\n#' \\item \"ahull\" to draw an alpha hull around your selection\n#' } \n#' @return A list with 3 elements:\n#' \\itemize{\n#' \\item roi: The indices of the points in the roi\n#' \\item selected: The indices of the user-selected points\n#' \\item hull: The hull of the roi, either the user-selected polygon or the results of alphahull:ahull}\n#' @importFrom graphics identify\n#' @importFrom alphahull ahull\n#' @\ndefineROI &lt;- function(xy, type = \"direct\", boundary_points = NULL, show = TRUE) {\n  if (!is.null(boundary_points)) {\n    hull.x &lt;- boundary_points[, 1]\n    hull.y &lt;- boundary_points[, 2]\n    # get points in the boundary:\n    roi &lt;- sp::point.in.polygon(point.x = xy[, 1], point.y = xy[, 2], \n                                pol.x = hull.x, pol.y = hull.y) &gt; 0\n    inds &lt;- NULL\n    hull &lt;- NULL\n  }\n  if (is.null(boundary_points)) {\n    \n    if (!is.element(type, c(\"direct\", \"ahull\"))) {\n      stop(\"must either give boundary_points or set type to \\'direct\\' or \\'ahull\\'\")\n    }\n    # user identifies boundary:\n    identifyres &lt;- identify(xy, plot = FALSE, order = TRUE)\n    inds &lt;- identifyres$ind[order(identifyres$order)]\n    \n    if (type == \"direct\") {\n      # The hull is just the polygon you've selected:\n      hull.x &lt;- xy[inds, 1]\n      hull.y &lt;- xy[inds, 2]\n      hull &lt;- inds\n      # get points in the boundary:\n      roi &lt;- sp::point.in.polygon(point.x = xy[, 1], point.y = xy[, 2], \n                                  pol.x = hull.x, pol.y = hull.y) &gt; 0\n    }\n    \n    if (type == \"ahull\") {\n      # get alpha hull of boundary:\n      hull &lt;- alphahull::ahull(xy[inds, 1], xy[inds, 2], alpha = 0.05)\n      # get points in the boundary:\n      roi &lt;- alphahull::inahull(ahull.obj = hull, xy)\n    }\n    \n  }\n  # plot:\n  if (show) {\n    points(xy[inds, ], col = \"red\", cex = 0.5, pch = 16)\n    polygon(xy[hull, ])\n    points(xy[roi, ], pch = 16, cex = 1, col = scales::alpha(\"gold\", 0.3))\n  }\n  \n  out = list(roi = roi, selected = inds, hull = hull)\n  return(out)\n}\n\n\n## example usage:\nclustcols  &lt;- c(Tumor=\"#C4B7A6\",Macrophage=\"#D55E00\",Fibroblast=\"#009E73\",dendritic=\"#CC79A7\",`Necrotic cells`=\"#999999\",Tcell=\"#0072B2\",Plasma=\"#56B4E9\",neutrophil=\"#E69F00\",innate_lymphoid=\"#F0E442\",Vasculature=\"#800000\",nk=\"#117733\",mast=\"#A65628\",bcell=\"#6A3D9A\",Unknown=\"#666666\")\n\npar(mar = c(0,0,0,0))\nplot(xy, pch = 16, cex = 0.3, asp = 1,\n     col = clustcols[meta_data$celltype], xlab = \"\", ylab = \"\")\n\nroi &lt;- defineROI(xy, type = \"direct\", show = TRUE) \n\n\n\n\n\n\n\n\n\n\n\nNote that the identify() function used by defineROI() above can be finnicky and surprisingly challenging to debug. If it works in your R environment, great. If not, then you can instead call the defineROI() function as in below code to flag cells inside a set of pre-defined xy coordinates.\n\n\nCode\n# draw the tissue:\nclustcols  &lt;- c(Tumor=\"#C4B7A6\",Macrophage=\"#D55E00\",Fibroblast=\"#009E73\",dendritic=\"#CC79A7\",`Necrotic cells`=\"#999999\",Tcell=\"#0072B2\",Plasma=\"#56B4E9\",neutrophil=\"#E69F00\",innate_lymphoid=\"#F0E442\",Vasculature=\"#800000\",nk=\"#117733\",mast=\"#A65628\",bcell=\"#6A3D9A\",Unknown=\"#666666\")\npar(mar = c(2,2,0,0))\nplot(xy, pch = 16, cex = 0.3, asp = 1,\n     col = clustcols[meta_data$celltype], xlab = \"\", ylab = \"\")\n\n# place a grid over it to determine where to pick boundary points:\nabline(h = pretty(range(xy[,2]), n=30), v = pretty(range(xy[,1]), n=30), lty=3, col=\"grey20\")\n\n# select points by hand:\nboundary_points &lt;- t(matrix(c(\n    1.85,7.05,\n    2,7.1,\n    2.05,6.95,\n    1.95,6.85,\n    1.87,6.9\n), nrow = 2))\n\n# define the ROI, i.e. the points in the boundary:\nroi &lt;- defineROI(xy, type = NULL, boundary_points = boundary_points, show = TRUE) \n\n\n\n\n\n\n\n\n\n\n\nThen, you can record distance to your ROI:\n\n\nCode\n## Calculate macrophages' distance to nearest T-cell:\ninds.mac &lt;- meta_data$celltype == \"Macrophage\"\ninds.roi &lt;- roi$roi\ndist2roi &lt;- FNN::get.knnx(\n  data = xy[inds.roi, ], # 2-column matrix of xy locations\n  query = xy, \n  k = 1)$nn.dist\n# add to metadata:\nmeta_data$dist2roi &lt;- dist2roi\n\n\n## plot:\npar(mar = c(0,0,0,0))\nplot(xy, pch = 16, cex = 0.1, asp = 1,\n     col = \"wheat\", xlab = \"\", ylab = \"\")\npoints(xy[inds.roi, ], pch = 16, col = \"orange\", cex = 0.5)\npoints(xy[inds.mac, ], pch = 16, cex = 0.5,\n       col = colorRampPalette(c(\"#A6CEE3\",\"#1F78B4\",\"#081D58\", \"black\"))(101)[\n       1 + round(100 * dist2roi / max(dist2roi))][inds.mac])\nlegend(\"topleft\", pch = 16,\n       col = c(\"#1F78B4\", \"orange\", \"wheat\"),\n       legend = c(\"Macrophages colored by distance to ROI\",\n                  \"Cells in ROI\",\n                  \"Other cells\"))"
  },
  {
    "objectID": "posts/DE-guide/index.html#considerations-for-running-de",
    "href": "posts/DE-guide/index.html#considerations-for-running-de",
    "title": "Differential expression: best practices and advanced techniques",
    "section": "3 Considerations for running DE",
    "text": "3 Considerations for running DE\nAbove we showed how to set up a variable to run DE against. Now we turn to the mechanics of actually running DE. We’ll discuss 2 important topics:\n\nHow to handle bias arising from cell segmentation errors\nHow to account for possible spatial correlation in your data\n\nBoth of these topics are discussed in great depth in this preprint, which accompanies our differential expression package smiDE (blog post) (package). Here we’ll merely summarize.\n\n3.1 Bias from segmentation errors:\nUntil the day that cell segmentation algorithms become perfectly accurate, cells’ expression profiles will occasionally be assigned transcripts from neighboring cells. Because the gene identity of these misassigned transcripts isn’t random across space, they can act as a powerful unmodeled confounding variable. For example: if we’re comparing T-cells in the stroma to T-cells in the tumor, the stroma T-cell profiles will contain transcripts from fibroblasts, and the tumor T-cell profiles will contain transcripts from tumor cells. DE will then discover many highly significant genes: fibroblast genes will appear up-regulated in stroma T-cells, and tumor genes will appear up in tumor-residing T-cells. These spurious hits waste analyst time and compromise analysis quality.\nWe propose two countermeasures to this bias, both implemented in the smiDE package:\n\nDon’t even analyze the genes at greatest risk of this bias. If you’re running DE on T-cells, don’t include genes like EPCAM, which is highly abundant in tumor cells and nearly absent in T-cells. smiDE implements a simple filter to flag genes based on their risk of cell segmentation bias - see the function overlap_ratio_metric().\nIn the remaining genes, adjust for minor bias. We measure a gene’s potential to suffer misassignment into a cell using its mean expression in other cell types around the cell. This then becomes a term in DE models. Taking this step mitigates bias from segmentation errors, though does not fully remove it.\n\n\n\n3.2 Accounting for spatial correlation\nDue to the large number of cells in most experiments, it’s common for DE analyses to produce infinitesimal p-values, e.g. 10^-60. This seems intuitively wrong: how can a dataset hold such strong evidence for expression changes? Where traditional models differ from our intuition (and from common sense) is the assumption that every cell is independent from every other cell. This is almost never true: cells nearby each other are subject to similar environmental influences unrelated to our design variables, so so their standard errors will be dependent, or correlated. In practice, this means that p-values from models assuming independence will be profoundly over-excitable.\nThe field of spatial statistics has long grappled with inference in the presence of spatial correlation such as this, and a sizeable arsenal of methods has been developed. In Vasconcelos & McGuire et al., the aforementioned preprint, we characterize the performance of many of these methods, along with some new ones we propose. We find a tradeoff between accuracy and computational efficiency, with the best methods taking unacceptably long to run in large datasets. Our key finding is that ignoring spatial correlation, i.e. running a traditional DE method, leads to large numbers of false positive hits, often far in excess of the presumed true positive hits whose p-values survive accounting for spatial correlation. Whichever method in the paper seems suitable for your study, you can run it using our R package smiDE.\n\n\n3.3 Other model choice considerations\nWe find that negative binomial models outperform Gaussian models, but at a cost in computational time. Poisson models offer a middle ground in terms of computational time, but typically underestimate standard errors, leading to inflated Type I errors.\nThe performance of Gaussian models is generally acceptable, making them a reasonable choice when computation time is a limitation. smiDE implements all these options under a variety of spatial correlation-aware methods."
  },
  {
    "objectID": "posts/DE-guide/index.html#approach-for-maximal-speed-simultaneous-fitting-of-all-genes-using-linear-algebra",
    "href": "posts/DE-guide/index.html#approach-for-maximal-speed-simultaneous-fitting-of-all-genes-using-linear-algebra",
    "title": "Differential expression: best practices and advanced techniques",
    "section": "4 Approach for maximal speed: simultaneous fitting of all genes using linear algebra",
    "text": "4 Approach for maximal speed: simultaneous fitting of all genes using linear algebra\nUnfortunately, there’s a cost in compute time and money to many of the more theoretically optimal DE approaches (e.g. using a NB distribution, accounting for spatial correlation, adjusting for bias from segmentation errors). An analysis of 19k genes in hundreds of thousands of cells can take a reasonably powerful EC2 instance a day or more to complete. When computation time is a concern, or when simply pursuing exploratory analysis, we recommend using a less optimal but much faster approach. In the code below, we demonstrate how to run a basic Gaussian / “ordinary least squares” regression simultaneously across all genes at once. This code returns reasonable DE results in seconds. This approach cannot model spatial correlation, nor can it adjust for confounding from cell segmentation errors. But its speed makes it very useful for exploratory analyses. It could also be used to prioritize genes for more computationally expensive models.\n\n\nCode\nsource(\"https://github.com/Nanostring-Biostats/CosMx-Analysis-Scratch-Space/blob/Main/_code/PatchDE/DEutils.R\")\n\n### Example usage:\n# run DE:\ninds.tumor &lt;- meta_data$celltype == \"Tumor\"\ninds.t &lt;- meta_data$celltype == \"Tcell\"\ndist2tcell &lt;- FNN::get.knnx(\n  data = xy[inds.t, ], # 2-column matrix of xy locations\n  query = xy, \n  k = 1)$nn.dist\n\nout &lt;- hastyDE(y = norm[inds.tumor, ], \n               df = data.frame(\"dist2tcell\" = dist2tcell[inds.tumor])) \nstr(out)"
  },
  {
    "objectID": "posts/DE-guide/index.html#multi-tissue-analyses",
    "href": "posts/DE-guide/index.html#multi-tissue-analyses",
    "title": "Differential expression: best practices and advanced techniques",
    "section": "5 Multi-tissue analyses",
    "text": "5 Multi-tissue analyses\nSo far we have only discussed the case of a single-tissue analysis. When analyzing multiple tissues, we have a simple recommendation: instead of running one giant DE model across all tissues at once, run your model separately for each tissue. This approach has a few benefits. First, it’s easier to manage computationally - you don’t need to load several large datasets into memory at once. Second, it’s scientifically appealing: we’ll usually have relatively few tissues and a whole lot of cells per tissue. This means we’re powered to run DE within each tissue, and there are few enough tissues that we have the cognitive ability to understand their results individually rather than averaged together. This per-tissue approach lets you see conclusions like, “T-cells react strongly to tumor cells in these three tissues, but not in these other two.” If you want to reduce a DE relationship to a single number, you can always use metaanalysis techniques to get the average relationship across all tissues.\nOur favorite way to display a multi-tissue DE analysis is with a heatmap of per-tissue results, coloring by effect size when results meet a p-value threshold:\n\n\n\n\n\n\n\n\n\nThis approach lets you see which DE trends are universal and which are tissue-specific.\n\n5.1 Best practices for multi-tissue DE:\n\nChoose an appropriate single-tissue DE approach as described earlier. We recommend the smiDE library for most cases.\nAs with all DE analyses, remove genes failing smiDE’s cell overlap ratio metric.\nDisplay results in a heatmap of genes x tissues. Color by effect size, and only give color to results with p &lt; 0.001 (or choose your own threshold). Show only genes that meet a strong effect size / p-value threshold in at least one tissue.\nSummarize each gene’s total evidence with a meta-analysis. We have had luck with the metafor package."
  },
  {
    "objectID": "posts/DE-guide/index.html#experimental-approach-stratifying-de-across-tissue-patches",
    "href": "posts/DE-guide/index.html#experimental-approach-stratifying-de-across-tissue-patches",
    "title": "Differential expression: best practices and advanced techniques",
    "section": "6 Experimental approach: stratifying DE across tissue patches",
    "text": "6 Experimental approach: stratifying DE across tissue patches\nHere we describe an alternative, experimental approach to DE that we have found to be useful. We emphasize that this approach is thus far very lightly tested, but we include it here before fully developing it in hopes that it proves useful and that community feedback strengthens a later release.\nOur motivation arises from two complaints about typical tissue-wide DE:\n\nBiology: we’ll often expect a DE relationship to vary across space, or to only occur locally. For example, perhaps T-cells only respond to nearby tumor cells when they’re in the nutrient-rich stroma rather than the tumor interior. When we look across the whole tissue for this relationship, we have a harder time discovering it since we model both regions where it occurs and regions where it doesn’t. In statistical terminology: unobserved variables across the span of the tissue are acting as effect modifiers.\nConvenience: because accounting for spatial correlation can be slow, running DE on a highly abundant cell type often means making a choice between extreme compute times or using sub-optimal methods that ignore spatial correlation.\n\nOur solution is to divide the tissue into small patches, then to run DE separately within each patch. This produces a matrix of DE results across genes and patches. Then, looking at patch-specific results, we can discover strong relationships that only occur in a few places. And using metaanalysis techniques across all patches, we recover our ability to discover relationships that exist broadly. In short, we get a more nuanced picture of DE behavior within a diverse tissue.\nThis approach has one other benefit: when we analyze small patches, spatial correlation becomes less important, as the spatial context within a given patch will be less variable than spatial context across a whole tissue. This lets us run the super-fast algorithm above within each patch. The speed benefit of this approach is so great that even in a large WTX dataset we obtain full DE results across all patches in minutes, while running just a single tissue-wide model for each gene might take a day.\nTo support patch-based DE. We have created an algorithm to partition a tissue into patches. This algorithm, “patchDE”, attempts to build patches that achieve a balance between the following goals:\n\nEnsure each patch has reasonable statistical power\nPrevent overly large patches\nBuild as many patches as possible\n\nIn other words, we seek to partition the tissue into reasonably-shaped districts that are all well-powered to run DE against the predictor variable.\nThe patchDE algorithm is available as an R script here.\nBelow is a demonstration of patchDE’s use.\nFirst we use define patches:\n\n\nCode\n### use Patch DE to partition the tissue into patches:\nsource(\"https://github.com/Nanostring-Biostats/CosMx-Analysis-Scratch-Space/blob/Main/_code/PatchDE/DEutils.R\")\n\n# define your design variable:\ninds.tumor &lt;- meta_data$celltype == \"Tumor\"\ninds.t     &lt;- meta_data$celltype == \"Tcell\"\nstopifnot(any(inds.tumor), any(inds.t))\ndist2tcell &lt;- FNN::get.knnx(\n  data  = as.matrix(xy[inds.t, , drop=FALSE]),\n  query = as.matrix(xy),\n  k = 1\n)$nn.dist[, 1]\n\n## derive patches:\n# Suggested tuning parameters to use: \n#  1. Control granularity: npatches.\n#  2. Control learning rate: bizesize, then possibly alpha. \n#  3. Patch size and shape: maxradius, roundness\n#  4. Patch position: initwithhotspots\npatches &lt;- getPatches(xy = xy[inds.tumor, ], \n                      X = dist2tcell[inds.tumor], \n                      npatches = 12,\n                      bitesize = 0.1,\n                      maxradius = 0.5,\n                      roundness = 0.25,\n                      initwithhotspots = TRUE,\n                      n_iters = 25,\n                      plotprogress = TRUE\n) # produces a vector of patch assigments, potentially including NA's for cells not given a patch\n\n\n# to view, draw polygon boundaries around each patch:\npatchhulls &lt;- getPatchHulls(xy = xy[inds.tumor, ], patch = patches) \n\n# plot patches:\npar(mar = c(0,0,2,0))\nplot(xy[inds.tumor, ], pch = 16, cex = 0.3, asp = 1,\n     main = \"Tumor cells colored by distance to T-cell, with patches for stratified DE\",\n     col = colorRampPalette(c(c(\"#A6CEE3\",\"#1F78B4\",\"#081D58\", \"black\")))(101)[\n       1 + round(100 * dist2tcell / max(dist2tcell))[inds.tumor]\n     ],\n     xlab = \"\", ylab = \"\")\nfor (i in 1:length(patchhulls)) {\n  plot(patchhulls[[i]], border = \"black\", wpoints = FALSE, add = TRUE)\n}\n\n\n\n\n\n\n\n\n\n\n\nBelow you can see the patches evolve over iterations. Our goal is to get a high “predictor sum of squares” (which determines statistical power) in each patch. You will notice that the per-patch power tends to improve over iterations, especially the early ones, as cells are moved from over-powered patches to under-powered ones. Also note that there algorithm does not converge to a single optimal solution; it ends up wandering around through a space of similarly satisfactory solutions.\n\nWith patches in hand, we can run a computationally-efficient DE test within each patch:\n\n\nCode\n### run DE in each patch, using hastyDE, which computationally-efficient but ignores spatial correlation:\nderesults &lt;- patchDE(y = norm[inds.tumor, ],\n                     df = data.frame(\"dist2tcell\" = dist2tcell[inds.tumor]),\n                     patch = patches)\nstr(deresults)\n# List of 1\n#  $ dist2tcell:List of 3\n#   ..$ pvals: num [1:3, 1:12] 2.59e-01 7.85e-01 3.61e-12 5.70e-01 7.52e-02 ...\n#   .. ..- attr(*, \"dimnames\")=List of 2\n#   .. .. ..$ : chr [1:3] \"PGC\" \"CXCL14\" \"VEGFA\"\n#   .. .. ..$ : chr [1:12] \"patch8\" \"patch3\" \"patch4\" \"patch12\" ...\n#   ..$ ests : num [1:3, 1:12] 1.0276 0.0797 6.3659 -0.3679 -0.2379 ...\n#   .. ..- attr(*, \"dimnames\")=List of 2\n#   .. .. ..$ : chr [1:3] \"PGC\" \"CXCL14\" \"VEGFA\"\n#   .. .. ..$ : chr [1:12] \"patch8\" \"patch3\" \"patch4\" \"patch12\" ...\n#   ..$ ses  : num [1:3, 1:12] 0.911 0.292 0.91 0.647 0.134 ...\n#   .. ..- attr(*, \"dimnames\")=List of 2\n#   .. .. ..$ : chr [1:3] \"PGC\" \"CXCL14\" \"VEGFA\"\n#   .. .. ..$ : chr [1:12] \"patch8\" \"patch3\" \"patch4\" \"patch12\" ...\n\n\nNow we’ve got DE results for every gene x patch. Next comes the hard part: figuring our which results to prioritize. We recommend two approaches:\n\nFind genes that have significant and large effect sizes in at least a few patches (strong but possibly sporadic results).\nFind genes with strong meta-analysis p-values (consistent but less dramatic results). Warning: most meta-analyses, including the version demonstrated below, will assume each patch is independent. Under the realistic scenario where neighboring patches will have correlated results, this assumption fails, producing overly optimistic p-values.\n\n\n\nCode\n### prep for gene prioritization:\n\n# replace NA results - arising from all-0 expression - with 0s:\nps &lt;- replace(deres[[1]]$pvals, is.na(deres[[1]]$pvals), 1)\nests &lt;- replace(deres[[1]]$ests, is.na(deres[[1]]$pvals), 0)\nses &lt;- replace(deres[[1]]$ses, is.na(deres[[1]]$pvals), 1e6)\n\n# scale ests by genes' mean expression:\ngenefactors &lt;- pmax(Matrix::colMeans(norm[inds.tumor, ]), 0.1)\nests &lt;- sweep(ests, 1, genefactors[rownames(ests)], \"/\")\n\n### identify genes with a few strong patches:\nest.thresh &lt;- 0.5\np.thresh &lt;- 0.01\ncrit &lt;- (abs(ests) &gt; est.thresh) & (ps &lt; p.thresh)\ncritdir &lt;- 1*((ests &gt; est.thresh) & (ps &lt; p.thresh)) - 1*((ests &lt; -est.thresh) & (ps &lt; p.thresh))\ntopgenes1 &lt;- names(which(rowSums(crit) &gt;= 3))\n\n### use meta-analysis to summarize genes' trends across patches\nmetapvals &lt;- sapply(rownames(deresults[[1]]$pvals), function(gene) {\n  fit &lt;- metafor::rma.uni(yi = deresults[[1]]$ests[gene, ], \n                          sei = deresults[[1]]$ses[gene, ], \n                          method = \"REML\")\n  return(fit$pval)\n})\ntopgenes2 &lt;- setdiff(names(metapvals)[order(metapvals, decreasing = TRUE)[1:50]], NA)\n\n\nOnce you’ve prioritized genes via the above two lists (topgenes1 and topgenes2), we recommend making a heatmap of their DE results:\n\n\nCode\n## now use a heatmap to plot results from either list of top genes:\npheatmap::pheatmap((deresults[[1]]$ests * (deresults[[1]]$pvals &lt; 1e-3))[topgenes1, ],\n         col = colorRampPalette(c(\"darkblue\", \"white\", \"darkred\"))(100),\n         breaks = seq(-1, 1, length.out = 101))\n\n\n\n\n\n\n\n\n\n\n\nFrom there, it’s the usual exploration of DE results, leaning heavily on spatial plots and literature searches.\nFinally, a note on multiplicity: when we run DE across dozens of patches, the problem of multiple testing gets even worse. So, before getting excited about a single gene in a single patch, take one of these countermeasures to multiplicity:\n\nConfirm the gene x patch has a strong adjusted p-value considering all the p-values from all the genes x patches.\nConfirm the gene has a strong adjusted p-value from the metaanalysis, considering the p-values from all the genes’ metaanalysis results."
  },
  {
    "objectID": "posts/DE-guide/index.html#comment-on-statistical-power-and-false-discoveries",
    "href": "posts/DE-guide/index.html#comment-on-statistical-power-and-false-discoveries",
    "title": "Differential expression: best practices and advanced techniques",
    "section": "7 Comment on statistical power and false discoveries",
    "text": "7 Comment on statistical power and false discoveries\nVery large numbers of cells give us very high statistical power to detect even tiny effect sizes. Paradoxically, this creates a hazard for analysts, as our high statistical power applies both to real effects and to the effects of unmeasured confounding variables. Now it’s usually a safe assumption that a given gene is being influenced by a variety of factors in a tissue, many of them unmeasured and at least lightly correlated with your design variable. In other words, any given gene is likely subject to unmeasured confounding, meaning there’s a false positive signal that we are well-powered to find significant and get fooled by.\nThe countermeasure to this phenomenon is simple: don’t get excited by p-values, but rather focus on effect sizes. The stronger a gene’s fold-change with your design variable, the more likely the change you see is driven by your design variable rather than unobserved confounders. You should still apply a reasonable p-value or FDR cutoff, but beyond that cutoff you should rank genes by effect size."
  },
  {
    "objectID": "posts/DE-guide/index.html#the-limitations-of-de",
    "href": "posts/DE-guide/index.html#the-limitations-of-de",
    "title": "Differential expression: best practices and advanced techniques",
    "section": "8 The limitations of DE",
    "text": "8 The limitations of DE\nDE analyses have a tidy framework: you specify variables that you hypothesize will impact gene expression, then you look for which genes correlate with those variables. But when we look at gene expression in space, we often find variability far beyond the explanatory ability of any variables we known enough to specify. In other words, the spatial determinants of gene expression are far more complicated than the DE models we build from our limited biological knowledge. This does not mean the DE is futile - we still consider it the primary tool for wringing biology from spatial data - but it’s worth keeping some implications of this phenomenon in mind:\n\nWhen DE identifies a gene, look at its expression in space and evaluate: how much of its variability is due to your design variable? Are there other strong spatial trends that suggest a different explanation? Taking the Moran’s I stat of a gene’s residuals could also be useful:\n\n\n\nCode\ninds.tumor &lt;- meta_data$celltype == \"Tumor\"\nW &lt;- spdep::dnearneigh(xy[inds.tumor, ], 0, quantile(FNN::get.knn(xy[inds.tumor, ], k=1)$nn.dist[,1], .95))\nWl &lt;- spdep::nb2listw(W, style=\"W\", zero.policy = TRUE)\noutcome &lt;- norm[inds.tumor, \"VEGFA\"]\npredictor &lt;- dist2tcell\nspdep::moran.test(residuals(lm(outcome ~ predictor)), Wl)\n\n\n\nTo understand a tissue, you should also pursue approaches that are not limited by the design variables you specify. Look for spatial variable genes, or for spatially correlated genes, or for perturbed spatial neighborhoods. These unsupervised, exploratory approaches will reveal the strongest spatial signals in your data without requiring you to know the full set of explanatory variables a priori."
  },
  {
    "objectID": "posts/rss/index.html",
    "href": "posts/rss/index.html",
    "title": "Stay up-to-date with our blog using your favorite RSS reader",
    "section": "",
    "text": "Keeping track of our newest posts should be easier now that we have enabled RSS feeds. It’s a great way to stay up-to-date on Scratch Space and any other blog you follow. It’s also super easy to set up.\nStep 1: Click the RSS feed icon on the upper right of this post.\n\n\n\n\n\n\n\n\n\nStep 2: Select your method (e.g., Feeder).\n\n\n\n\n\n\n\n\n\nAnd that’s it! When you navigate to your RSS reader, you should see “Blog” along with your other RSS feeds."
  },
  {
    "objectID": "posts/deriving-cell-polygons-from-transcript-locations/index.html",
    "href": "posts/deriving-cell-polygons-from-transcript-locations/index.html",
    "title": "Inferring cell polygons from transcript locations",
    "section": "",
    "text": "A complete CosMx dataset will contain polygonal boundaries for each cell for use in plotting. In practice, especially with earlier datasets or with datasets passed between collaborators, this data can be missing. We’ve created a toolkit for deriving these polygons from cells’ transcript locations. (Note: we are not performing cell segmentation here, just drawing boundaries around transcripts already assigned to cells.)\nYou can find the package here.\nPlotting cells as polygons looks better in zoomed-in views, and it allows for plotting of individual transcripts as in the below:"
  },
  {
    "objectID": "posts/deriving-cell-polygons-from-transcript-locations/index.html#deriving-cell-polygons-for-plotting",
    "href": "posts/deriving-cell-polygons-from-transcript-locations/index.html#deriving-cell-polygons-for-plotting",
    "title": "Inferring cell polygons from transcript locations",
    "section": "",
    "text": "A complete CosMx dataset will contain polygonal boundaries for each cell for use in plotting. In practice, especially with earlier datasets or with datasets passed between collaborators, this data can be missing. We’ve created a toolkit for deriving these polygons from cells’ transcript locations. (Note: we are not performing cell segmentation here, just drawing boundaries around transcripts already assigned to cells.)\nYou can find the package here.\nPlotting cells as polygons looks better in zoomed-in views, and it allows for plotting of individual transcripts as in the below:"
  },
  {
    "objectID": "posts/vignette-basic-analysis-updated/01_preprocessing.html",
    "href": "posts/vignette-basic-analysis-updated/01_preprocessing.html",
    "title": "Basic analysis vignette: QC, normalization, dimension reduction and cell typing",
    "section": "",
    "text": "Here we propose an updated pipeline for basic CosMx® analysis in R, from data loading through cell typing. This workflow applies to all our RNA assays. Also see the companion posts on exploratory data analysis and confirmatory analysis with differential expression testing. A complete analysis will typically begin with the pre-processing described here, use exploratory analyses to generate hypotheses, then conclude by using differential expression analysis to test those hypotheses.\nThis code assumes a whole study can be fit into your compute environment’s memory. For very large studies, see our upcoming vignette on the topic.\nThis post is exclusively in R. Many steps have easy python analogs, but some, like the HieraType immune cell typing algorithm and the FOV QC functions, only have R implementations.\n\n\nA high-level view of our workflow is below:\n\n\n\nStep\nInputs\nOutputs\n\n\n\n\nLoad flat files\nFlat files\nRaw counts, metadata, xy\n\n\nCustomize tissues’ xy arrangement\nxy\nxy\n\n\nQC cells and FOVs\nRaw counts, metadata, xy\nRaw counts, metadata, xy (filtered)\n\n\nNormalization\nRaw counts\nNormalized counts\n\n\nDimension reduction: get HVGs\nRaw counts\nHVGs\n\n\nDimension reduction: PCA\nRaw counts, metadata, HVGs\nPCs\n\n\nDimension reduction: UMAP\nPCs\nUMAP projection, nearest neighbors\n\n\nGraph clustering (Louvain or Leiden)\nNearest neighbors\nClusters\n\n\nInSituType clustering\nRaw counts, HVGs, metadata (mean negprobe column)\nClusters\n\n\nCluster naming / marker gene ID\nClusters, raw counts\nSuggested cluster names\n\n\nCluster QC\nClusters, raw counts\nSuggested cluster names\n\n\nImmune cell typing with HieraType\nRaw counts, nearest neighbors\nHieraType calls\n\n\nHarmonize HieraType with prior clusters\nHieraType calls, clusters\nCell type calls\n\n\n\n\n\n\n\n\n\nNote on large studies\n\n\n\nWhen your data is too large to fit into memory – and this can happen with just a few slides of WTX data – At this point, we recommend the below workflow, which we will demonstrate in a separate vignette in early 2026:\n\nObtain a subsample of the larger study. This could be FOVs chosen at random from all the tissues in the study, or just the first couple slides to come off the instrument.\nUse this subsample to fix a basic pre-processing pipeline. Importantly, this pipeline has to be applicable to new samples: their data has to be projected onto the same dimension-reduced embedding, and their cell typing has to map to the cell typing of the subsample.\nApply the above pre-processing pipeline separately to each tissue/slide in the study.\nDefine an additional “hypothesis testing” pipeline, also to be applied separately to each tissue. This pipeline will compute whatever summary statistics you’re interested in, e.g. DE results, cell type abundance, LR interaction scores.\nPerform meta-analysis of every tissues’ summary statistics together. E.g. contrast DE results or cell type abundances across responders and non-responders.\nCustom subset analyses: you may also have to load in custom subsets of the data for analysis, e.g. just the macrophages from every tissue."
  },
  {
    "objectID": "posts/vignette-basic-analysis-updated/01_preprocessing.html#outline",
    "href": "posts/vignette-basic-analysis-updated/01_preprocessing.html#outline",
    "title": "Basic analysis vignette: QC, normalization, dimension reduction and cell typing",
    "section": "",
    "text": "A high-level view of our workflow is below:\n\n\n\nStep\nInputs\nOutputs\n\n\n\n\nLoad flat files\nFlat files\nRaw counts, metadata, xy\n\n\nCustomize tissues’ xy arrangement\nxy\nxy\n\n\nQC cells and FOVs\nRaw counts, metadata, xy\nRaw counts, metadata, xy (filtered)\n\n\nNormalization\nRaw counts\nNormalized counts\n\n\nDimension reduction: get HVGs\nRaw counts\nHVGs\n\n\nDimension reduction: PCA\nRaw counts, metadata, HVGs\nPCs\n\n\nDimension reduction: UMAP\nPCs\nUMAP projection, nearest neighbors\n\n\nGraph clustering (Louvain or Leiden)\nNearest neighbors\nClusters\n\n\nInSituType clustering\nRaw counts, HVGs, metadata (mean negprobe column)\nClusters\n\n\nCluster naming / marker gene ID\nClusters, raw counts\nSuggested cluster names\n\n\nCluster QC\nClusters, raw counts\nSuggested cluster names\n\n\nImmune cell typing with HieraType\nRaw counts, nearest neighbors\nHieraType calls\n\n\nHarmonize HieraType with prior clusters\nHieraType calls, clusters\nCell type calls\n\n\n\n\n\n\n\n\n\nNote on large studies\n\n\n\nWhen your data is too large to fit into memory – and this can happen with just a few slides of WTX data – At this point, we recommend the below workflow, which we will demonstrate in a separate vignette in early 2026:\n\nObtain a subsample of the larger study. This could be FOVs chosen at random from all the tissues in the study, or just the first couple slides to come off the instrument.\nUse this subsample to fix a basic pre-processing pipeline. Importantly, this pipeline has to be applicable to new samples: their data has to be projected onto the same dimension-reduced embedding, and their cell typing has to map to the cell typing of the subsample.\nApply the above pre-processing pipeline separately to each tissue/slide in the study.\nDefine an additional “hypothesis testing” pipeline, also to be applied separately to each tissue. This pipeline will compute whatever summary statistics you’re interested in, e.g. DE results, cell type abundance, LR interaction scores.\nPerform meta-analysis of every tissues’ summary statistics together. E.g. contrast DE results or cell type abundances across responders and non-responders.\nCustom subset analyses: you may also have to load in custom subsets of the data for analysis, e.g. just the macrophages from every tissue."
  },
  {
    "objectID": "posts/vignette-basic-analysis-updated/01_preprocessing.html#per-cell-qc",
    "href": "posts/vignette-basic-analysis-updated/01_preprocessing.html#per-cell-qc",
    "title": "Basic analysis vignette: QC, normalization, dimension reduction and cell typing",
    "section": "4.1 Per-cell QC:",
    "text": "4.1 Per-cell QC:\nFirst, we’ll apply a threshold on cells’ total counts. Our defaults are fairly permissive; it would be reasonable to double them in datasets where you can do so without throwing out too many cells.\n\n\nCode\n# require sufficient counts per cell \nhist(log2(metadata$nCount_RNA), breaks = 100, xlab = \"Log2 counts per cell\", ylab = \"N cells\", main = \"\")\n## cut off the low tail: \n# recommendations:\n# - 1000plex: 20 (permissive) or 50 (conservative)\n# - 6000plex: 50 (permissive) or 100 (conservative)\n# - WTX: 100 (permissive) or 200 (conservative)\n# - all panels: no more than 5% of cells (permissive) or 10% of cells (conservative)\ncount_threshold &lt;- min(200, quantile(metadata$nCount_RNA, 0.10)) # apply threshold, but don't flag &gt;10% of cells\nabline(v = log2(count_threshold), col = \"red\")\nflag &lt;- metadata$nCount_RNA &lt; count_threshold\nlegend(\"topleft\", legend = paste0(round(mean(flag) * 100, 1), \"% rejected\"))\nmean(flag)\n\n\n\n\n\n\n\n\n\n\n\nNext we’ll throw out cells with excessively large areas. In most studies, these “cells” are the result of segmentation errors. This step typically removes very few cells.\n\n\nCode\n# what's the distribution of areas?\nhist(metadata$Area, breaks = 100, xlab = \"Cell Area\", main = \"\", xlab = \"Cell area (pixels)\")\n\n# based on the above, set a threshold well out into the tail:\narea_threshold &lt;- 30000\nabline(v = area_threshold, col = \"red\")\nlegend(\"topright\", legend = paste0(round(mean(metadata$Area &gt; area_threshold) * 100, 2), \"% rejected\"))\n\n# flag cells based on area:\nflag &lt;- flag | (metadata$Area &gt; area_threshold)\nmean(flag)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nNote: some tissues do have very large cells, e.g. purkinje cells in the brain or cardiomyocytes in the heart. You’ll likely want to skip the area filter in those studies.\n\n\nTo check for segmentation errors, consider our R package FastReseg, which uses transcript positions to flag cells with likely segmentation errors, then remove or reassign transcripts assigned to the wrong cells. We also advise examining the segmentation results in AtoMx’s tissue viewer; studies will occasionally need to be re-segmented under a different set of parameters."
  },
  {
    "objectID": "posts/vignette-basic-analysis-updated/01_preprocessing.html#fov-qc",
    "href": "posts/vignette-basic-analysis-updated/01_preprocessing.html#fov-qc",
    "title": "Basic analysis vignette: QC, normalization, dimension reduction and cell typing",
    "section": "4.2 FOV QC",
    "text": "4.2 FOV QC\nWe check FOVs for two indicators of artifacts: diminished total counts, and biased gene expression profiles. Procedures for both these checks, along with a detailed discussion, can be found in a method described here.\nTo summarize briefly: for each “bit” in our barcodes (e.g. red in reporter cycle 8), we look for FOVs where genes using the bit are underexpressed. We also look for FOVs where total expression is suppressed.\nBelow we’ll run our FOV QC code and examine its results:\n\n\nCode\n## preparing resources:\n# source the FOV QC tool:\nsource(\"https://raw.githubusercontent.com/Nanostring-Biostats/CosMx-Analysis-Scratch-Space/Main/_code/FOV%20QC/FOV%20QC%20utils.R\")\n# load necessary information for the QC tool: the gene to barcode map:\nallbarcodes &lt;- readRDS(url(\"https://github.com/Nanostring-Biostats/CosMx-Analysis-Scratch-Space/raw/Main/_code/FOV%20QC/barcodes_by_panel.RDS\"))\nnames(allbarcodes)\n# get the barcodes for the panel we want:\nbarcodemap &lt;- allbarcodes$Hs_WTX    # &lt;------- choose the right map for your panel\nhead(barcodemap)\n\n## run the method:\nfovqcresult &lt;- runFOVQC(counts = counts, xy = xy, fov = metadata$FOV, barcodemap = barcodemap) \nsaveRDS(fovqcresult, file = paste0(outdir, \"/processed_data/fovqcresult.RDS\"))\n\n# map of flagged FOVs:\nmapFlaggedFOVs(fovqcresult)\n\n# list FOVs flagged for any reason, for loss of signal, for bias:\nfovqcresult$flaggedfovs\nfovqcresult$flaggedfovs_fortotalcounts\nfovqcresult$flaggedfovs_forbias\n\n# flag cells in flagged FOVs:\nflag[is.element(metadata$FOV, fovqcresult$flaggedfovs)] &lt;- TRUE\n\n# plot the result:\nFOVSignalLossSpatialPlot(fovqcresult) \n\n\n\n\n\n\n\n\n\n\n\nWe don’t have any flagged FOVs in this study. For examples of studies with more flagged FOVs, see the FOV QC post and this older vignette. The FOV signal loss plot above does show variation in signal strength, but that variation appears to track spatially smooth biology, likely contours of tumor glands, rather than sharp FOV boundaries."
  },
  {
    "objectID": "posts/vignette-basic-analysis-updated/01_preprocessing.html#descriptive-qc-plots",
    "href": "posts/vignette-basic-analysis-updated/01_preprocessing.html#descriptive-qc-plots",
    "title": "Basic analysis vignette: QC, normalization, dimension reduction and cell typing",
    "section": "4.3 Descriptive QC plots",
    "text": "4.3 Descriptive QC plots\nIn addition to the above per-cell flags, it can be worth plotting some QC metrics atop the space of your tissues. The purpose of these plots is to become aware of possible technical effects that might explain any artifacts you discover later in analysis. In the vast majority of studies, these plots will not require any action from you.\nFirst, plot total counts over space:\n\n\nCode\n## plot total counts over space:\npar(mar = c(0,0,0,0))\nplot(xy, pch = 16, cex = 0.1, asp = 1, \n     col = viridis_pal(option = \"B\")(101)[\n       round(1 + 100 * (log2(pmin(pmax(metadata$nCount_RNA, 10), 5000)) - log2(10)) / log2(5000))\n     ])\nlegendvals &lt;- c(10, 100, 1000, 5000)\nlegend(\"bottomright\", pch = 16, \n       col = c(\"white\", viridis_pal(option = \"B\")(101)[round(1 + 100 * (log2(legendvals) - log2(10)) / log2(5000))]),\n       legend = c(\"Total counts:\", legendvals))\n\n\n\n\n\n\n\n\n\n\n\nWe see ample variability in total counts over space, but it all appears biological, not technical, with the exception of some FOV edge effects in which cells partially captured at some FOV edges have suppressed counts.\nWe also like to plot background over space. Because negative control counts are so sparse at the level of single cells, we plot spatially smoothed background, i.e. we color each cell by the mean background over its 50 nearest neighbors. To isolate background tendency from overall signal strength, we also normalize our background (negprobe) counts to each cells’ total RNA counts.\n\n\nCode\n# install insitucor:\nif (FALSE) {\n  devtools::install_github(\"https://github.com/Nanostring-Biostats/InSituCor\")\n}\n\n## plot smoothed background over space:\n# get spatial neighbors:\nneighbors &lt;- InSituCor:::nearestNeighborGraph(xy[, 1], xy[, 2], N = 50, subset = metadata$slide_ID)  \n# calculate spatially-smoothed and totalcount-normalized background:\nsmoothedgbrate &lt;- InSituCor:::neighbor_mean(x = metadata$nCount_negprobes / metadata$nCount_RNA, neighbors = neighbors)\n# plot:\npar(mar = c(0,0,0,0))\nplot(xy[, 2:1], pch = 16, cex = 0.1, asp = 1, \n     col = viridis_pal(option = \"B\")(101)[\n       round(1 + 100 * pmin(smoothedgbrate / quantile(smoothedgbrate, 0.9995), 1))\n     ])\nlegendvals &lt;- signif(median(smoothedgbrate) * c(0.5,1,2,5,10), 2)\nlegend(\"bottomright\", pch = 16, \n       col = c(\"white\", viridis_pal(option = \"B\")(101)[signif(1 + 100 * pmin(legendvals / quantile(smoothedgbrate, 0.9995), 1), 2)]),\n       legend = c(\"Spatially smoothed totalcounts-normalized background:\", paste0(c(0.5,1,2,5,10), \"x median\")))\n\n\n\n\n\n\n\n\n\n\n\nWe see some regions of elevated background. No immediate action is needed, but by becoming aware of these isolated technical effects we’ll be armed to interpret any strange results driven by them. High local background often occurs in regions of necrosis.\nFinally, we plot flagged cells in space:\n\n\nCode\n# plot flagged cells in space:\npar(mar = c(0,0,0,0))\nplot(xy[, 2:1], pch = 16, cex = 0.1, asp = 1, \n     col = c(\"grey80\", \"red\")[1 + flag])\n\n\n\n\n\n\n\n\n\n\n\nWe can see flagged cells clustered in ducts/vessels/gaps in the tissue. Again, no action is needed, but we should keep this in mind while we interpret results."
  },
  {
    "objectID": "posts/vignette-basic-analysis-updated/01_preprocessing.html#removing-flagged-cells",
    "href": "posts/vignette-basic-analysis-updated/01_preprocessing.html#removing-flagged-cells",
    "title": "Basic analysis vignette: QC, normalization, dimension reduction and cell typing",
    "section": "4.4 Removing flagged cells",
    "text": "4.4 Removing flagged cells\nAs our final QC step, we remove flagged cells and save the filtered data for downstream analysis:\n\n\nCode\n# save data with flagged cells removed\ncounts &lt;- counts[!flag, ]\nmetadata &lt;- metadata[!flag, ]\nxy &lt;- xy[!flag, ]\n\n# save filtered data objects, to be used in the remainder of the analysis\nsaveRDS(counts, file = paste0(outdir, \"/processed_data/counts.RDS\"))\nsaveRDS(metadata, file = paste0(outdir, \"/processed_data/metadata.RDS\"))\nsaveRDS(xy, file = paste0(outdir, \"/processed_data/xy.RDS\"))"
  },
  {
    "objectID": "posts/vignette-basic-analysis-updated/01_preprocessing.html#unsupervised-clustering",
    "href": "posts/vignette-basic-analysis-updated/01_preprocessing.html#unsupervised-clustering",
    "title": "Basic analysis vignette: QC, normalization, dimension reduction and cell typing",
    "section": "7.1 Unsupervised clustering",
    "text": "7.1 Unsupervised clustering\nHere we demonstrate the most consistently successful approach to cell typing we have found. (Supervised cell typing with InSituType can also work quite well, but depends on a good reference marix.) First, we perform unsupervised clustering using a set of a few thousand highly variable genes (hvg’s). Second, we use the HieraType algorithm to obtain accurate immune cell classification, then overwrite our initial clustering results with HieraType’s calls wherever it finds immune cells. This approach is robust, and requires minimal configuration and re-running. Naming clusters used to be time-consuming, but we have found that the right prompts to a large language model (LLM), combined with rigorous oversight, minimize the burden of cluster naming. We will demonstrate two approaches to unsupervised clustering:\n\nLouvain clustering, using PC’s derived from Pearson residuals of hvg’s.\nInSituType’s unsupervised mode, run on hvg’s.\n\nOf the above two methods, Louvain tends to be faster, while InSituType is easier to refine, and, more importantly, straightforward to project onto future datasets. (InSituType clusters come with mean expression profiles which can be used as input to InSituType’s supervised cell typing mode.)\n\nLouvain clusteringClustering with InSituType\n\n\nNote: Here we run louvain clustering with a high resolution, intentionally over-clustering with the plan to condense afterwards. It’s often better to run with the default resolution (0.8) at first, then subcluster selected cell types afterwards. To sub-cluster a cell type, first filter out genes for which segmentation errors are likely to bias its profiles. Use smiDE::overlap_ratio_metric to do so. (smiDE is available on the scratch space.)\n\n\nCode\n# use Seurat to run Louvain clustering on the graph from our umap object\nif (TRUE) {\n  seu[[\"pearsongraph\"]] &lt;- Seurat::as.Graph(umapobj$grph) ## nearest neighbors / adjacency matrix used for unsupervised clustering\n  set.seed(0)\n  seu &lt;- Seurat::FindClusters(seu, graph = \"pearsongraph\", resolution = 1.2)  # choosing a high resolution with the plan to condense afterwards\n  clust &lt;- seu@meta.data$seurat_clusters\n  saveRDS(clust, file = paste0(outdir, \"/processed_data/clust.RDS\"))\n} else {\n  clust &lt;- readRDS(paste0(outdir, \"/processed_data/clust.RDS\"))\n}\n\n# save to metadata\nmetadata$clust &lt;- clust\n\ncellcols &lt;- rep(c(\n  \"#E41A1C\", \"#377EB8\", \"#4DAF4A\", \"#984EA3\", \"#FF7F00\",\n  \"#A65628\", \"#F781BF\", \"#999999\", \"#66C2A5\", \"#FC8D62\",\n  \"#8DA0CB\", \"#E78AC3\", \"#A6D854\", \"#FFD92F\", \"#E5C494\",\n  \"#B3B3B3\", \"#1B9E77\", \"#D95F02\", \"#7570B3\", \"#E7298A\",\n  \"#66A61E\", \"#E6AB02\", \"#A6761D\", \"#666666\", \"#A6CEE3\",\n  \"#1F78B4\", \"#B2DF8A\", \"#33A02C\", \"#FB9A99\", \"#E31A1C\",\n  \"#FDBF6F\", \"#FF7F00\", \"#CAB2D6\", \"#6A3D9A\", \"#FFFF99\",\n  \"#B15928\", \"#8DD3C7\", \"#FFFFB3\", \"#BEBADA\", \"#FB8072\"\n), 3)[1:length(unique(clust))]\n\n# Quick xy and umap plots of clusters to confirm resolution looks right:\nplot(umapobj$ump@cell.embeddings, pch = 16, asp = 1, cex = 0.1, \n     col = scales::alpha(cellcols[as.numeric(as.factor(clust))], 0.05))\nplot(xy, pch = 16, asp = 1, cex = 0.1, \n     col = cellcols[as.numeric(as.factor(clust))])\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nHere we refer you to the InSituType vignette. Running in unsupervised mode is simplest, though supervised and semi-supervised modes can work well provided with good reference profiles.\nA call to InSituType that would work with our setup here is:\n\n\nCode\nif (TRUE) {\n  set.seed(0)\n  unsup &lt;- insitutype(\n    x = counts[, hvgs],  # only use HVG's. InSituType's computation time scales with the number of genes, so analyzing the full WTX panel is very slow. \n    neg = metadata$negmean,\n    assay_type = \"RNA\", \n    reference_profiles = NULL,\n    reference_sds = NULL,\n    cohort = NULL,   # see the InSituType docs for how to use this argument to incorporate spatial information into clustering\n    n_clusts = 20,\n    n_starts = 5,\n    max_iters = 25\n  ) \n  saveRDS(unsup, file = paste0(outdir, \"/processed_data/unsup.RDS\"))\n} else {\n  unsup &lt;- readRDS(paste0(outdir, \"/processed_data/unsup.RDS\"))\n}\n# save results\nmetadata$clust &lt;- clust &lt;- unsup$clust\n\n# Quick xy and umap plots of clusters to confirm resolution looks right:\nplot(umapobj$ump@cell.embeddings, pch = 16, asp = 1, cex = 0.1, \n     col = scales::alpha(cellcols[as.numeric(as.factor(clust))], 0.05))\nplot(xy, pch = 16, asp = 1, cex = 0.1, \n     col = cellcols[as.numeric(as.factor(clust))])"
  },
  {
    "objectID": "posts/vignette-basic-analysis-updated/01_preprocessing.html#naming",
    "href": "posts/vignette-basic-analysis-updated/01_preprocessing.html#naming",
    "title": "Basic analysis vignette: QC, normalization, dimension reduction and cell typing",
    "section": "7.2 Naming clusters",
    "text": "7.2 Naming clusters\nDetermining which cell type a cluster corresponds to is a complex exercise that should take into account:\n\nThe cluster’s marker genes\nIts overall abundance\nIts spatial locations\n\nThis can be onerous, but we can get a big jump start on this work by using large language models (LLM’s). Below, we’ll create a custom prompt asking a LLM to name your cluster. We have found LLM’s to do a very good (though not perfect) job of naming cell types given this information. After this step we’ll show how to QC your cell type assignments.\nAs a first step, we’ll derive marker genes for our clusters:\n\n\nCode\nif (TRUE) {\n  markers &lt;- HieraType::clusterwise_foldchange_metrics(\n    Matrix::t(counts),\n    metadata = metadata,\n    cluster_column = \"clust\",\n    cellid_column = \"cell_id\")\n  saveRDS(markers, file = \"processed_data/markers.RDS\")\n} else {\n  markers &lt;- readRDS(\"processed_data/markers.RDS\")\n}\n\n# get a more succinct list of markers: only the top N per cell type:\n# prioritize by fold change, but penalize low-expressers:\nmarkers$prioritystat &lt;- (markers$cluster_expr + 0.025) / (markers$clusterprime_expr + 0.025)\nmarkersshort &lt;- c()\nnperclust &lt;- 5\nfor (name in unique(markers$cluster)) {\n  inds &lt;- markers$cluster == name\n  if (length(inds) &gt; 0) {\n    markersshort &lt;- c(markersshort,\n                      markers$gene[inds][order(markers$prioritystat[inds], decreasing = TRUE)[1:min(nperclust, sum(inds))]])\n  }\n}\n\n\nIn addition to data-derived marker genes, we’ll also look at a pre-defined list of well-known markers of broad cell types and lineages.\n\n\nCode\n# load general-purpose lineage and marker genes:\nsource(\"https://raw.githubusercontent.com/Nanostring-Biostats/CosMx-Analysis-Scratch-Space/Main/_code/vignette2/lineage_and_marker_genes.R\")\n# (loads the list \"lineagegenes\")\n\n# save both selected markers and lineage genes:\nallusefulmarkers &lt;- intersect(colnames(counts), unique(c(unlist(lineagegenes), markersshort)))\n\n\nNow that we have marker genes identified, we can proceed to crafting an LLM prompt:\n\n\nCode\n## describe your tissue here. \nmytissuetype &lt;- \"HER2+ breast cancer\"\n\n# the preamble:\nprompt_preamble &lt;- paste0(\n\"Please propose cell type names for the clusters I\\'ve found in a CosMx study. This is data from a \", mytissuetype, \". \",\n\"Below are two tables. The first is each cell type\\'s abundance in the dataset. \",\n\"The second is a table of mean expression levels of various marker genes and lineage-defining genes in each cluster. \",\n\"It\\'s possible that some clusters could be closely-related cell types, or distinct states of the same cell type. Call that out when it\\'s apparent. \",\n\"For each cluster, give me your best guess at its identity, and give me your justification. Let me know when you\\'re uncertain. \",\n\"Then, give me R code defining a named vector called \\'cluster_labels\\' in which my cluster IDs are the names and the values are your proposed cell types. \",\n\"Don\\'t hallucinate, and check your work three times. \")\n\n# info on cluster frequencies:\nprompt_frequencies &lt;- paste0(\n\"\nThe cluster frequencies are: \", \npaste0(paste0(\"cluster \", names(table(clust)), \":\", table(clust)), collapse = \", \"))\n\n## give the LLM each cluster's mean expression profile over relevant genes:\n\n# obtain a matrix of the clusters' marker gene profiles:\nallusefulmarkers &lt;- intersect(colnames(counts), unique(c(unlist(lineagegenes), markersshort)))\nmeanexpression &lt;- markers[, dcast(.SD, gene ~ cluster, value.var = \"cluster_expr\")]\nmeanexpression &lt;- as.matrix(meanexpression[, -1])          # drop gene col\nrownames(meanexpression) &lt;- markers[, unique(gene)]\nmeanexpression &lt;- meanexpression[allusefulmarkers, ]\n\n# reduce to just lineage genes with decent expression (but keep de novo markers):\nisdenovo &lt;- is.element(rownames(meanexpression), markersshort)\nmeanexpression &lt;- meanexpression[isdenovo | apply(meanexpression, 1, max) &gt; 0.2, ]\n\nprompt_profiles &lt;- paste0(\n  \"And here is a table of each cluster's mean expression of selected data- and biology-derived marker genes: \",\n  paste(capture.output(\n    write.table(round(meanexpression, 1), sep = \",\", row.names = TRUE, col.names = TRUE)\n  ), collapse = \"\\n\"))\n\nmessage(paste0(prompt_preamble, \"\\n\", prompt_frequencies, \"\\n\", prompt_profiles))\n\n# save old results for rewriting later on:\nunnamedclust &lt;- clust\nunnamedmeanexpression &lt;- meanexpression\n\n\nThis creates the below prompt, which can be copied into whichever LLM you prefer:\n\n\n\n\n\n\n\n\n\nWhen this prompt was passed to ChatGPT5, it produced a writeup that looked like this:\n\n\n\n\n\n\n\n\n\n… and more importantly, the below code ready to be copy-pasted into our analysis:\n\n\nCode\ncluster_labels &lt;- c(\n  \"0\"  = \"Luminal epithelial (low-RNA/quiescent)\",\n  \"1\"  = \"Neutrophils (state C, degranulating/secretory-high)\",\n  \"2\"  = \"T cells (CD4-like, resting)\",\n  \"3\"  = \"IFN-high epithelial (luminal, inflamed)\",\n  \"4\"  = \"Luminal epithelial (apocrine-leaning; state A)\",\n  \"5\"  = \"CAFs (matrix-rich fibroblasts)\",\n  \"6\"  = \"Antigen-presenting myeloid (cDC2 / moDC)\",\n  \"7\"  = \"Luminal epithelial (apocrine-high; state B)\",\n  \"8\"  = \"Luminal epithelial (apocrine-high; state C)\",\n  \"9\"  = \"Neutrophils (state B)\",\n  \"10\" = \"Luminal epithelial (apocrine-secretory)\",\n  \"11\" = \"Luminal epithelial (apocrine-high; state D)\",\n  \"12\" = \"Luminal epithelial (apocrine-very-high; state E)\",\n  \"13\" = \"Macrophages (APOE+/C1QA+ TAMs)\",\n  \"14\" = \"Neutrophils (state A; S100A8/A9-max)\",\n  \"15\" = \"Epithelial–neutrophil admixture (uncertain)\",\n  \"16\" = \"CAFs (cycling)\",\n  \"17\" = \"Endothelial (blood/lymphatic mix)\",\n  \"18\" = \"Inflamed epithelial with myeloid shadow (uncertain)\",\n  \"19\" = \"Pericytes / vascular SMC\",\n  \"20\" = \"Luminal epithelial (mucociliary-like secretory)\",\n  \"21\" = \"Cycling epithelial\",\n  \"22\" = \"Luminal epithelial (baseline state)\",\n  \"23\" = \"IFN-high epithelial (luminal, inflamed)\",\n  \"24\" = \"Luminal epithelial (mucociliary-like secretory)\",\n  \"25\" = \"Plasma cells\",\n  \"26\" = \"Antigen-presenting cells (B/cDC; cycling, uncertain)\",\n  \"27\" = \"Cytotoxic T / NK cells\"\n)\n\n# for now, just uncritically take the names. Clustering QC and possible renaming will come later.\nmetadata$clust &lt;- clust &lt;- cluster_labels[as.character(unnamedclust)]\ncolnames(meanexpression) &lt;- cluster_labels[as.character(gsub(\"cluster\", \"\", colnames(unnamedmeanexpression)))]"
  },
  {
    "objectID": "posts/vignette-basic-analysis-updated/01_preprocessing.html#clustqc",
    "href": "posts/vignette-basic-analysis-updated/01_preprocessing.html#clustqc",
    "title": "Basic analysis vignette: QC, normalization, dimension reduction and cell typing",
    "section": "7.3 QC of clustering results",
    "text": "7.3 QC of clustering results\nThe LLM gave us a good guess at cluster names, but we still need to verify them. To assist in this process, we recommend looking at 4 outputs:\n\nThe LLM’s justifications for its calls\nA heatmap of each cluster’s expression of key marker genes\nThe clusters’ distributions in space.\nThe clusters’ UMAP positions\n\nThe code below draws the key plots:\n\n\nCode\n# heatmap of marker genes - drawn tall so we can read all gene names:\ndev.off() # need to silence the current graphics device for a pheatmap pdf to render properly\npdf(paste0(outdir, \"/results/marker heatmap tall.pdf\"), height = 17, width = 6)\npheatmap::pheatmap(sweep(meanexpression, 1, pmax(0.1, apply(meanexpression, 1, max)), \"/\"),\n         col = colorRampPalette(c(\"white\", \"darkblue\"))(101),\n         fontsize_row = 6)\ndev.off()\n\n# umap positions\npng(\"results/umap_by_cluster.png\", width = 16, height = 16, units = \"in\", res = 400)\npar(mar = c(0,0,0,0))\nplot(umapobj$ump@cell.embeddings, pch = 16, asp = 1, cex = 0.1, \n     col = scales::alpha(cellcols[as.numeric(as.factor(clust))], 0.05))\nlegend(\"topleft\", pch = 16, legend = levels(as.factor(clust)), col = cellcols[1:length(levels(as.factor(clust)))])\ndev.off()\n  \n# xy positions:\nfor (name in unique(clust)) {\n  png(paste0(\"results/cluster xy - \", make.names(name), \".png\"), \n      width = diff(range(xy[, 1])) * 0.5, \n      height = diff(range(xy[, 2])) * 0.5,\n      unit = \"in\", res = 350)\n  par(mar = c(0,0,0,0))\n  plot(xy, pch = 16, cex = 0.1, \n       col = scales::alpha(cellcols, 0.3)[as.numeric(as.factor(clust))], \n       xlab = \"\", ylab = \"\", xaxt = \"n\", yaxt = \"n\")\n  points(xy[clust == name, ], pch = 16, cex = 0.1, \n         col = \"black\")\n  legend(\"top\", legend = name, bty = \"n\")\n  dev.off()\n}\n\n\nWe obtain:\nA .pdf heatmap of marker gene expression, stretched out to allow for scrutinizing gene names (not legible zoomed-out; meant to be explored via zooming and scrolling):\n\n\n\n\n\n\n\n\n\nA .png showing each cluster in umap space, giving you another look at which clusters are similar to each other:\n\n\n\n\n\n\n\n\n\nA .png for each cluster showing its positions in xy space (bold black points atop faded points for other clusters):\n\n\n\n\n\n\n\n\n\nWith these plots in hand, you should scrutinize the initial cluster names and correct as needed. Note that you can gloss over immune clusters: we’ll be overriding them later with the HieraType algorithm’s results.\nTo rename clusters, simply edit the cluster names in the definition of cluster_labels above, and re-run from that code block onward. This step can also be used to merge closely-related clusters by assigning multiple clusters the same name. In our case, we renamed three clusters of cancer cells that the LLM labeled as neutrophils (some of the classic neutrophil markers are also expressed by cancer cells).\n\n\n\n\n\n\nNote\n\n\n\nFor tumor studies, additional techniques can help classify cancer cells:\n\nCancer cells tend to be extremely transcriptionally active. Clusters with high total counts per cell are usually cancer.\nThe scMalignantFinder algorithm promises to call cells as cancer vs. non-cancer. We have not tried it, but it seems promising.\nFor WTX studies, it’s possible to estimate cells’ copy number variants. Cells with clear CNV’s will usually be cancer. We have used insituCNV successfully. A newer method, ClonalScope, also looks promising."
  },
  {
    "objectID": "posts/vignette-basic-analysis-updated/01_preprocessing.html#hieratyperun",
    "href": "posts/vignette-basic-analysis-updated/01_preprocessing.html#hieratyperun",
    "title": "Basic analysis vignette: QC, normalization, dimension reduction and cell typing",
    "section": "8.1 Running HieraType",
    "text": "8.1 Running HieraType\nWe created the HieraType algorithm to classify immune cells in a way that is informed by marker genes. We have found it to consistently outperform other algorithms in immune cell typing. Our standard approach now is to overwrite our initial clustering results with HieraType’s results whenever it calls an immune cell.\nAn important caveat: the HieraType workflow below was designed for solid tissues containing the typical infiltrating immune cell classes, i.e. everything you might expect to find in a solid tumor. For tissues with specialized immune cell types, e.g. progenitor cells, or immune-derived cancer cells, HieraType could still run but would need modifications to its marker genes / “pipeline” data object. See the HieraType package for a deeper read before setting that up.\nBelow, we run HieraType in two steps. In the first, we call broad cell types (e.g. epithelial, immune, …) then subclassify the immune cells (B, T, macrophage…)\n\n\nCode\n### set up HieraType pipeline:\npipeline_io_rna &lt;- HieraType::make_pipeline(\n  markerslists = list(\n    \"l1\" = HieraType::markerslist_l1\n    ,\"l2\" = HieraType::markerslist_immune\n  )\n  ,priors = list(\n    \"l2\" = \"l1\"\n  )\n  ,priors_category = list(\n    \"l2\" = \"immune\"\n  )\n)\n\nif (TRUE) {\n  hieratyperes &lt;- HieraType::run_pipeline(\n    pipeline = pipeline_io_rna,\n    counts_matrix = counts,\n    totalcounts = metadata$nCount_RNA,\n    adjacency_matrix = umapobj$grph[rownames(counts), rownames(counts)]\n  )\n  saveRDS(hieratyperes, file = \"processed_data/hieratyperes.RDS\")\n} else {\n  hieratyperes &lt;- readRDS(\"processed_data/hieratyperes.RDS\")\n}\n\n# further subclassify T-cells:\ntcell_ids &lt;- hieratyperes$post_probs$l1[celltype_granular==\"tcell\"][[\"cell_ID\"]]\nif (TRUE) {\n  tcell_typing &lt;- \n    HieraType::run_pipeline(\n      pipeline = HieraType::pipeline_tcell,\n      counts_matrix = counts[tcell_ids, ],\n      totalcounts = metadata$nCount_RNA,\n      adjacency_matrix = umapobj$grph[tcell_ids, tcell_ids],\n      celltype_call_threshold = 0.5\n    )\n  saveRDS(tcell_typing, file = \"processed_data/tcell_typing.RDS\")\n} else {\n  tcell_typing &lt;- readRDS(\"processed_data/tcell_typing.RDS\")\n}\n\n# unify the two levels of hieratype results:\nhtclust &lt;- hieratyperes$post_probs$l1$celltype_granular\nnames(htclust) &lt;- hieratyperes$post_probs$l1$cell_ID\nhtclust[tcell_typing$post_probs$tmajor$cell_ID] &lt;- tcell_typing$post_probs$tmajor$celltype_granular\nhtclust &lt;- htclust[match(metadata$cell_id, names(htclust))]\nmetadata$hieratype_call &lt;- htclust\n\n\nNow we’ll use a simple marker heatmap to confirm HieraType worked as hoped:\n\n\nCode\n# pull out canonical (\"index\") markers:\nindexmarkers &lt;- unique(c(\n  unlist(pipeline_io_rna$markerslists$l2)[grepl(\"index_marker\", names(unlist(pipeline_io_rna$markerslists$l2)))],\n  unlist(HieraType::pipeline_tcell)[grepl(\"index_marker\", names(unlist(HieraType::pipeline_tcell)))]\n))\n\n# make a marker heatmap for the hieratype immune cell calls:\nfcmetrics &lt;- HieraType::clusterwise_foldchange_metrics(\n  normed  = Matrix::t(norm[, indexmarkers]),\n  metadata = data.frame(\"cell_ID\" = names(htclust), \"hieratype_call\" = htclust),\n  cluster_column = \"hieratype_call\"\n)\nhm_hier &lt;- HieraType::marker_heatmap(fcmetrics, extras = NULL)\n\nprint(hm_hier)\n\n\n\n\n\n\n\n\n\n\n\nThe above heatmap doesn’t show the strongest markers; it shows the most biologically-relevant markers. We can gain further confidence in our immune cell typing results looking at data-driven markers:\n\n\nCode\nfctbl_unsup &lt;- \n  HieraType::clusterwise_foldchange_metrics(normed  = Matrix::t(norm),\n                                            metadata = data.frame(\"cell_ID\" = names(htclust), \"hieratype_call\" = htclust),\n                                            cluster_column = \"hieratype_call\"\n  )\n\n## make a marker heatmap\nhm_unsup &lt;- HieraType::marker_heatmap(fctbl_unsup)\nprint(hm_unsup)"
  },
  {
    "objectID": "posts/vignette-basic-analysis-updated/01_preprocessing.html#hieratypemerge",
    "href": "posts/vignette-basic-analysis-updated/01_preprocessing.html#hieratypemerge",
    "title": "Basic analysis vignette: QC, normalization, dimension reduction and cell typing",
    "section": "8.2 Merging clustering and HieraType results",
    "text": "8.2 Merging clustering and HieraType results\nTo finish our cell typing exercise, we now merge the Louvain and HieraType results. All cells called immune by HieraType will get HieraType labels. All other cells will retain their old labels, with one important exception: clusters that were overwhelmingly called immune by HieraType will be removed, and their cells will be assigned to whatever consensus cell type is most abundant in its nearest neighbors in expression space.\n\n\nCode\n## merge w existing clusters:\nmerged &lt;- HieraType::celltype_label_integration(\n  metadata = metadata,\n  adjacency_mat = umapobj$grph,\n  cellid_colname = \"cell_id\",\n  unsupervised_colname = \"clust\",\n  supervised_colname = \"hieratype_call\",\n  supervised_labels_keep = unique(c(names(HieraType::markerslist_immune)\n                                   ,names(HieraType::markerslist_tcellmajor)\n                                   ,names(HieraType::markerslist_cd4tminor)\n                                   ,names(HieraType::markerslist_cd8tminor))\n  ),\n  dissolve_smallcluster_if_overwritten_prop_greaterthan = c(0.9, 0.5),\n  and_dissolve_smallcluster_if_finalcluster_prop_lessthan = c(0.05, 0.01)\n)\n\ncelltype &lt;- metadata$celltype &lt;- merged$celltype[match(metadata$cell_id, merged$cell_id)]\n\n# celltype[is.element(celltype, louvain_immune_names)] &lt;- \"immune_unspecified\"\nsaveRDS(celltype, file = paste0(outdir, \"/processed_data/celltype.RDS\"))\nsaveRDS(metadata, file = paste0(outdir, \"/processed_data/metadata.RDS\"))\n\n\nOnce our cell types are complete, we re-generate the spatial plots:\n\n\nCode\n# xy positions:\nfor (name in unique(celltype)) {\n  png(paste0(\"results/celltype xy - \", make.names(name), \".png\"), \n      width = diff(range(xy[, 1])) * 0.5, \n      height = diff(range(xy[, 2])) * 0.5,\n      unit = \"in\", res = 350)\n  par(mar = c(0,0,0,0))\n  plot(xy, pch = 16, cex = 0.1, \n       col = scales::alpha(cellcols, 0.3)[as.numeric(as.factor(celltype))], \n       xlab = \"\", ylab = \"\", xaxt = \"n\", yaxt = \"n\")\n  points(xy[celltype == name, ], pch = 16, cex = 0.1, \n         col = \"black\")\n  legend(\"top\", legend = name, bty = \"n\")\n  dev.off()\n}"
  },
  {
    "objectID": "posts/marker-gene-smoothing/index.html",
    "href": "posts/marker-gene-smoothing/index.html",
    "title": "Applications for visualization and cell typing using ‘smoothed’ marker genes",
    "section": "",
    "text": "1 Introduction\nMarker genes are genes that are expressed primarily within a single cell type, and are often used to delineate and label clusters during cell typing in a scRNAseq analysis.\nWith spatially-resolved transcriptomics (SRT) data, a number of factors can contribute to challenges in a cell typing analysis, as well as hinder our ability to visualize our favorite marker genes. For example, these factors may include lower sensitivity compared to scRNAseq data, background due to autoflourescence, and segmentation error.\nA common feedback for new SRT analysts when dealing with SRT data may be along the lines of “Why don’t I see gene ‘X’ in a majority of cells for cell type ‘Y’?”.\nIn this post we’ll discuss:\n\nWhy counts of a single marker gene are not definitive of cell type\nHow to derive more useful / less noisy / “smoothed” expression of marker genes\nHow to perform fine-grained subtyping using smoothed marker genes, with T-cell subtyping as motivation\n\n\n\n2 A motivating example: Noisy T-cell typing in non-small cell lung cancer tissue\nFor example, here is a data set below consisting of non-small cell lung cancer tissues. Let’s load it in, run some quick unrefined-cell typing using InSituType (Danaher et al. 2022), and take a look at the initial results.\n\nlibrary(ggplot2)\nlibrary(ggrepel)\nlibrary(RColorBrewer)\nlibrary(data.table)\nlibrary(InSituType)\n\nsem &lt;- readRDS(\"seurat_object.Rds\")\n\n### semi-supervised cell typing with 3 unsupervised clusters, using 'ioprofiles' reference matrix\ninsitu &lt;- \nInSituType::insitutype(Matrix::t(sem[[\"RNA\"]]@counts)\n                       ,neg = Matrix::colMeans(sem[[\"negprobes\"]])\n                       ,reference_profiles = InSituType::ioprofiles\n                       ,n_clusts = 3\n                       )\n\n### clean up cell type names and save results back to seurat object\nclustdt &lt;- data.table(clust_o = insitu$clust, row.names=names(insitu$clust))\nclustdt[,clust:=clust_o]\nclustdt[grep(\"T CD4\", clust),clust:=\"T CD4\"]\nclustdt[grep(\"T CD8\", clust),clust:=\"T CD8\"]\nclustdt[grep(\"B-cell\", clust),clust:=\"B cell\"]\nclustdt[,.N,by=.(clust)]\nsem@meta.data$clust &lt;- NULL\nsem &lt;- \nSeurat::AddMetaData(sem\n                    ,data.frame(clustdt[,.(clust, clust_o)]\n                                ,row.names=names(insitu$clust)\n                                )\n                    )\n\nHere we can plot the InSituType clusters (‘clust’) on the UMAP. This UMAP was created using ‘Analytic Pearson residuals’ (Lause, Berens, and Kobak 2021).\n\n\nCode\numapf &lt;- function(umapreduc\n                  ,clustercol\n                  ,semuse\n                  ,cls=NULL\n                  ,xlim = NULL\n                  ,ylim = NULL){\n  \n  umapd &lt;-  \n    data.table(semuse@reductions[[umapreduc]]@cell.embeddings\n               ,keep.rownames = TRUE)\n  setnames(umapd, c(names(umapd)[2:3]), c(\"UMAP_1\", \"UMAP_2\"))\n  obsmrk &lt;- merge(data.table(semuse@meta.data), umapd\n                  ,by.x=\"cell_ID\"\n                  , by.y=\"rn\")\n  \n  obstxt &lt;- obsmrk[,lapply(.SD, median),by=c(clustercol),.SDcols=paste0(\"UMAP_\",1:2)]\n  \n    p &lt;- \n      ggplot(obsmrk, aes(UMAP_1, UMAP_2, color=.data[[clustercol]])) + \n      geom_point(size=0.2) + \n      theme_bw() + coord_fixed(xlim=xlim, ylim=ylim) + \n      geom_label_repel(data=obstxt, aes(x=UMAP_1, y=UMAP_2, label=.data[[clustercol]]),show.legend=FALSE\n                       ,inherit.aes=FALSE,color='black')\n    \n  if(is.null(cls)){\n    p &lt;- p +  \n      scale_color_manual(values=rep(unname(pals::alphabet()), 3)\n                         ,guide=guide_legend(override.aes=list(size=4)))\n    \n  } else {\n    p &lt;- p +  \n      scale_color_manual(values=cls\n                         ,guide=guide_legend(override.aes=list(size=4)))\n  }\n  return(p)\n}\n\n\n\nctpal &lt;- c('#C20088','#005C31','#2BCE48'\n           ,'#4C005C','#F0A0FF','#003380'\n           ,'#FFCC99','#8F7C00','#9DCC00'\n           ,'#191919','#94FFB5','#0075DC'\n           ,'#FFA8BB','#FFA405','#993F00'\n           ,'#808080')\nnames(ctpal) &lt;- c('endothelial','mDC','plasmablast'\n                  ,'b','B cell','pDC'\n                  ,'macrophage','a','mast'\n                  ,'T CD4','fibroblast','T CD8'\n                  ,'NK','Treg','neutrophil'\n                  ,'c')\numapf(\"pearsonumap\", \"clust\", sem, cls = ctpal)\n\n\n\n\n\n\n\n\n\n\nLet’s zoom in on some of the supervised clusters we hoped to identify below. We can see that some of the major cell types are somewhat clearly delineated on the UMAP.\n\nLymphocytes; T-cell types (T CD8, T CD4, and Treg) are clustered together, and near the ‘B cell’ cluster.\nMyeloid cell types; (macrophage, pDC, mDC) are clustered in a similar area.\n\nBut there does appear to potentially be some noise in delineating cell types within those major categories.\n\numapf(\"pearsonumap\", \"clust\", sem, cls = ctpal, xlim = c(-5.5, 6.5), ylim = c(-0.01, 7.2))\n\n\n\n\n\n\n\n\n\n\nWe can focus on T cells in this dataset as a driving example for using smoothing as an approach for addressing challenging cell typing and visualization problems.\nCanonical marker genes for T cells include\n\nCD3 (expected to be expressed in all T-cell types),\nCD4 (commonly used together with CD3 to identify T CD4 cells. CD4 can also be expressed in myeloid cells.)\nFOXP3 (commonly used together with CD3 to identify Treg cells. Treg cells are a special subset of T CD4 cells)\nCD8A and CD8B (used together with CD3 to identify T CD8 cells)\n\nFirst, let’s take a look at the relative frequency of our T-cell clusters ‘Treg’, ‘T CD8’, and ‘T CD4’. Tregs are supposed to be a rare sub type of T CD4 cells. Yet we have more than 3x as many Tregs called than we do T CD4.\n\n\nCode\nbard &lt;- data.table(sem@meta.data)[,.N,by=.(clust)]\nbard[,clust:=factor(clust, levels=bard[order(-N),clust])]\nggplot(bard[grep(\"^T\",clust)], aes(x=clust, y=N,fill=clust)) + \n  theme_bw() + \n  theme(text=element_text(size=16)) + \n  geom_bar(stat='identity') +\n  scale_fill_manual(values=ctpal, guide = guide_legend(reverse=TRUE)) + \n  scale_y_continuous(n.breaks=12, labels = scales::comma, name = \"# of cells\") + \n  labs(title=\"# of cells called by T cell subtype\") + \n  geom_text(aes(x=clust, y=N + 200, label=scales::comma(N))) + \n  coord_flip()\n\n\n\n\n\n\n\n\n\n\n\nDo we really have this many Treg cells in our data?\nTo gather more evidence toward answering this kind of question, we can calculate the proportion of cells in each cell type expressing a particular marker gene, along with a fold change comparison for each cluster relative to other clusters.\n\n\nCode\ntotalcount_norm &lt;- function(sm){\n    libsizes &lt;- Matrix::colSums(sm)\n    scalefactor &lt;- mean(libsizes)\n    libsizes[libsizes==0] &lt;- 1\n    normed &lt;- sm %*% Matrix::Diagonal(x=scalefactor/libsizes)\n    dimnames(normed) &lt;- dimnames(sm)\n    return(normed)\n  }\n\nclusterwise_fold_change_stats &lt;- function(cnts=NULL, normed = NULL, metainfo, clustercol){\n  if(missing(normed)){\n    normed &lt;- totalcount_norm(cnts) \n  }\n  outl &lt;- list()\n  for(ii in unique(metainfo[[clustercol]])){\n    cells_ii &lt;- metainfo[metainfo[[clustercol]]==ii,cell_ID]\n    cells_iiprime &lt;- metainfo[metainfo[[clustercol]]!=ii,cell_ID]\n    cluster_expr_ii  &lt;- Matrix::rowMeans(normed[,cells_ii,drop=FALSE])\n    cluster_expr_iiprime &lt;- Matrix::rowMeans(normed[,cells_iiprime,drop=FALSE]) \n    cluster_prop_ii &lt;- Matrix::rowMeans(normed[,cells_ii,drop=FALSE] &gt; 0) \n    cluster_prop_iiprime &lt;- Matrix::rowMeans(normed[,cells_iiprime,drop=FALSE] &gt; 0) \n    fctbl &lt;- data.table(cluster=ii\n                        ,cluster_expr = cluster_expr_ii\n                        ,clusterprime_expr = cluster_expr_iiprime\n                        ,gene = names(cluster_expr_ii)\n                        ,cluster_prop = cluster_prop_ii\n                        ,clusterprime_prop = cluster_prop_iiprime\n    )[,typ:=clustercol]\n    fctbl[,fold_change:=cluster_expr / clusterprime_expr]\n    fctbl[,fold_change_prop:=cluster_prop / clusterprime_prop]\n    outl[[paste0(ii)]] &lt;- copy(fctbl) \n  } \n  return(fc = rbindlist(outl))\n}\n\n\nWe can see that FOXP3 is expressed in a much larger frequency in Treg cells relative to other T-cell subtypes– this is good.\nHowever, only 12.7% of our Treg cells are FOXP3 positive, which may be a concern given that we have so many more Treg cells than other T-cell subtypes.\n\ncluster_level_stats &lt;-  \nclusterwise_fold_change_stats(cnts = sem[[\"RNA\"]]@counts\n                   ,metainfo = data.table(sem@meta.data)\n                   ,clustercol = \"clust\")\n\nbard &lt;- cluster_level_stats[gene==\"FOXP3\"][grep(\"^T\",cluster)]\nbard[,cluster:=factor(cluster, levels=bard[order(-cluster_prop),cluster])]\nggplot(bard, aes(x=cluster, y=cluster_prop, fill=cluster)) + \n  theme_bw() + \n  theme(text=element_text(size=16)) + \n  geom_bar(stat='identity') +\n  scale_fill_manual(values=ctpal, guide = guide_legend(reverse=TRUE)) + \n  scale_y_continuous(n.breaks=12, labels = scales::comma, name = \"Proportion of cells expressing the FOXP3 marker\") + \n  labs(title=\"FOXP3\") + \n  geom_text(aes(x=cluster, y=cluster_prop + 0.01, label=formatC(cluster_prop,3))) + \n  coord_flip()\n\n\n\n\n\n\n\n\n\n\nAt this stage, one may reasonably wonder: “If we define a Treg cell based on FOXP3 expression, why not call a cell”Treg” only if it is expressing FOXP3?”\nHere we can illustrate the challenge this would present by plotting FOXP3 expression on the UMAP. On the one hand, if we look closely, we can see what looks like might be a “hot spot” on the UMAP where we are calling Treg cells, and we also have higher FOXP3 expression.\nBut setting a threshold based on FOXP3 expression to define our Treg cells would be futile.\nWe have many cells near our ‘FOXP3 hotspot’ which may very well be Tregs, but do not have any counts of the marker gene. On the other hand, we can see cells of all types, all over the UMAP, which have one or several counts of FOXP3 expressed possibly due to some form of background.\n\n\nCode\nmarker_umap_plot &lt;- function(marker_matrix, marker, sem\n                             ,umapreduc, scale_expr = TRUE\n                             ,xlim=NULL,ylim=NULL){\n  \n  pd &lt;-  \n    data.table(sem@reductions[[umapreduc]]@cell.embeddings\n               ,keep.rownames = TRUE)\n  setnames(pd, c(names(pd)[1:3]), c(\"cell_ID\", \"UMAP_1\", \"UMAP_2\"))\n  pd[match(colnames(marker_matrix), cell_ID),(c(marker)):=marker_matrix[marker,]]\n  setkeyv(pd, marker)\n  if(scale_expr){\n    p &lt;- \n      ggplot(pd \n             ,aes(x=UMAP_1, y = UMAP_2, color=scale(.data[[marker]]))) \n      \n  } else {\n    p &lt;- \n      ggplot(pd \n             ,aes(x=UMAP_1, y = UMAP_2, color=.data[[marker]])) \n    \n  }\n  p &lt;- p +\n    geom_point(size=0.1) +\n    scale_color_gradientn(colors=brewer.pal(9, \"Reds\")) + \n    theme_bw() +\n    scale_x_continuous(n.breaks=10) + \n    scale_y_continuous(n.breaks=10) + \n    labs(title=marker) + coord_fixed(xlim=xlim,ylim=ylim) \n  return(p)\n}\n\n\n\n\nCode\nraw_foxp3_plot &lt;- \n  marker_umap_plot(sem[[\"RNA\"]]@counts, \"FOXP3\", sem, \"pearsonumap\"\n                   ,xlim = c(-5.5, 6.5), ylim = c(-0.01, 7.2),scale=FALSE) + \n    labs(title=\"raw FOXP3\")\n\nctpal_sub &lt;- ctpal\nctpal_sub[grep(\"^T\",names(ctpal_sub),invert=TRUE)] &lt;- \"grey77\"\ncowplot::plot_grid(\n  raw_foxp3_plot\n  ,umapf(\"pearsonumap\", \"clust\", sem\n         ,cls = ctpal_sub, xlim = c(-5.5, 6.5), ylim = c(-0.01, 7.2))\n  ,nrow=2\n  ) + \n  theme(plot.background = element_rect(fill = 'white',color='white')) + \n  cowplot::panel_border(remove=TRUE) \n\n\n\n\n\n\n\n\n\n\n\n\n\n3 Using ‘smoothed’ FOXP3 to highlight Treg focal point and refine cell types.\nOne potential approach to cleaning this up is to use some form of ‘smoothed’ marker gene expression, rather than the raw FOXP3 counts.\nWe can describe the calculation for ‘smoothed’ marker expression in two basic steps:\n\nFind the \\(K\\) nearest neighbors of each cell in UMAP space.\nAverage the raw (or normalized) expression of the gene across that cells nearest neighbors.\n\nThere’s a few different ways we might think about motivating this approach. The UMAP is an approximate manifold projection, which takes a low (2-d) representation of our high-dimensional (960 genes) data set. The manifold is ‘locally connected’, meaning cells near each other in UMAP space are also similar to each other in expression space. By averaging the expression of a marker gene of interest across cells with similar profiles, we can make a simple imputation of what we’d expect to see for the marker gene, given other cells of similar expression profiles.\nThis function below identifies the nearest neighbors in UMAP space, and makes a smoothing matrix, which can be used to get the average expression of any gene among a given cell’s nearest neighbors. Here is a simple implementation of the function, to take a ‘Seurat’ object as input, but could easily be modified for other data formats.\n\n## create a column-standardized nearest neighbor matrix \n## based on nearest neighbors in umap coordinates\n#' \n#' @param sem a seureat object, which contains the UMAP reduction.\n#' @param umapreduc name of the umap reduction, i.e. \"umap\"\n#' @param n_neighbor number of nearest neighbors to be identified.\n#' \n#' @return \"smoother\", a smoothing matrix. expression (genes x cells ) x  smoother(cells x cells) , \n#' will create an averaged expression across nearest neighbors.\n#' \numap_nn &lt;- function(sem, umapreduc, n_neighbors=100){\n \n  ## extract umap coordinates \n  umapd &lt;-  \n    data.table(sem@reductions[[umapreduc]]@cell.embeddings\n               ,keep.rownames = TRUE)\n  setnames(umapd, c(names(umapd)[1:3]), c(\"cell_ID\", \"UMAP_1\", \"UMAP_2\"))\n  \n  ## identify nearest n_neighbors (+1 includes the cell as a neighbor to itself)\n  nn_umap &lt;- RANN::nn2(umapd[,.(UMAP_1, UMAP_2)],k = n_neighbors + 1)$nn.idx\n  nn_umap &lt;- data.table::melt(cbind(umapd[,.(cell_ID)], data.table(nn_umap))\n                              , id.vars=c(\"cell_ID\", \"V1\"))\n  colnames(nn_umap) &lt;- c(\"cell_ID1\", \"cell_ID1_idx\", \"neighbor\", \"cell_ID2_idx\")\n  nn_umap &lt;- merge(nn_umap\n                   , nn_umap[,.(cell_ID2=cell_ID1, cell_ID2_idx=cell_ID1_idx)][\n                     ,unique(.SD)],by=\"cell_ID2_idx\")\n  \n  ## Cell x cell neighbor indicator matrix\n  wumap &lt;- Matrix::sparseMatrix(i = c(unique(nn_umap$cell_ID1_idx), nn_umap$cell_ID2_idx)\n                                ,j=c(unique(nn_umap$cell_ID1_idx), nn_umap$cell_ID1_idx)\n                                ,x=1)\n  \n  rownames(wumap) &lt;- colnames(wumap) &lt;- nn_umap[order(nn_umap$cell_ID1_idx),unique(cell_ID1)]\n  \n  ## Column standardize, so that columns (cells) sum to 1, and each neighbor given equal weight.\n  mumap &lt;- Matrix::sparseMatrix(i=1:ncol(wumap)\n                                ,j=1:ncol(wumap)\n                                ,x=1/Matrix::colSums(wumap)\n                                )\n  dimnames(mumap) &lt;- dimnames(wumap)\n  smoother &lt;- mumap %*% wumap\n  smoother &lt;- smoother[,colnames(sem)]\n  return(smoother)\n}\n\nHere, we can apply our ‘smoothing matrix’ to some T-cell marker genes and compare the difference on the UMAP. Whereas raw marker expression is noisy and sparse, smoothed expression clearly highlights the focal points for each marker on the UMAP.\n\n\nCode\nsmoother &lt;- umap_nn(sem, \"pearsonumap\", n_neighbors = 500)\nsem &lt;- SetAssayData(sem, \"data\", assay = \"RNA\", new.data = totalcount_norm(sem[[\"RNA\"]]@counts))\nsmoothed_tcell_markers &lt;- sem[[\"RNA\"]]@data[c(\"FOXP3\",\"CD3G\",\"CD8B\", \"CD4\"),] %*% smoother\n\nplist &lt;- list()\nfor(g in c(\"FOXP3\", \"CD8B\",\"CD3G\")){\n  plist[[paste0(g,\".smooth\")]] &lt;- \n    marker_umap_plot(smoothed_tcell_markers, g, sem, \"pearsonumap\"\n                     ,xlim = c(-5.5, 6.5), ylim = c(-0.01, 7.2)) + \n        labs(title=paste0(\"smooth \",g))\n  plist[[paste0(g,\".raw\")]] &lt;- \n    marker_umap_plot(sem[[\"RNA\"]]@counts, g, sem, \"pearsonumap\"\n                     ,xlim = c(-5.5, 6.5), ylim = c(-0.01, 7.2)) + \n        labs(title=paste0(\"raw \",g))\n}\ncowplot::plot_grid(plotlist=plist, nrow=3) + \n  theme(plot.background = element_rect(fill = 'white',color='white')) + \n  cowplot::panel_border(remove=TRUE) \n\n\n\n\n\n\n\n\n\n\n\nFrom here, we could take a number of different approaches to ‘clean up’ our T-cell calls. For example, because Tregs are a subset of T CD4 cells, we might consider reassigning them to T CD4 if they have low ‘smoothed FOXP3’ expression.\nBelow, we could rank the Treg cells by their smoothed FOXP3 expression, as a way of measuring our confidence in the cell type call.\nIf we kept all of our Treg cells as Tregs, then 12.7% would be FOXP3+. If we keep only the top 100 cells, 42% would be FOXP3+.\n\n\nCode\nmet &lt;- data.table(sem@meta.data)\nmet[[\"foxp3smooth\"]] &lt;- smoothed_tcell_markers[\"FOXP3\",met[[\"cell_ID\"]]]\nmet[[\"foxp3raw\"]] &lt;- sem[[\"RNA\"]]@counts[\"FOXP3\",met[[\"cell_ID\"]]]\n\n### calculate pct of actual FOXP3 positive Tregs, ranking by smoothed FOXP3\ntreg_filter &lt;- met[clust==\"Treg\"][order(-foxp3smooth)][,rnk:=1:.N]\ntreg_filter[,pct_foxp3_positive:=cumsum(foxp3raw &gt; 0)/(rnk)]\n\nggplot(treg_filter[seq(100,.N,length.out=20)]\n       ,aes(x=rnk, y=pct_foxp3_positive)) + \n  geom_bar(stat='identity') + \n  theme_bw() + \n  scale_y_continuous(n.breaks=20) + \n  scale_x_continuous(n.breaks=20) + \n  geom_text(aes(x=rnk, y=pct_foxp3_positive + 0.01, label=formatC(pct_foxp3_positive,3))) + \n  labs(title=\"Proportion of FOXP3+ Treg cells when filtering by smoothed expression\"\n       ,x=\"# of Treg cells kept\"\n       ,y=\"Proportion of FOXP3+ cells\")\n\n\n\n\n\n\n\n\n\n\n\nWe can also make a few scatter plots to show the bivariate distributions of some of these T cell markers, and color the cells by their original cell type labels. We can certainly see that each marker has a cluster of cells with strong, high-expression. On the other hand, there is a gray area at which unambiguous delineation between cell types becomes challenging.\n\n\nCode\nmet[[\"cd3gsmooth\"]] &lt;- smoothed_tcell_markers[\"CD3G\",met[[\"cell_ID\"]]]\nmet[[\"cd3graw\"]] &lt;- sem[[\"RNA\"]]@counts[\"CD3G\",met[[\"cell_ID\"]]]\nmet[[\"cd4smooth\"]] &lt;- smoothed_tcell_markers[\"CD4\",met[[\"cell_ID\"]]]\nmet[[\"cd4raw\"]] &lt;- sem[[\"RNA\"]]@counts[\"CD4\",met[[\"cell_ID\"]]]\nmet[[\"cd8bsmooth\"]] &lt;- smoothed_tcell_markers[\"CD8B\",met[[\"cell_ID\"]]]\nmet[[\"cd8braw\"]] &lt;- sem[[\"RNA\"]]@counts[\"CD8B\",met[[\"cell_ID\"]]]\n\nscatterp1 &lt;- ggplot(met, aes(cd3gsmooth, foxp3smooth,color=clust)) + \n  geom_point(size=0.2) + \n  theme_bw() + \n  scale_color_manual(values = ctpal, guide=guide_legend(override.aes=list(size=4))) + \n  theme(legend.position=\"left\") + \n  coord_fixed()\nscatterp1 &lt;- ggExtra::ggMarginal(scatterp1, type = \"histogram\")\nprint(scatterp1)\n\nscatterp2 &lt;- ggplot(met, aes(cd3gsmooth, cd8bsmooth,color=clust)) + \n  geom_point(size=0.2) + \n  theme_bw() + \n  scale_color_manual(values = ctpal, guide=guide_legend(override.aes=list(size=4))) + \n  theme(legend.position=\"left\") + \n  coord_fixed()\nscatterp2 &lt;- ggExtra::ggMarginal(scatterp2, type = \"histogram\")\nprint(scatterp2)\n\nscatterp3 &lt;- ggplot(met, aes(cd4smooth, foxp3smooth,color=clust)) + \n  geom_point(size=0.2) + \n  theme_bw() + \n  theme(legend.position=\"left\") + \n  scale_color_manual(values = ctpal, guide=guide_legend(override.aes=list(size=4))) + \n  coord_fixed()\nscatterp3 &lt;- ggExtra::ggMarginal(scatterp3, type = \"histogram\")\nprint(scatterp1)\n\n\nCD3G vs. FOXP3:\n\n\n\n\n\n\n\n\n\nCD3G vs. CD8B:\n\n\n\n\n\n\n\n\n\nCD4 vs. FOXP3:\n\n\n\n\n\n\n\n\n\nHere is a quick comparison of what the UMAP might look like after refining Tregs, using different filters.\n\n\nCode\nplist &lt;- list()\nfor(ii in c(5, 10, 15)){\n  met[,clust_filtered:=clust]\n  threshold &lt;- treg_filter[seq(100,.N,length.out=20)][ii][[\"foxp3smooth\"]]\n  met[foxp3smooth &lt;=  threshold &\n        clust_filtered==\"Treg\",clust_filtered:=\"T CD4\"]\n  sem@meta.data$clust_filtered &lt;- NULL\n  sem &lt;- Seurat::AddMetaData(sem, metadata = data.frame(met[,.(clust_filtered)], row.names = met[[\"cell_ID\"]]))\n  plist[[paste0(ii)]] &lt;- \n  umapf(\"pearsonumap\", \"clust_filtered\", sem\n         ,cls = ctpal_sub, xlim = c(-1, 3), ylim = c(2.5, 5)) + \n    labs(title=paste0(\"Filtered Tregs (smooth FOXP3 &gt; \",formatC(threshold,3), \")\")) + \n    theme(legend.position=\"none\")\n}\ncowplot::plot_grid(plotlist = plist,nrow=3) + \n  theme(plot.background = element_rect(fill = 'white',color='white')) + \n  cowplot::panel_border(remove=TRUE) \n\n\n\n\n\n\n\n\n\n\n\n\n\n4 Other marker genes\nIt may be worth mentioning that marker genes for any cell type (not just T cells) could potentially be utilized for visualization or cell type refinement.\nHere’s a few others that highlight key regions on the UMAP:\n\n\nCode\nmrks &lt;- c( \n  \"FOXP3\" \n  ,\"CTLA4\"\n  ,\"PDCD1\"\n  ,\"IL32\"\n  ,\"IL7R\"\n  ,\"CD8A\" \n  ,\"CD8B\"\n  ,\"CD3E\"\n  ,\"CD3D\"\n  ,\"CD3G\"\n  ,\"KLRK1\"\n  ,\"MS4A1\"\n  ,\"CD19\"\n  ,\"CD79A\"\n  ,\"IGKC\"\n  ,\"JCHAIN\"\n  ,\"IGHG1\"\n  ,\"IGHG2\"\n  ,\"IGHM\"\n  ,\"IGHA1\"\n  ,\"MZB1\"\n  ,\"XBP1\"\n  ,\"CLEC10A\"\n  ,\"IL1B\"\n  ,\"ITGAX\"\n  ,\"IL3RA\"\n  ,\"GZMB\"\n  ,\"GNLY\"\n  ,\"GZMA\"\n  ,\"CXCL8\"\n  ,\"CD68\"\n  ,\"CD163\"\n  ,\"C1QA\", \"C1QB\", \"C1QC\", \"LYZ\", \"MMP9\", \"IL18\"\n  ,\"VWF\", \"PECAM1\", \"RGS5\", \"SPARCL1\"\n  ,\"KRT5\", \"KRT17\", \"KRT19\", \"EPCAM\"\n  ,\"COL1A1\", \"COL1A2\", \"COL3A1\"\n  ,\"TIGIT\"\n  ,\"CPA3\", \"TPSB2\", \"TPSAB1\", \"KIT\"\n  ,\"CSF3R\"\n)\n\nsmoothed_markers &lt;- sem[[\"RNA\"]]@data[mrks,] %*% smoother\nplist &lt;- list()\nfor(g in c(\"CD68\", \"GZMA\", \"GNLY\", \"MS4A1\", \"C1QC\", \"VWF\")){\n  plist[[paste0(g,\".smooth\")]] &lt;- \n    marker_umap_plot(smoothed_markers, g, sem, \"pearsonumap\"\n                     ,xlim = c(-5.5, 6.5), ylim = c(-0.01, 7.2)) + \n        labs(title=paste0(\"smooth \",g))\n}\n  \ncowplot::plot_grid(plotlist=plist, nrow=3) + \n  theme(plot.background = element_rect(fill = 'white',color='white')) + \n  cowplot::panel_border(remove=TRUE) \n\n\n\n\n\n\n\n\n\n\n\nA clustering analysis based only on smoothed expression of known marker genes could serve as a useful aid or even a standalone approach for cell typing. For example, here is a naive k-means clustering using a number of different marker genes, and with their clusters colored on the UMAP.\n\nkmd &lt;- as.data.table(Matrix::t(smoothed_markers))\nkmd &lt;- kmd[,lapply(.SD, scale)]\nkmclus &lt;- kmeans(kmd, centers=20)\nnames(kmclus$cluster) &lt;- colnames(smoothed_markers)\nmet &lt;- data.table(sem@meta.data)\nmet[match(names(kmclus$cluster),cell_ID),kmclust:=as.character(kmclus$cluster)]\nsem@meta.data$kmclust &lt;- NULL\nsem &lt;- Seurat::AddMetaData(sem, metadata = data.frame(met[,.(kmclust)], row.names=met[[\"cell_ID\"]]))\numapf(\"pearsonumap\", \"kmclust\", sem)\n\n\n\n\n\n\n\n\n\n\n\n\n5 Conclusion\nIn this vignette, I discussed a method that can be used to get an expected expression of a marker gene in a cell, given that cell’s nearest neighbors in UMAP space, along with potential applications to visualization and cell type refinement.\n\n\n\n\n\n\n\nReferences\n\nDanaher, Patrick, Edward Zhao, Zhi Yang, David Ross, Mark Gregory, Zach Reitz, Tae K. Kim, et al. 2022. “Insitutype: Likelihood-Based Cell Typing for Single Cell Spatial Transcriptomics.” bioRxiv. https://doi.org/10.1101/2022.10.19.512902.\n\n\nLause, Jan, Philipp Berens, and Dmitry Kobak. 2021. “Analytic Pearson Residuals for Normalization of Single-Cell RNA-Seq UMI Data.” Genome Biology 22 (September): 258. https://doi.org/10.1186/s13059-021-02451-7."
  },
  {
    "objectID": "posts/big-data/index.html",
    "href": "posts/big-data/index.html",
    "title": "Big datasets: strategies for memory-efficient analysis",
    "section": "",
    "text": "CosMx data can be truly huge, containing millions of cells and thousands of genes. This prevents many typical analysis strategies, including many toolkits designed for scRNA-seq data. Here we’ll discuss ways to work with big datasets.\n\n\nNo analysis method uses all your data at once. So for any given analysis, pull in only what you need. See below for a discussion of data types and how to handle them.\n\n\nCosMx data comes several varieties:\n\n\nThese are matrices of cells * genes or cells * cells, populated mainly by 0 values. Sparse matrix formats allow us to only store information for non-zero values, greatly reducing memory demands. When working with sparse matrices, try to use methods that can act on this data type.\nExamples of sparse matrices:\n\nraw counts (sparse matrix, integers)\nnorm counts (sparse, but now decimals. can round to 3 or 4 decimal places to control size a bit)\ncells’ neighbor relationships (e.g. 50 entries per cell for 50 nearest neighbors)\n\n\n\n\nSome data is inevitably dense. Ideally, only pull this data into memory when you need it.\nExamples of dense data:\n\nCell metadata. Storing as a data table is most efficient. Since this usually has dozens of variables that are unnecessary for most analyses, you can also keep in memory only the columns you need for a given analysis.\nPrincipal components. Unavoidably large. To save memory, store only the top 20-50 PCs, throwing out the information-light remaining PCs.\n\n\n\n\n\numap\nxy locations\n\n\n\n\n\nTranscript locations. This comes in an enormous data table. In most studies you’ll want to handle this in chunks, e.g. one FOV / region at a time, or one gene.\nCell polygons. Another very large file. Since you can’t resolve polygon shapes for tens of thousands of cells at once, this data is only useful for very zoomed-in plots, allowing you to only keep say thousands of cell polygons in memory at once.\n\n\n\n\n\n\nIt doesn’t take too many slides before you can no longer fit the raw count matrix into R. At this point, you’re forced to work in batches. One good approach is to run fundamental analyses - e.g. QC, normalization, dimension reduction and cell typing - one sample at a time, saving your results to disk. Then for study-wide analyzes you can load in only the data you need, e.g. xy positions and cell types, or normalized expression values from a single gene.\n\n\n\nData formats do exist for this purpose, and they’re developing rapidly. Consider:\n\nTileDB / TileDBSOMA TileDBsc\nSeuratDisk\nSeurat v5 has some functionality for switching between disk and memory, but not yet enough to support a full spatial analysis.\n\n\n\n\nLarge datasets take time to analyze, there is no way around that, but some simple computation choices can make a big impact.\nEnsure your data stays in sparse matrix format; watch out for dense coercions. The Matrix package is great to ensure sparsity.\nParallelization is your friend but be sure to understand how much data you are reading into memory in each core. While as fast as possible is always nice, hardware does have its limitations."
  },
  {
    "objectID": "posts/big-data/index.html#strategy-1-be-intentional-about-what-data-you-bring-into-memory",
    "href": "posts/big-data/index.html#strategy-1-be-intentional-about-what-data-you-bring-into-memory",
    "title": "Big datasets: strategies for memory-efficient analysis",
    "section": "",
    "text": "No analysis method uses all your data at once. So for any given analysis, pull in only what you need. See below for a discussion of data types and how to handle them.\n\n\nCosMx data comes several varieties:\n\n\nThese are matrices of cells * genes or cells * cells, populated mainly by 0 values. Sparse matrix formats allow us to only store information for non-zero values, greatly reducing memory demands. When working with sparse matrices, try to use methods that can act on this data type.\nExamples of sparse matrices:\n\nraw counts (sparse matrix, integers)\nnorm counts (sparse, but now decimals. can round to 3 or 4 decimal places to control size a bit)\ncells’ neighbor relationships (e.g. 50 entries per cell for 50 nearest neighbors)\n\n\n\n\nSome data is inevitably dense. Ideally, only pull this data into memory when you need it.\nExamples of dense data:\n\nCell metadata. Storing as a data table is most efficient. Since this usually has dozens of variables that are unnecessary for most analyses, you can also keep in memory only the columns you need for a given analysis.\nPrincipal components. Unavoidably large. To save memory, store only the top 20-50 PCs, throwing out the information-light remaining PCs.\n\n\n\n\n\numap\nxy locations\n\n\n\n\n\nTranscript locations. This comes in an enormous data table. In most studies you’ll want to handle this in chunks, e.g. one FOV / region at a time, or one gene.\nCell polygons. Another very large file. Since you can’t resolve polygon shapes for tens of thousands of cells at once, this data is only useful for very zoomed-in plots, allowing you to only keep say thousands of cell polygons in memory at once."
  },
  {
    "objectID": "posts/big-data/index.html#strategy-2-process-each-tissue-slide-separately",
    "href": "posts/big-data/index.html#strategy-2-process-each-tissue-slide-separately",
    "title": "Big datasets: strategies for memory-efficient analysis",
    "section": "",
    "text": "It doesn’t take too many slides before you can no longer fit the raw count matrix into R. At this point, you’re forced to work in batches. One good approach is to run fundamental analyses - e.g. QC, normalization, dimension reduction and cell typing - one sample at a time, saving your results to disk. Then for study-wide analyzes you can load in only the data you need, e.g. xy positions and cell types, or normalized expression values from a single gene."
  },
  {
    "objectID": "posts/big-data/index.html#strategy-3-use-data-objects-that-handle-moving-data-between-disk-and-memory",
    "href": "posts/big-data/index.html#strategy-3-use-data-objects-that-handle-moving-data-between-disk-and-memory",
    "title": "Big datasets: strategies for memory-efficient analysis",
    "section": "",
    "text": "Data formats do exist for this purpose, and they’re developing rapidly. Consider:\n\nTileDB / TileDBSOMA TileDBsc\nSeuratDisk\nSeurat v5 has some functionality for switching between disk and memory, but not yet enough to support a full spatial analysis."
  },
  {
    "objectID": "posts/big-data/index.html#strategy-4-efficient-computing",
    "href": "posts/big-data/index.html#strategy-4-efficient-computing",
    "title": "Big datasets: strategies for memory-efficient analysis",
    "section": "",
    "text": "Large datasets take time to analyze, there is no way around that, but some simple computation choices can make a big impact.\nEnsure your data stays in sparse matrix format; watch out for dense coercions. The Matrix package is great to ensure sparsity.\nParallelization is your friend but be sure to understand how much data you are reading into memory in each core. While as fast as possible is always nice, hardware does have its limitations."
  },
  {
    "objectID": "posts/napari-alignment-tools/index.html",
    "href": "posts/napari-alignment-tools/index.html",
    "title": "Aligning H&E and CosMx Images in napari",
    "section": "",
    "text": "Aligning Hematoxylin and Eosin (H&E) histology with CosMx® Spatial Molecular Imager (SMI) data is more than a cosmetic step: it’s turning two complementary modalities into a single, interpretable picture. H&E provides the spatial scaffold which includes tissue boundaries, cell shapes, and histopathology cues, while CosMx adds the multiplexed molecular profile for each cell. When accurately aligned, these layers reinforce each other: structure informs expression, and expression validates structure. However, it’s a common challenge to align these two kinds of images as they often differ in scale, orientation, or position due to variations in acquisition methods.\nIn this tutorial, we’ll walk through how to effectively align H&E and CosMx images in napari with a two-part workflow:\n\nfirst do a quick landmark-based alignment with affinder plugin,\nthen fine tune with custom transformation widgets napari_alignment_tools for controlled micro-nudges.\n\nBy the end, you’ll be able to:\n\nLoad stitched CosMx data and matching H&E images in napari.\nPerform coarse alignment with affinder (affine/similarity/euclidean models).\nFine-tune transforms with intuitive widgets napari_alignment_tools for pixel-level adjustments.\nVerify results visually and save an aligned H&E ready for analysis.\n\nLike other items in our CosMx Analysis Scratch Space, the usual caveats and license applies."
  },
  {
    "objectID": "posts/napari-alignment-tools/index.html#set-up-general-environment",
    "href": "posts/napari-alignment-tools/index.html#set-up-general-environment",
    "title": "Aligning H&E and CosMx Images in napari",
    "section": "2.1 Set up general environment",
    "text": "2.1 Set up general environment\nIt’s recommended to create a dedicated environment for napari applications. If you already have an environment with napari and napari-cosmx plugin installed, you could just activate that environment directly and proceed to Section 2.2.\nBelow is the example command line to create virtual environment napariEnv.\n\n\n\nsetup napari environment\n\n# create environment\npython -m venv /path/to/my/napariEnv\n\n# activate environment\nsource /path/to/my/napariEnv/bin/activate   # Windows: /path/to/my/napariEnv/Scripts/activate\npip install --upgrade pip\n\n# install napari viewer\npip install \"napari[all]\"\n\n\nFollowing the instructions in earlier post, one should next install the napari-cosmx plugin from the latest wheel file for interacting with CosMx data.\nWith napari-cosmx plugin installed, one could start to prepare CosMx napari dataset and overlaying single-cell and transcriptional analysis results on top of morphological images. Please refer to earlier napari post series for more details."
  },
  {
    "objectID": "posts/napari-alignment-tools/index.html#sec-plugins",
    "href": "posts/napari-alignment-tools/index.html#sec-plugins",
    "title": "Aligning H&E and CosMx Images in napari",
    "section": "2.2 Install alignment-required plugins",
    "text": "2.2 Install alignment-required plugins\nTwo plugins are required for this tutorial:\n\naffinder and\ncustom transformation widgets napari_alignment_tools, whose wheel file .whl needs to be downloaded from here.\n\nYou can either install them via command line or in napari GUI.\nOption 1: install via command line.\n\n\n\ninstall alignment plugins\n\npip install affinder\npip install /path/to/wheel/file/napari_alignment_tools-&lt;version&gt;-py3-none-any.whl\n\n\nOption 2: install via napari GUI.\nFirst launch napari GUI by typing napari in command line, and then go to Plugins menu and follow the steps below.\n\naffindercustom napari-alignment-tools\n\n\n\n\n\n\n\n(A) Launch plugin manager; (B) Locate affinder in search box and install (red arrows). (C) The installed plugin would show up under Plugins menu when launching napari next time.\n\n\n\n\n\n\n\n\n\n\n\nFor cutom plugin, (A) launch plugin manger under Plugins menu; (B) Drag the downloaded wheel file to the bottom field and click install (yellow arrows) and watch Show Status (C) for the installation progress."
  },
  {
    "objectID": "posts/napari-alignment-tools/index.html#load-data",
    "href": "posts/napari-alignment-tools/index.html#load-data",
    "title": "Aligning H&E and CosMx Images in napari",
    "section": "4.1 Load data",
    "text": "4.1 Load data\n\nStart napari.\nLoad H&E: Drag the H&E file into napari GUI (it will be a 2D image layer), choose napari builtins reader if prompted.\nLoad CosMx dataset: Drag the pre-stitched cosmx data folder (which contents morphology image, cell segmentation, cell‑type metadata, etc.) into napari GUI, choose napari CosMx reader if prompted.\n\n\n\n\n\n\nChoose reader based on image/data type."
  },
  {
    "objectID": "posts/napari-alignment-tools/index.html#coarse-alignment-with-affinder-landmarks",
    "href": "posts/napari-alignment-tools/index.html#coarse-alignment-with-affinder-landmarks",
    "title": "Aligning H&E and CosMx Images in napari",
    "section": "4.2 Coarse alignment with affinder (landmarks)",
    "text": "4.2 Coarse alignment with affinder (landmarks)\nGoal: Compute a transform that maps the Moving H&E layer onto the Reference CosMx layer by clicking corresponding landmarks.\n\nOpen affinder: Plugins → affinder → Start affinder. A right‑dock widget appears with drop-downs listing your layers.\n\nYou can further click on the Select file field next to Save transformation as line of the widget to export the transformation matrix for future usage.\nThe widget allows 3 different transform models:\n\naffine (default): translation, rotation, scale, shear, reflection (most flexible).\nsimilarity: translation, rotation, uniform scale (shape‑preserving).\neuclidean: translation + rotation only (most rigid).\n\n\nSelect layers:\n\nReference Layer = your CosMx image (e.g., morphology or cell_type metadata image that has clear features).\nMoving Layer = your H&E image.\n\nStart point selection: Click Start in the affinder widget.\n\naffinder adds two Points layers—one for the reference, one for the moving image.\nThe viewer would focuse you on the Reference layer first. Click at least three distinct, clearly identifiable landmarks (features visible in both images) in the Reference layer.\nThe viewer would then switch focus to the Moving (H&E) layer. Click the corresponding points in the same order.\n\nTransform application: After the third pair is placed, affinder computes and applies the transform so the H&E (Moving) aligns onto the CosMx (Reference). Continue adding additional pairs (alternating layers) to refine the alignment iteratively. The more points you add, the more accurate the alignment.\nClick Finish when the coarse alignment looks good. The transformation matrix used would be saved to the file defined in step (1).\n\n\n\n\n\n\n\nImportant\n\n\n\nOrder matters! Always click correspondence points in the same order across Reference and Moving images.\n\n\n\nload data and launch affinderpoint selectionaligned image\n\n\n\n\n\n\n\nThe napari viewer has both kinds of image data loaded before starting the affinder. CosMx data layer cell_type is choosen as reference layer, while H&E image WTx_Exp-25_Colon_HE is chosen as moving layer.\n\n\n\n\n\n\n\n\n\n\n\nPairs of points are selected in the 2 layers before applying the transformation.\n\n\n\n\n\n\n\n\n\n\n\nUpon clicking Finish, the Moving layer (H&E) is now displayed in a way aligned to the Reference layer (CosMx cell_type metadata) based on the anchor points selected."
  },
  {
    "objectID": "posts/napari-alignment-tools/index.html#finetuning-with-custom-transform-widgets",
    "href": "posts/napari-alignment-tools/index.html#finetuning-with-custom-transform-widgets",
    "title": "Aligning H&E and CosMx Images in napari",
    "section": "4.3 Fine‑tuning with custom transform widgets",
    "text": "4.3 Fine‑tuning with custom transform widgets\nUse the widgets from napari_alignment_tools to make controlled adjustments after affinder’s coarse alignment.\nAs shown in figure below, there are 2 ways to open the napari_alignment_tools widgets (B):\n\nOption 1 (A): Go to napari menu, Plugins → Alignment Tools → Alignment Tool and Fine Nudge.\nOption 2 (C): Go to the the console &gt; at bottom left corner of the dataset-loaded napari viewer and run:\n\n\n\n\nadd custom widgets in napari console\n\nfrom napari_alignment_tools.widgets import add_widgets_to_viewer\nadd_widgets_to_viewer(viewer)\n\n\nThis adds two dock widgets to the right dock: Alignment Tool (for coarse parameters) and Fine Nudge (for small increments). Both widgets allow you to put in defined numbers (instead of adding points) for transformation and thus allow the alignment occur in a more controlled way.\n\n\n\n\n\nAfter loading a pre-stitched cosmx dataset in napari, one could add the custm widgets (B, to the right dock) either (A) via Plugins menu or by (C) running short python command in napari console.\n\n\n\n\n\n4.3.1 Use the Alignment Tool (top panel)\n\nLayer selection: In Alignment Tool, choose your H&E image layer (the Moving layer you want to adjust).\nAdjust as needed:\n\nRotation (−180 to 180°)\nScale Verti/Horiz (0.0001 to 1000)\nShift Verti/Horiz (−1000 to 1000 px)\nFlip Horiz/Verti (checkboxes)\n\nApply: Click Apply Alignment. Inspect by toggling visibility and using opacity sliders.\n\n\n\n4.3.2 Use the Fine Nudge Tool (micro adjustments, bottom panel)\n\nLayer selection: Choose the H&E layer.\nDirection & step size:\n\n\nPick a direction—left (Y−), right (Y+), up (X−), down (X+), rotate counter‑clockwise (Rotate−), rotate clockwise (Rotate+).\nSet the Step (e.g., 1 px for translation; 0.5–1° for rotation).\n\n\nApply Nudge, repeat this until alignment is precise.\n\n\n\n\n\n\n(A) Custom widgets from napari_alignment_tools; (B) Overlay of cell_type metadata on top of H&E image before vs. after fine-tuning; (C) Side-by-side view of the post-fine-tuned images.\n\n\n\n\n\n\n\n\n\n\nTip\n\n\n\n\nUse opacity on the H&E layer to blend with the CosMx background.\nToggle layer visibility (V) to quickly inspect.\nLink pan/zoom across layers by multi‑selecting layers and enabling Link Layers (chain icon) in the layer controls.\n\n\n\n\n\n4.3.3 Verify & save\n\nVisual checks: Zoom into salient structures (tissue boundaries, lumen edges, sharp features) and ensure edges coincide across layers.\nSave: There are a few options to save the alignment results:\n\n\nTo save high-resolution aligned H&E-CosMx images: In the napari menu, choose File -&gt; Save Screenshot or type the following command in the napari console: viewer.screenshot(\"Aligned image [file name].png\", scale = 7). Larger scale values help with generating higher resolution images.\nTo save applied alignment adjustments for reuse: right-click the H&E image layer, select Copy scale and transforms -&gt; Copy all to clipboard\n\n\n\n\n\n\nScreenshot of the dropdown menu showing how to save image transformations.\n\n\n\n\nSave the information from the clipboard, which is a Python dictionary. It will have a format similar to below:\n{\"affine\": [[1.04153992599718, -0.006080890992258121, -6.3775880232906275], [0.004057876599801822, 1.0290241905428268, -26.61572787836182], [0.0, 0.0, 1.0]], \"rotate\": [[1.0, -0.0], [0.0, 1.0]], \"scale\": [0.0017, 0.0017], \"shear\": [0.0], \"translate\": [0.0, 0.0]}\nNext time, after reloading the same H&E image, copy the saved transformation dictionary values and right-click the image layer to select Apply scale/transforms from clipboard. The exact same adjustment will be re-applied."
  },
  {
    "objectID": "posts/napari-stitching/napari-cosmx-stitching.html",
    "href": "posts/napari-stitching/napari-cosmx-stitching.html",
    "title": "Programmatic stitching with napari-cosmx",
    "section": "",
    "text": "This is the third how-to post in our napari series for CosMx® SMI data analysis. In the first post, I introduced the napari-cosmx plugin, which allows you to view and analyze CosMx SMI data exported from AtoMx® SIP. This plugin features a user-friendly GUI widget for stitching raw data, making it ideal for those without scripting experience. The second post highlighted some tips and tricks for using the plugin effectively. This post will explore programmatic stitching using Python, offering a more flexible and powerful approach for advanced users.\nStitching CosMx SMI datasets can be challenging due to their large size and the high RAM requirements of the stitching process. This is often compounded by limited storage space on local computers. While remote servers (like cloud computers) can mitigate these issues, they are often headless, making GUI-based stitching difficult. Additionally, there are situations where programmatic stitching of multiple slides is desired, bypassing the need for a GUI entirely. Finally, the current GUI-based approach within the plugin requires starting with an existing slide, as the stitching widget is only accessible after a slide is loaded. This adds an unnecessary step to the workflow.\nWhile the GUI provides a user-friendly way to stitch CosMx SMI data, it’s also possible to perform stitching programmatically. This approach offers greater flexibility and control, particularly for those comfortable with Python programming. However, it requires additional installation steps and may have higher technical barriers compared to the GUI method, which has been more extensively tested."
  },
  {
    "objectID": "posts/napari-stitching/napari-cosmx-stitching.html#create-and-activate-a-virtual-environment",
    "href": "posts/napari-stitching/napari-cosmx-stitching.html#create-and-activate-a-virtual-environment",
    "title": "Programmatic stitching with napari-cosmx",
    "section": "1.1 Create and activate a virtual environment",
    "text": "1.1 Create and activate a virtual environment\nThe exact steps needed to create a virtual environment depends on several factors and a step-by-step guide beyond the scope of this post. That said, I recommend reading this fantastic Real Python post. I’m working with Python 3.9.20 as there have been reports of breaking changes with newer Python 3.10+.\nOnce activated, install napari.\npip install \"napari[all]\"\npip install ipython # optional\npip install imageio # optional"
  },
  {
    "objectID": "posts/napari-stitching/napari-cosmx-stitching.html#install-napari-cosmx-plugin",
    "href": "posts/napari-stitching/napari-cosmx-stitching.html#install-napari-cosmx-plugin",
    "title": "Programmatic stitching with napari-cosmx",
    "section": "1.2 Install napari-cosmx plugin",
    "text": "1.2 Install napari-cosmx plugin\nDownload the whl file from the Scratch Space repository directly to your working directory via wget and then install it with pip\nwget https://github.com/Nanostring-Biostats/CosMx-Analysis-Scratch-Space/raw/refs/heads/Main/assets/napari-cosmx%20releases/napari_CosMx-0.4.17.1-py3-none-any.whl\npip install napari_CosMx-0.4.17.1-py3-none-any.whl\nAnd you can confirm that it installed when pip freeze shows the installation path.\npip freeze | grep \"napari_CosMx\"\n\nnapari-CosMx @ file:///home/ec2-user/napari_CosMx-0.4.17.0-py3-none-any.whl"
  },
  {
    "objectID": "posts/napari-stitching/napari-cosmx-stitching.html#package-scripts",
    "href": "posts/napari-stitching/napari-cosmx-stitching.html#package-scripts",
    "title": "Programmatic stitching with napari-cosmx",
    "section": "1.3 Package scripts",
    "text": "1.3 Package scripts\nWhen napari-cosmx is installed, we get a few package scripts that can be called directly. These are:\n\nstitch-images, which builds the zarr structure\nread-targets, which creates the targets.hdf5 file\n\nAssuming these are in your path, you can see their help documentation by running stitch-images --help or read-targets --help.\nstitch-images --help\nusage: stitch-images [-h] [-i INPUTDIR] [--imagesdir IMAGESDIR] [-o OUTPUTDIR] [-f OFFSETSDIR] [-l] [-u UMPERPX] [-z ZSLICE] [--dotzarr]\n\nTile CellLabels and morphology TIFFs.\n\noptional arguments:\n  -h, --help            show this help message and exit\n  -i INPUTDIR, --inputdir INPUTDIR\n                        Required: Path to CellLabels and morphology images.\n  --imagesdir IMAGESDIR\n                        Optional: Path to morphology images, if different than inputdir.\n  -o OUTPUTDIR, --outputdir OUTPUTDIR\n                        Required: Where to create zarr output.\n  -f OFFSETSDIR, --offsetsdir OFFSETSDIR\n                        Required: Path to latest.fovs.csv directory.\n  -l, --labels          \n                        Optional: Only stitch labels.\n  -u UMPERPX, --umperpx UMPERPX\n                        Optional: Override image scale in um per pixel.\n                        Instrument-specific values to use:\n                        -&gt; beta04 = 0.1228\n  -z ZSLICE, --zslice ZSLICE\n                        Optional: Z slice to stitch.\n  --dotzarr             \n                        Optional: Add .zarr extension on multiscale pyramids.\nread-targets --help\nusage: read-targets [-h] [-o OUTPUTDIR] [--filename FILENAME] folder\n\nRead decoded targets and write to hdf5\n\npositional arguments:\n  folder                Voting folder\n\noptional arguments:\n  -h, --help            show this help message and exit\n  -o OUTPUTDIR, --outputdir OUTPUTDIR\n                        Where to write hdf5 file\n  --filename FILENAME   Name for hdf5 file\nSo an example syntax might looks like this:\nstitch-images -i &lt;path to CellStats dir&gt; -f &lt;path to RunSummary dir&gt; -o &lt;path to output dir&gt;\nread-targets &lt;path to AnalysisResults/sub dir&gt; - o &lt;path to output dir&gt;"
  },
  {
    "objectID": "posts/napari-stitching/napari-cosmx-stitching.html#sec-launching-napari-cosmx-from-python",
    "href": "posts/napari-stitching/napari-cosmx-stitching.html#sec-launching-napari-cosmx-from-python",
    "title": "Programmatic stitching with napari-cosmx",
    "section": "2.1 Viewing the results",
    "text": "2.1 Viewing the results\nAs mentioned in the second napari series post, one can use python directly to view CosMx SMI data. We can also launch napari from python directly. In the code below, I instantiated a Gemini class object, turned off the segmentation and FOV labels layers, added the PanCK and DNA channels and manually adjusted the contrast of PanCK. Finally, I launched the widget for further exploration.\n\nfrom importlib.metadata import metadata\nimport numpy\nimport pandas as pd\nimport os\nfrom napari_cosmx.gemini import Gemini\nimport imageio\n\nnapari_files_path = SlideOutputDir # i.e., 'your/SlideOutputDir/from/above'\ngem = Gemini(napari_files_path)\ngem.viewer.layers['Segmentation'].visible = False\ngem.viewer.layers['FOV labels'].visible = False\ngem.add_channel('PanCK', colormap = 'green')\npanck = gem.viewer.layers['PanCK']\npanck.contrast_limits = [116.0, 5903.646408839779]\ngem.add_channel('DNA', colormap = 'bop blue')\ngem.show_widget()\n\nfig_path = napari_files_path + \"/fig-stitch-single-slide.png\"\nwith imageio.get_writer(fig_path, dpi=(800, 800)) as writer:\n        screenshot = gem.viewer.screenshot(canvas_only=False)\n        writer.append_data(screenshot)\n\n\n\n\n\n\n\nNote\n\n\n\nYou’ll note in the widget section that the Color Cells widget is blank. That’s because we didn’t create metadata for this slide (i.e., it was not present in the raw data). For an example of adding metadata, see the Adding and viewing metadata section from the first post.\n\n\n\n\n\n\n\n\n\n\nFigure 1: The output from a single slide stitching. This image represent an 8-by-8 FOV grid. PanCK and DNA are shown in green and blue, respectively."
  },
  {
    "objectID": "posts/napari-stitching/napari-cosmx-stitching.html#conclusion",
    "href": "posts/napari-stitching/napari-cosmx-stitching.html#conclusion",
    "title": "Programmatic stitching with napari-cosmx",
    "section": "3.1 Conclusion",
    "text": "3.1 Conclusion\nIn this post, I showed how to prepare napari-cosmx files folders from raw data programmatically. To do this, we used a virtual environment to install our plugin and created a script to install a single slide followed by a script to install multiple slides. I also showed how we can open a slide with napari-cosmx directly from python."
  },
  {
    "objectID": "posts/spatial-plotting/index.html",
    "href": "posts/spatial-plotting/index.html",
    "title": "Visualizing Spatial Transcriptomics: A Guide to Effective Plotting",
    "section": "",
    "text": "Spatial transcriptomics data provide rich opportunities for visual exploration. In this post, we demonstrate several useful visualizations for CosMx® data, particularly when working from flat files, and showcase a range of visualizations to highlight different aspects of CosMx data. Similar plots could be generated when working with common packages such as Seurat (Hao et al. 2024) or Squidpy (Palla et al. 2022). For more plotting ideas with these tools, see the following posts:\nPlotting with Seurat objects\nPlotting and analysis with Squidpy\nThese plots serve as a foundation for both quality control and exploratory analysis and are meant to serve as inspiration for additional plots you could make. For every plot, we show one version made in R and another made in Python; you can view the corresponding R or Python code by expanding the dropdown tab above the figure."
  },
  {
    "objectID": "posts/spatial-plotting/index.html#introduction",
    "href": "posts/spatial-plotting/index.html#introduction",
    "title": "Visualizing Spatial Transcriptomics: A Guide to Effective Plotting",
    "section": "",
    "text": "Spatial transcriptomics data provide rich opportunities for visual exploration. In this post, we demonstrate several useful visualizations for CosMx® data, particularly when working from flat files, and showcase a range of visualizations to highlight different aspects of CosMx data. Similar plots could be generated when working with common packages such as Seurat (Hao et al. 2024) or Squidpy (Palla et al. 2022). For more plotting ideas with these tools, see the following posts:\nPlotting with Seurat objects\nPlotting and analysis with Squidpy\nThese plots serve as a foundation for both quality control and exploratory analysis and are meant to serve as inspiration for additional plots you could make. For every plot, we show one version made in R and another made in Python; you can view the corresponding R or Python code by expanding the dropdown tab above the figure."
  },
  {
    "objectID": "posts/spatial-plotting/index.html#data-set-up",
    "href": "posts/spatial-plotting/index.html#data-set-up",
    "title": "Visualizing Spatial Transcriptomics: A Guide to Effective Plotting",
    "section": "2 Data set up",
    "text": "2 Data set up\nFor demonstration in this post, we use data from a breast cancer sample that has been analyzed in AtoMx® SIP through unsupervised cell typing. Many of the below plots rely on the same data objects. For convenience, we show how each of these objects are read in here and will use them in later code blocks. We also load in libraries that will be used in later sections.\n\nRPython\n\n\n\n\nCode\nlibrary(ggplot2)\nlibrary(grid)\nlibrary(data.table)\nlibrary(R.utils)\nlibrary(dplyr)\nlibrary(ggsci)\nlibrary(pals)\nlibrary(FNN)\nlibrary(viridis)\nlibrary(scales)\n\n# Define paths\nraw_data_dir &lt;- \"/path/to/raw/data\"\nout_dir &lt;- \"/path/to/out/dir\"\nslide_name &lt;- \"slideName\" # Set this to your slide name, i.e. the identifier at the front of each flat file\n\n# Read data\ncell_meta &lt;- read.csv(paste0(raw_data_dir, \"/\", slide_name, \"_metadata_file.csv.gz\")) #Note this is a small file and we read it into a data frame for convenience\ncell_polygons &lt;- fread(paste0(raw_data_dir, \"/\", slide_name, \"-polygons.csv.gz\"))\nfov_positions &lt;- fread(paste0(raw_data_dir, \"/\", slide_name, \"_fov_positions_file.csv.gz\"))\n\n\n\n\n\n\nCode\nfrom pathlib import Path\nimport os\nimport gzip\nimport subprocess\nimport io\nimport pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport matplotlib.cm as cm\nimport matplotlib.patches as mpatches\nimport matplotlib.colors as mcolors\nfrom mpl_toolkits.axes_grid1.inset_locator import inset_axes\nfrom sklearn.neighbors import NearestNeighbors\nimport string\nimport math\n\n\n# Define paths\nraw_data_dir = Path(\"/path/to/raw/data\")\nout_dir = Path(\"/path/to/out/dir\")\nslide_name = \"slideName\"\n\n# Read data\ncell_meta = pd.read_csv(raw_data_dir / f\"{slide_name}_metadata_file.csv.gz\")\ncell_polygons = pd.read_csv(raw_data_dir / f\"{slide_name}-polygons.csv.gz\")\nfov_positions = pd.read_csv(raw_data_dir / f\"{slide_name}_fov_positions_file.csv.gz\")\n\n\n\n\n\n\n2.1 Scale Bar Function\nBecause the majority of these plots are spatial plots, we’ll often want to include a scale bar. Rather than showing how to make that scale bar for every plot, we write two quick general functions (R and python versions) here at the beginning to make a nice scale bar and reuse these functions throughout this post.\nAdditionally, all the code here is designed to work from positions given in pixels, as they are in default flat files. If you have positions in mm you’ll want to adjust accordingly, primarily in the scale bar function.\n\nRPython\n\n\n\n\nCode\n## Set up scale bar function\n\nmake_scale_bar_r &lt;- function(x_vals, y_vals, microns_per_pixel = 0.12028) {\n  \n  # Adds a scale bar to a ggplot.\n\n    #Parameters:\n      #x_vals: vector of x coordinates in pixels\n      #y_vals: vector of y coordinates in pixels\n      #microns_per_pixel: conversion factor from pixels to microns. Default is conversion factor for commercial CosMx instrument\n   \n  # Example usage:\n    # scale_bar = make_scale-bar_r(x_vals = cell_meta$CenterX_global_px, y_vals = cell_meta$CenterY_global_px)\n    # ggplot() + scale_bar$bg + scale_bar$rect + scale_bar$label\n  \n  \n  # Calculate x-axis range\n  x_range &lt;- range(x_vals, na.rm = TRUE)\n  x_length &lt;- diff(x_range)\n  x_length_um &lt;- x_length * microns_per_pixel\n  \n  # Target scale length ~1/4 of the x-axis\n  target &lt;- x_length_um / 4\n  \n  # Compute order of magnitude\n  order &lt;- 10^floor(log10(target))\n  mantissa &lt;- target / order\n  \n  # Round mantissa to nearest 1, 2, or 5\n  nice_mantissa &lt;- if (mantissa &lt; 1.5) {\n    1\n  } else if (mantissa &lt; 3.5) {\n    2\n  } else if (mantissa &lt; 7.5) {\n    5\n  } else {\n    10\n  }\n  \n  # Final scale length in pixels\n  scale_length_um &lt;- nice_mantissa * order\n  scale_length_px &lt;- scale_length_um / microns_per_pixel\n  \n  # Format label\n  scale_label &lt;- if (scale_length_um &gt;= 1000) {\n    paste0(scale_length_um / 1000, \" mm\")\n  } else {\n    paste0(scale_length_um, \" µm\")\n  }\n  \n  # Set coordinates for the scale bar \n  x_start &lt;- x_range[2] - scale_length_px * 1.1\n  x_end &lt;- x_range[2] - scale_length_px * 0.1\n  y_pos &lt;- min(y_vals, na.rm = TRUE) + scale_length_px * 0.1\n\n  # Generate scale bar background, scale bar and annotation to return\n  list(\n    bg = annotation_custom(\n    grob = rectGrob(gp = gpar(fill = \"white\", alpha = 0.8, col = NA)),\n    xmin = x_start- scale_length_px*0.05, xmax = x_end+ scale_length_px*0.05,\n    ymin = y_pos- scale_length_px*0.05, ymax = y_pos + scale_length_px*0.3\n  ),\n    rect = annotation_custom(\n      grob = rectGrob(gp = gpar(fill = \"black\")),\n      xmin = x_start, xmax = x_end,\n      ymin = y_pos, ymax = y_pos + scale_length_px * 0.05\n    ),\n    label = annotation_custom(\n      grob = textGrob(scale_label, gp = gpar(col = \"black\"), just = \"center\", vjust = 0),\n      xmin = (x_start + x_end)/2, xmax = (x_start + x_end)/2,\n      ymin = y_pos + scale_length_px * 0.1, ymax = y_pos + scale_length_px * 0.1\n    )\n  )\n}\n\n\n\n\n\n\nCode\n## Set up scale bar function\n\ndef make_scale_bar_py(ax, x_coords, y_coords, microns_per_pixel=0.12028):\n    \"\"\"\n    Adds a scale bar to a matplotlib plot.\n\n    Parameters:\n    - ax: matplotlib Axes object\n    - x_coords: list or array of x coordinates\n    - y_coords: list or array of y coordinates\n    - microns_per_pixel: conversion factor from pixels to microns. Default is conversion factor for commercial CosMx instrument\n    \n    Example usage:\n    - fig, ax = plt.subplots()\n    - ax.scatter(x, y)\n    - make_scale_bar_py(ax, microns_per_pixel, x, y)\n\n    \"\"\"\n    # Calculate x-axis range\n    x_range = [min(x_coords), max(x_coords)]\n    x_length = x_range[1] - x_range[0]\n    x_length_um = x_length * microns_per_pixel\n\n    # Target scale length ~1/4 of the x-axis\n    target = x_length_um / 4\n\n    # Compute order of magnitude\n    order = 10 ** np.floor(np.log10(target))\n    mantissa = target / order\n\n    # Round mantissa to nearest 1, 2, or 5\n    if mantissa &lt; 1.5:\n        nice_mantissa = 1\n    elif mantissa &lt; 3.5:\n        nice_mantissa = 2\n    elif mantissa &lt; 7.5:\n        nice_mantissa = 5\n    else:\n        nice_mantissa = 10\n\n    # Final scale length in pixels\n    scale_length_um = nice_mantissa * order\n    scale_length_px = scale_length_um / microns_per_pixel\n\n    # Format label\n    if scale_length_um &gt;= 1000:\n        scale_label = f\"{scale_length_um / 1000:.1f} mm\"\n    else:\n        scale_label = f\"{scale_length_um:.0f} µm\"\n\n    # Set coordinates for the scale bar\n    x_start = x_range[1] - scale_length_px * 1.1\n    x_end = x_range[1] - scale_length_px * 0.1\n    y_pos = min(y_coords) + scale_length_px * 0.1\n    \n    # Set up background for scale bar\n    scale_bg = mpatches.Rectangle(\n        (x_start - scale_length_px * 0.05, y_pos - scale_length_px * 0.05),\n        width=(x_end - x_start) + scale_length_px * 0.1,\n        height=scale_length_px * 0.4,\n        color='white', alpha=0.8,\n        zorder = 10\n    )\n    \n    # Add background\n    ax.add_patch(scale_bg)\n\n    # Draw scale bar\n    ax.plot([x_start, x_end], [y_pos, y_pos], color='black', linewidth=2, zorder=11)\n    ax.text((x_start + x_end) / 2, y_pos + scale_length_px * 0.1, scale_label,\n            color='black', ha='center', va='bottom', zorder=12)"
  },
  {
    "objectID": "posts/spatial-plotting/index.html#plotting-data-in-space",
    "href": "posts/spatial-plotting/index.html#plotting-data-in-space",
    "title": "Visualizing Spatial Transcriptomics: A Guide to Effective Plotting",
    "section": "3 Plotting Data in Space",
    "text": "3 Plotting Data in Space\nSpatial transcriptomics unlocks the ability to visualize gene expression in its native tissue context. In this section, we explore a variety of spatial plots, from full tissue views to single FOVs or smaller, and from cell outlines to transcript overlays, highlighting different ways to represent spatial data.\n\n3.1 Cell Positions\nVisualize cell centroids from the cell metadata file. This shows a broad overview of the tissue structure. We start with all cells colored grey.\n\nRPython\n\n\n\n\nCode\n## Set up scale bar\nscale_bar &lt;- make_scale_bar_r(x_vals = cell_meta$CenterX_global_px,\n                            y_vals = cell_meta$CenterY_global_px)\n\n## Plot it\nggplot(cell_meta,\n       aes(x = CenterX_global_px, y = CenterY_global_px)) +\n  geom_point(color = \"grey\", size = 0.1, alpha = 0.05) +\n  coord_fixed() + # Fix aspect ratio\n  theme_void() +\n  scale_bar$bg +\n  scale_bar$rect +\n  scale_bar$label\n  \nggsave(paste0(out_dir, \"cell_positions.png\"),\n       width = 4, height = 6, units = \"in\")\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\n## Create the scatter plot\nfig, ax = plt.subplots(figsize=(4, 6))\nax.scatter(\n    cell_meta[\"CenterX_global_px\"],\n    cell_meta[\"CenterY_global_px\"],\n    color=\"grey\",\n    s=0.1,\n    alpha=0.05\n)\nax.set_aspect('equal', adjustable='box') # Fix aspect ratio\nax.axis('off')  # Removes axes and grid\n\n# Add scale bar\nmake_scale_bar_py(ax, cell_meta[\"CenterX_global_px\"], cell_meta[\"CenterY_global_px\"])\n\n# Save the figure\nplt.savefig(os.path.join(out_dir, \"python_cell_positions.png\"), bbox_inches='tight', pad_inches=0, dpi=300)\nplt.close()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n3.2 Cell Polygons\nTo illustrate cell boundaries, we plot polygon outlines derived from the polygon flat files. These visualizations are most informative when zoomed in, so we focus on a single FOV where individual cell shapes are more discernible.\n\n\n\n\n\n\nNote on Polygon Flat Files\n\n\n\nThe polygon flat file encodes each cell’s shape using a simplified set of vertices. As a result, some cells may appear to overlap when plotted—this is a visual artifact caused by rounding during polygon generation.\nImportantly, the actual segmentation used for transcript assignment does not contain overlapping cell borders. The cell boundaries are sampled using a convex hull to minimize the number of points in the polygons flat file. This file is intended to provide a rough approximation of cell shapes, which is why convex hull simplification may introduce overlaps.\nFor precise cell boundaries, refer to the CellLabels_F#####.TIF file, which defines borders at the per-pixel level.\n\n\n\nRPython\n\n\n\n\nCode\n## Set up scale bar\nscale_bar &lt;- make_scale_bar_r(x_vals = cell_polygons %&gt;% filter(fov == 100) %&gt;% pull(x_global_px),\n                            y_vals =  cell_polygons %&gt;% filter(fov == 100) %&gt;% pull(y_global_px))\n## Plot it\nggplot(cell_polygons %&gt;% filter(fov == 100), # Select cells in FOV 100\n       aes(x = x_global_px, y = y_global_px, group = cell)) +\n  geom_polygon(fill = NA, color = \"black\") +\n  coord_fixed() +\n  theme_void() +\n  scale_bar$bg +\n  scale_bar$rect +\n  scale_bar$label\n  \nggsave(paste0(out_dir, \"cell_outlines_singleFOV.png\"),\n       width = 4, height = 4, units = \"in\")\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\n# Filter data for FOV 100\nfiltered_data = cell_polygons[cell_polygons[\"fov\"] == 100]\n\n## Create the polygon plot\nfig, ax = plt.subplots(figsize=(4, 4))\n\nfor key, group in filtered_data.groupby(\"cell\"):\n  ax.plot(group[\"x_global_px\"], group[\"y_global_px\"], color=\"black\", zorder=1)\n    \nax.set_aspect('equal', adjustable='box')\nax.axis('off')  # Removes axes and grid\n\n# Add scale bar\nmake_scale_bar_py(ax, filtered_data[\"x_global_px\"], filtered_data[\"y_global_px\"])\n\n# Save the figure\nplt.savefig(os.path.join(out_dir, \"python_cell_outlines_singleFOV.png\"), bbox_inches='tight', pad_inches=0, dpi=300)\nplt.close()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n3.3 Color Cells by Metadata\nOverlay polygons with metadata such as cell type. Here, we use results from Leiden clustering. Throughout the post, we showcase a variety of color palettes. When only a few colors are needed, we aim for consistency between R and Python plots. In cases requiring many colors, we highlight diverse palette options, which may differ across the two languages.\n\n\n\n\n\n\nNote\n\n\n\nThere are a small number of cells with no associated cell type as they got flagged in QC. These show up as NA in the plots.\n\n\n\nRPython\n\n\n\n\nCode\n## Add cell type to polygons\nplot.df &lt;- cell_polygons %&gt;% filter(fov == 100) %&gt;% as.data.frame()\nmeta &lt;- as.data.frame(cell_meta)\nrow.names(meta) &lt;- meta$cell\nplot.df$cell_type &lt;- as.data.frame(meta)[plot.df$cell, \"leiden_cluster\"]\n\n## Set up scale bar\nscale_bar &lt;- make_scale_bar_r(x_vals = plot.df %&gt;% pull(x_global_px),\n                            y_vals =  plot.df %&gt;% pull(y_global_px))\n\n## Plot it\nggplot(plot.df,\n       aes(x = x_global_px, y = y_global_px, \n           group = cell, # Group cells for polygons\n           fill = as.factor(cell_type))) + # Polygon fill by cell type\n  geom_polygon(color = \"black\", linewidth = 0.3) +\n  scale_fill_ucscgb() + #Palette inspired by UCSB Genome Browser\n  coord_fixed() +\n  theme_void() +\n  labs(fill = \"Cell type\") +\n  scale_bar$bg +\n  scale_bar$rect +\n  scale_bar$label\n  \nggsave(paste0(out_dir, \"celltype_polygons_singleFOV.png\"),\n       width = 6, height = 4, units = \"in\")\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\n# Filter for FOV 100\nplot_df = cell_polygons[cell_polygons[\"fov\"] == 100]\n\n# Merge only the 'leiden_cluster' column\nmeta_subset = cell_meta[['cell', 'leiden_cluster']]\nplot_df = plot_df.merge(meta_subset, on='cell', how='left')\n\n# Create a colormap\nclusters = plot_df[\"leiden_cluster\"].unique()\n\n# Filter out NA values first\nvalid_clusters = [c for c in clusters if pd.notna(c)]\n\ncmap = cm.get_cmap(\"tab20\", len(valid_clusters))\ncluster_to_color = {cluster: cmap(i) for i, cluster in enumerate(valid_clusters)}\n\n#Add color for NA values\ncluster_to_color[np.nan] = \"lightgrey\"\n\n## Create the polygon plot\nfig, ax = plt.subplots(figsize=(6, 4))\n\nfor key, group in plot_df.groupby(\"cell\"): # Iterate through each cell\n    cluster = group[\"leiden_cluster\"].iloc[0]\n    color = cluster_to_color[np.nan] if pd.isna(cluster) else cluster_to_color[cluster]\n    coords = group[[\"x_global_px\", \"y_global_px\"]].values\n    coords = np.vstack([coords, coords[0]])  # close the polygon\n    ax.fill(coords[:, 0], coords[:, 1], facecolor=color, edgecolor=\"black\", linewidth=0.5, zorder=1)\n\n\nax.set_aspect('equal', adjustable='box')\nax.axis('off')  # Removes axes and grid\n\n# Add scale bar\nmake_scale_bar_py(ax, plot_df[\"x_global_px\"], plot_df[\"y_global_px\"])\n\n# Create legend handles\nlegend_handles = [\n    mpatches.Patch(\n      color=color, \n      label=f\"Cluster {int(cluster)}\" if pd.notna(cluster) else \"Cluster NA\")\n    for cluster, color in cluster_to_color.items()\n]\n\n# Add legend to the right\nax.legend(\n  handles=legend_handles, \n  title=\"Cell type\", \n  bbox_to_anchor=(1.05, 1), \n  loc='upper left',\n  fontsize=6,\n  title_fontsize=8)\n\n# Save\nplt.savefig(os.path.join(out_dir, \"python_celltype_polygons_singleFOV.png\"), bbox_inches='tight', pad_inches=0, dpi=300)\nplt.close()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n3.4 Highlight One Cell Type\nHere we change the color on a single cell type, designated as tumor subtype A, to highlight these cells.\n\nRPython\n\n\n\n\nCode\n## Add cell type to polygons\nplot.df &lt;- cell_polygons %&gt;% filter(fov == 100) %&gt;% as.data.frame()\nmeta &lt;- as.data.frame(cell_meta)\nrow.names(meta) &lt;- meta$cell\nplot.df$cell_type &lt;- as.data.frame(meta)[plot.df$cell, \"leiden_cluster\"] \n\n## Select cells to highlight\nplot.df$highlight &lt;- ifelse(plot.df$cell_type == \"5\", \"Tumor A\", \"Other\")\n\n## Set up scale bar\nscale_bar &lt;- make_scale_bar_r(x_vals = plot.df %&gt;% pull(x_global_px),\n                            y_vals =  plot.df %&gt;% pull(y_global_px))\n\n\n## Plot it\nggplot(plot.df,\n       aes(x = x_global_px, y = y_global_px, group = cell,\n           fill = highlight)) +\n  geom_polygon(color = \"darkgrey\", linewidth = 0.3) +\n  scale_fill_jco() + # Use a color palette from JCO (Journal of Clinical Oncology)\n  coord_fixed() +\n  theme_void() +\n  labs(fill = \"Cell type\") +\n  scale_bar$bg +\n  scale_bar$rect +\n  scale_bar$label\n \nggsave(paste0(out_dir, \"celltypeHighlight_polygons_singleFOV.png\"),\n       width = 6, height = 4, units = \"in\")\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\n# Filter for FOV 100\nplot_df = cell_polygons[cell_polygons[\"fov\"] == 100]\n\n# Merge only the 'leiden_cluster' and 'nCount_RNA' columns\nmeta_subset = cell_meta[['cell', 'leiden_cluster', 'nCount_RNA']]\nplot_df = plot_df.merge(meta_subset, on='cell', how='left')\n\n# Add highlight column\nplot_df['highlight'] = np.where(plot_df['leiden_cluster'] == 5, 'Tumor A', 'Other')\n\n## Plot\nfig, ax = plt.subplots(figsize=(6, 6))\nfor key, group in plot_df.groupby(\"cell\"):\n    highlight = group[\"highlight\"].iloc[0]\n    fill_color = '#EFC000' if highlight == 'Tumor A' else '#0073C2' # Fill color logic, matching blue / yellow shown in R plot\n    coords = group[[\"x_global_px\", \"y_global_px\"]].values\n    coords = np.vstack([coords, coords[0]])  # close the polygon\n    ax.fill(coords[:, 0], coords[:, 1], facecolor=fill_color, edgecolor='darkgrey', linewidth=0.5, zorder = 1)\n\nax.set_aspect('equal')\nax.axis('off')\n\n# Add scale bar\nmake_scale_bar_py(ax, plot_df[\"x_global_px\"], plot_df[\"y_global_px\"])\n\n# Legend\nlegend_handles = [\n    mpatches.Patch(color='#0073C2', label='Tumor A'),\n    mpatches.Patch(color='#EFC000', label='Other')\n]\nax.legend(handles=legend_handles, title=\"Cell type\", bbox_to_anchor=(1.05, 1), loc='upper left')\n\nplt.savefig(os.path.join(out_dir, \"python_celltypeHighlight_polygons_singleFOV.png\"), bbox_inches='tight', pad_inches=0, dpi=300)\nplt.close()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n3.5 Mute Background Cells\nAs an alternative, we can highlight one cell type by muting the color for all others. However, keep in mind that when many colors are present, muting can reduce contrast and make distinctions harder to perceive. To improve interpretability, consider grouping cells into 5–10 major types or manually assigning similar hues to related cell types. As another option, color the cells of interest black, which may allow you to mute other colors less.\n\nRPython\n\n\n\n\nCode\n## Add cell type to polygons\nplot.df &lt;- cell_polygons %&gt;% filter(fov == 100) %&gt;% as.data.frame()\nmeta &lt;- as.data.frame(cell_meta)\nrow.names(meta) &lt;- meta$cell\nplot.df$cell_type &lt;- as.data.frame(meta)[plot.df$cell, \"leiden_cluster\"] \n\n## Set alpha by cell type\nalpha_vals &lt;- rep(0.2, length(unique(plot.df$cell_type)))\nnames(alpha_vals) &lt;- c(unique(plot.df$cell_type))\nalpha_vals[\"5\"] &lt;- 1\n\n## Set up scale bar\nscale_bar &lt;- make_scale_bar_r(x_vals = plot.df %&gt;% pull(x_global_px),\n                            y_vals =  plot.df %&gt;% pull(y_global_px))\n\n## Plot it\nggplot(plot.df,\n       aes(x = x_global_px, y = y_global_px, group = cell,\n           fill = as.factor(cell_type), alpha = as.factor(cell_type))) +\n  geom_polygon(color = \"darkgrey\", linewidth = 0.3) +\n  scale_fill_d3(palette = \"category20\", na.value = \"lightgrey\") + # Inspired by colors in the D3 visualization library\n  coord_fixed() +\n  theme_void() +\n  labs(fill = \"Cell type\", alpha = \"Cell type\") +\n  scale_alpha_manual(values = alpha_vals, na.value = 0.2) + # Adjust opacity by cell type\n  scale_bar$bg +\n  scale_bar$rect +\n  scale_bar$label\n  \nggsave(paste0(out_dir, \"celltypeAlphaHighlight_polygons_singleFOV.png\"),\n       width = 6, height = 4, units = \"in\")\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\n# Filter for FOV 100\nplot_df = cell_polygons[cell_polygons[\"fov\"] == 100]\n\n# Merge only the 'leiden_cluster' column\nmeta_subset = cell_meta[['cell', 'leiden_cluster']]\nplot_df = plot_df.merge(meta_subset, on='cell', how='left')\n\n# Create a colormap\nclusters = plot_df[\"leiden_cluster\"].unique()\n\n# Filter out NA values first\nvalid_clusters = [c for c in clusters if pd.notna(c)]\n\ncmap = cm.get_cmap(\"Set3\", len(valid_clusters)) #Use matplotlib's Set3 palette\ncluster_to_color = {cluster: cmap(i) for i, cluster in enumerate(valid_clusters)}\n\n#Add color for NA values\ncluster_to_color[np.nan] = \"lightgrey\"\n\n# Add alpha column\nplot_df['alpha'] = np.where(plot_df['leiden_cluster'] == 5, 1, 0.3)\n\n## Plot\nfig, ax = plt.subplots(figsize=(6, 6))\nfor key, group in plot_df.groupby(\"cell\"):\n    cell_type = group[\"leiden_cluster\"].iloc[0]\n    alpha = group[\"alpha\"].iloc[0]\n    fill_color = cluster_to_color[np.nan] if pd.isna(cell_type) else cluster_to_color[cell_type]\n    coords = group[[\"x_global_px\", \"y_global_px\"]].values\n    coords = np.vstack([coords, coords[0]])  # close the polygon\n    ax.fill(coords[:, 0], coords[:, 1], facecolor=fill_color, edgecolor='darkgrey', linewidth=0.5, alpha=alpha, zorder=1)\n\nax.set_aspect('equal')\nax.axis('off')\n\n# Add scale bar\nmake_scale_bar_py(ax, plot_df[\"x_global_px\"], plot_df[\"y_global_px\"])\n\n# Legend for fill colors\nunique_clusters = plot_df[\"leiden_cluster\"].unique()\nlegend_handles = [\n    mpatches.Patch(\n      color=color, \n      label=f\"Cluster {int(cluster)}\" if pd.notna(cluster) else \"Cluster NA\",\n      alpha = 1 if cluster == 5 else 0.3)\n    for cluster, color in cluster_to_color.items()\n]\nax.legend(\n  handles=legend_handles, \n  title=\"Cell type\", \n  bbox_to_anchor=(1.05, 0.95), \n  loc='upper left',\n  fontsize = 6,\n  title_fontsize=8)\n\nplt.savefig(os.path.join(out_dir, \"python_celltypeAlphaHighlight_polygons_singleFOV.png\"), bbox_inches='tight', pad_inches=0, dpi=300)\nplt.close()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n3.6 Dynamically Color One Cell Type\nSometimes we want to highlight metadata about a single cell type, such as counts per cell specifically for tumor cells. To do this, we can set all other cells to a background color such as light grey and then dynamically color the cells of interest.\n\nRPython\n\n\n\n\nCode\n## Add cell type and counts to polygons\nplot.df &lt;- cell_polygons %&gt;% filter(fov == 100) %&gt;% as.data.frame()\nmeta &lt;- as.data.frame(cell_meta)\nrow.names(meta) &lt;- meta$cell\nplot.df$cell_type &lt;- as.data.frame(meta)[plot.df$cell, \"leiden_cluster\"]\nplot.df$nCount_RNA &lt;- as.data.frame(meta)[plot.df$cell, \"nCount_RNA\"]\n\n## Set up scale bar\nscale_bar &lt;- make_scale_bar_r(x_vals = plot.df %&gt;% pull(x_global_px),\n                            y_vals =  plot.df %&gt;% pull(y_global_px))\n\n## Plot it\nggplot(plot.df,\n       aes(x = x_global_px, y = y_global_px, group = cell,\n           fill = ifelse(cell_type == \"5\", nCount_RNA, NA))) + #Logic to color only cells of one type by total counts\n  geom_polygon(color = \"darkgrey\", linewidth = 0.3) +\n  scale_fill_viridis(option = \"magma\", trans = \"log10\", na.value = \"lightgrey\") + # Use viridis color palette\n  coord_fixed() +\n  theme_void() +\n  labs(fill = \"Transcripts per cell\") +\n  scale_bar$bg +\n  scale_bar$rect +\n  scale_bar$label\n  \nggsave(paste0(out_dir, \"celltypeHighlightTxperCell_polygons_singleFOV.png\"),\n       width = 6, height = 4, units = \"in\")\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\n# Filter for FOV 100\nplot_df = cell_polygons[cell_polygons[\"fov\"] == 100]\n\n# Merge only the 'leiden_cluster' and 'nCount_RNA' columns\nmeta_subset = cell_meta[['cell', 'leiden_cluster', 'nCount_RNA']]\nplot_df = plot_df.merge(meta_subset, on='cell', how='left')\n\n# Prepare log10-transformed values for cluster 5\nhighlight_df = plot_df[plot_df['leiden_cluster'] == 5].copy()\nhighlight_df['log_nCount_RNA'] = np.log10(highlight_df['nCount_RNA'].replace(0, np.nan)) # Log10 transform\nvmin, vmax = highlight_df['log_nCount_RNA'].min(), highlight_df['log_nCount_RNA'].max()\nnorm = mcolors.Normalize(vmin=vmin, vmax=vmax) # Normalize to 0 - 1 range as expected by matplotlib colormap\ncmap = cm.get_cmap(\"magma\") # Use the magma palette\n\n# Assign colors dynamically\ncell_to_color = {}\nfor _, row in plot_df.iterrows():\n    if row['leiden_cluster'] == 5 and pd.notna(row['nCount_RNA']) and row['nCount_RNA'] &gt; 0:\n        log_val = np.log10(row['nCount_RNA'])\n        scaled_val = norm(log_val)\n        cell_to_color[row['cell']] = cmap(scaled_val)\n    else:\n        cell_to_color[row['cell']] = \"lightgrey\"\n\n\n\n## Plot\nfig, ax = plt.subplots(figsize=(6, 6))\nfor key, group in plot_df.groupby(\"cell\"):\n    fill_color = cell_to_color[key]\n    coords = group[[\"x_global_px\", \"y_global_px\"]].values\n    coords = np.vstack([coords, coords[0]])  # close the polygon\n    ax.fill(coords[:, 0], coords[:, 1], facecolor=fill_color, edgecolor='darkgrey', linewidth=0.5, zorder=1)\n\nax.set_aspect('equal')\nax.axis('off')\n\n# Add scale bar\nmake_scale_bar_py(ax, plot_df[\"x_global_px\"], plot_df[\"y_global_px\"])\n\n\n# Add colorbar with original transcript counts\nsm = cm.ScalarMappable(cmap=cmap, norm=norm)\nsm.set_array([])\ncbar = fig.colorbar(sm, ax=ax)\ntick_vals = np.linspace(vmin, vmax, num=5)\ncbar.set_ticks(tick_vals)\ncbar.set_ticklabels([f\"{int(10**val):,}\" for val in tick_vals])\ncbar.set_label(\"Transcripts per cell\", fontsize=8)\n\n\nplt.savefig(os.path.join(out_dir, \"python_celltypeHighlightTxperCell_polygons_singleFOV.png\"), bbox_inches='tight', pad_inches=0, dpi=300)\nplt.close()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n3.7 Gallery of single cell type highlighting\nSimilar to above, here we highlight one cell type at a time. However, we now do this for each cell type separately and show a tiled gallery of all cell types. For this example, we show the whole tissue to give the broader context of where each cell type appears.\n\n\n\n\n\n\nNote\n\n\n\nIn making this gallery, plotting all cells in every facet causes many cells to be plotted if you’re looking at a large slide. Here, we instead show 5% of cells in our background to give a tissue overview and all 100% of cells of the type of interest in the foreground.\n\n\n\nRPython\n\n\n\n\nCode\n## Set up scale bar\nscale_bar &lt;- make_scale_bar_r(x_vals = cell_meta$CenterX_global_px,\n                            y_vals = cell_meta$CenterY_global_px)\n\n# Make a copy of metadata that lacks the cell type\ndf2 &lt;- dplyr::select(cell_meta, -leiden_cluster)\n\n# Sample 5% of cells for background\nset.seed(2025)\ndf2 &lt;- df2[sample(1:nrow(df2), nrow(df2)/20),]\n\n## Plot it\nggplot(cell_meta,\n       aes(x = CenterX_global_px, y = CenterY_global_px)) +\n  geom_point(data = df2, color = \"grey80\", size = 0.01, alpha = 0.05) + # Background cells\n  geom_point(color = \"red\", size = 0.01, alpha = 0.1)+ # Foreground highlighted cells\n  coord_fixed() +\n  theme_void() +\n  scale_bar$bg +\n  scale_bar$rect +\n  scale_bar$label +\n  facet_wrap(~leiden_cluster)\n  \nggsave(paste0(out_dir, \"gallery_celltype_positions.png\"),\n       width = 8, height = 12, units = \"in\")\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\n# Create a 5% random sample for background\ndf2 = cell_meta.drop(columns='leiden_cluster').sample(frac=0.05, random_state=2025)\n\n# Create faceted plots by leiden_cluster\nunique_clusters = cell_meta['leiden_cluster'].unique()\nunique_clusters.sort()\nn_clusters = len(unique_clusters)\nn_cols = math.ceil(math.sqrt(n_clusters))\nn_rows = int(np.ceil(n_clusters / n_cols))\n\nfig, axes = plt.subplots(n_rows, n_cols, figsize=(8, 12), squeeze=False)\n\nfor ax, cluster in zip(axes.flat, unique_clusters):\n    # Background layer\n    ax.scatter(df2['CenterX_global_px'], df2['CenterY_global_px'],\n               color='grey', s=0.01, alpha=0.05)\n\n    # Foreground red points for this cluster\n    cluster_data = cell_meta[cell_meta['leiden_cluster'] == cluster]\n    ax.scatter(cluster_data['CenterX_global_px'], cluster_data['CenterY_global_px'],\n               color='red', s=0.01, alpha=0.1)\n\n    # Add scale bar\n    make_scale_bar_py(ax, cell_meta['CenterX_global_px'], cell_meta['CenterY_global_px'])\n    \n    ax.set_title(f\"Cluster {cluster}\")\n    ax.set_aspect('equal')\n    ax.axis('off')\n\n# Hide any unused subplots\nfor ax in axes.flat[n_clusters:]:\n    ax.axis('off')\n\nplt.tight_layout()\nplt.savefig(os.path.join(out_dir, \"python_gallery_celltype_positions.png\"), dpi=300)\nplt.close()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n3.8 Plot One Cell and Its 20 Nearest Neighbors\nFor this plot, we select one cell of interest and plot it along with its 20 nearest neighbors, based on the cell centroids.\n\nRPython\n\n\n\n\nCode\n## Get cells to plot\n# Extract cell centroids\nxy &lt;- cell_meta[,c(\"CenterX_global_px\", \"CenterY_global_px\")]\nrow.names(xy) &lt;- cell_meta$cell_id\n\nneighbors &lt;- FNN::get.knnx(data = xy, # 2-column matrix of xy locations\n                           query = xy, \n                           k = 21) # Set to one more than target. Value chosen includes the cell itself.\n\nrow.names(neighbors$nn.index) &lt;- row.names(xy)\n\n# Select cell of interest\ncoi &lt;- \"c_1_100_555\"\n\n# Extract neighboring cells\nneighboring_cells &lt;- row.names(neighbors$nn.index)[neighbors$nn.index[coi,]]\n\n# Add cell type to polygons\nplot.df &lt;- cell_polygons %&gt;% filter(cell %in% c(neighboring_cells, coi)) %&gt;% as.data.frame()\nmeta &lt;- as.data.frame(cell_meta)\nrow.names(meta) &lt;- meta$cell\nplot.df$cell_type &lt;- as.data.frame(meta)[plot.df$cell, \"leiden_cluster\"] \n\n## Set up scale bar\nscale_bar &lt;- make_scale_bar_r(x_vals = plot.df %&gt;% pull(x_global_px),\n                            y_vals =  plot.df %&gt;% pull(y_global_px))\n\n## Plot it\nggplot(plot.df,\n       aes(x = x_global_px, y = y_global_px, group = cell,\n           fill = as.factor(cell_type), \n           alpha = (cell == coi), # Emphasize cell of interest\n           color = (cell == coi))) + # Emphasize cell of interest\n  geom_polygon() +\n    scale_alpha_manual(values = c(\"TRUE\" = 1, \"FALSE\" = 0.5)) +\n    scale_color_manual(values = c(\"TRUE\" = \"black\", \"FALSE\" = \"darkgrey\")) +\n  scale_fill_npg() + # Use palette inspired by nature publishing group\n  coord_fixed() +\n  theme_void() +\n  labs(fill = \"Cell type\") +\n  guides(alpha = \"none\") +\n  guides(color = \"none\")  +\n  scale_bar$bg +\n  scale_bar$rect +\n  scale_bar$label\n\nggsave(paste0(out_dir, \"celltype_polygons_cell20neighbors.png\"),\n       width = 4, height = 3, units = \"in\")\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\n# Extract cell centroids\nxy = cell_meta[['CenterX_global_px', 'CenterY_global_px']].values\n\n# Find nearest neighbors\n#nbrs = sklearn.neighbors.NearestNeighbors(n_neighbors=21).fit(xy)\nnbrs = NearestNeighbors(n_neighbors=21).fit(xy)\ndistances, indices = nbrs.kneighbors(xy)\n\n# Select cell of interest\ncoi = 'c_1_100_555'\ncoi_index = cell_meta[cell_meta['cell_id'] == coi].index[0]\n\n# Extract neighboring cells\nneighboring_cells = cell_meta.iloc[indices[coi_index]].cell_id.values\n\n# Add cell type to polygons\nplot_df = cell_polygons[cell_polygons['cell'].isin(neighboring_cells)]\nplot_df = plot_df.merge(cell_meta[['cell_id', 'leiden_cluster']], left_on='cell', right_on='cell_id')\nplot_df['alpha'] = np.where(plot_df['cell'] == coi, 1, 0.3)\n\n# Set up color mapping\nunique_clusters = sorted(plot_df[\"leiden_cluster\"].dropna().unique())\ncmap = plt.cm.get_cmap(\"Accent\", len(unique_clusters)) # Matplotlib's accent color palette\ncluster_to_color = {cluster: cmap(i) for i, cluster in enumerate(unique_clusters)}\nif plot_df[\"leiden_cluster\"].isna().any():\n  cluster_to_color[np.nan] = \"lightgrey\"\n\n## Plot\nfig, ax = plt.subplots(figsize=(6, 6))\nfor key, group in plot_df.groupby(\"cell\"):\n    cell_type = group[\"leiden_cluster\"].iloc[0]\n    alpha = group[\"alpha\"].iloc[0]\n    edge_color = 'black' if group[\"cell\"].iloc[0] == coi else 'darkgrey'\n    fill_color = cluster_to_color[np.nan] if pd.isna(cell_type) else cluster_to_color[cell_type]\n    coords = group[[\"x_global_px\", \"y_global_px\"]].values\n    coords = np.vstack([coords, coords[0]])  # close the polygon\n    ax.fill(coords[:, 0], coords[:, 1], facecolor=fill_color, edgecolor=edge_color, alpha=alpha, zorder = 1)\n\nax.set_aspect('equal')\nax.axis('off')\n\n# Add scale bar\nmake_scale_bar_py(ax, plot_df[\"x_global_px\"], plot_df[\"y_global_px\"])\n\n# Legend for fill colors\nlegend_handles = [\n    mpatches.Patch(\n      color=color, \n      label=f\"Cluster {int(cluster)}\" if pd.notna(cluster) else \"Cluster NA\")\n    for cluster, color in cluster_to_color.items()\n]\n\nax.legend(handles=legend_handles, title=\"Cell type\", bbox_to_anchor=(1.05, 1), loc='upper left')\n\nplt.tight_layout()\nplt.savefig(os.path.join(out_dir, \"python_celltype_polygons_cell20neighbors.png\"), bbox_inches='tight', pad_inches=0, dpi=300)\nplt.close()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n3.9 Plot one cell in its neighborhood\nSometimes, plotting a single cell alongside its x nearest neighbors can give a misleading impression, making it seem like the cells are isolated, even when they’re actually part of a densely packed region. A more spatially accurate alternative is to visualize a square section of tissue centered on a cell of interest.\nTo do this, we first select all cells within a broader radius to ensure complete polygon shapes are captured. Then, we trim the plot to display only a smaller, focused square around the target cell. This approach preserves spatial context while highlighting the local environment.\n\nRPython\n\n\n\n\nCode\n## Get cells to plot\n\n# Conversion factor for commercial CosMx instrument.\nmicrons_per_pixel &lt;- 0.12028\n\n# Select cell of interest\ncoi &lt;- \"c_1_100_555\"\n\n# Set square edge size in microns and pixels\nsquare_edge_um &lt;- 100\nsquare_edge_px &lt;- square_edge_um / microns_per_pixel\n\n# Extract large square boundaries, double the width and height of target, centered on coi\n# Ensures that we're not cutting through a cell\ncoi_x &lt;- cell_polygons %&gt;% filter(cell == coi) %&gt;% pull(x_global_px) %&gt;% median()\ncoi_y &lt;- cell_polygons %&gt;% filter(cell == coi) %&gt;% pull(y_global_px) %&gt;% median()\nplot.df &lt;- cell_polygons %&gt;% filter(\n  x_global_px &gt; (coi_x - square_edge_px),\n   x_global_px &lt; (coi_x + square_edge_px),\n   y_global_px &gt; (coi_y - square_edge_px),\n   y_global_px &lt; (coi_y + square_edge_px)\n)\n\n# Add cell type to polygons\nmeta &lt;- as.data.frame(cell_meta)\nrow.names(meta) &lt;- meta$cell\nplot.df$cell_type &lt;- as.data.frame(meta)[plot.df$cell, \"leiden_cluster\"] \n\n## Set up scale bar, adding min / max values directly because we'll be showing a subset of the data\nscale_bar &lt;- make_scale_bar_r(x_vals = c(coi_x - square_edge_px/2, coi_x + square_edge_px/2),\n                            y_vals =  c(coi_y - square_edge_px/2, coi_y + square_edge_px/2))\n\n\n## Plot it\nggplot(plot.df,\n       aes(x = x_global_px, y = y_global_px, group = cell,\n           fill = as.factor(cell_type), \n           alpha = (cell == coi), # Emphasize cell of interest\n           color = (cell == coi))) + # Emphasize cell of interest\n  geom_polygon() +\n    scale_alpha_manual(values = c(\"TRUE\" = 1, \"FALSE\" = 0.5)) +\n    scale_color_manual(values = c(\"TRUE\" = \"black\", \"FALSE\" = \"darkgrey\")) +\n  scale_fill_d3(palette = \"category20c\") + # Inspired by colors in the D3 visualization library\n  theme_void() +\n  labs(fill = \"Cell type\") +\n  guides(alpha = \"none\") +\n  guides(color = \"none\")  +\n  # Set reduced coordinates\n  coord_fixed(ratio = 1,\n              xlim=c(coi_x - square_edge_px/2, coi_x + square_edge_px/2), \n                  ylim=c(coi_y - square_edge_px/2, coi_y + square_edge_px/2)) +\n  scale_bar$bg +\n  scale_bar$rect +\n  scale_bar$label\nggsave(paste0(out_dir, \"celltype_polygons_cell100umsquare.png\"),\n       width = 6, height = 6, units = \"in\")\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\n# Constants\nmicrons_per_pixel = 0.12028\ncoi = \"c_1_100_555\"\nsquare_edge_um = 100\nsquare_edge_px = square_edge_um / microns_per_pixel\n\n# Compute centroid of cell of interest\ncoi_data = cell_polygons[cell_polygons['cell'] == coi]\ncoi_x = coi_data['x_global_px'].median()\ncoi_y = coi_data['y_global_px'].median()\n\n# Filter polygons within square region\nplot_df = cell_polygons[\n    (cell_polygons['x_global_px'] &gt; (coi_x - square_edge_px)) &\n    (cell_polygons['x_global_px'] &lt; (coi_x + square_edge_px)) &\n    (cell_polygons['y_global_px'] &gt; (coi_y - square_edge_px)) &\n    (cell_polygons['y_global_px'] &lt; (coi_y + square_edge_px))\n].copy()\n\n# Add cell type\nmeta = cell_meta.set_index('cell')\nplot_df['cell_type'] = plot_df['cell'].map(meta['leiden_cluster'])\n\n# Set up color mapping\nunique_clusters = sorted(plot_df[\"cell_type\"].dropna().unique())\ncmap = plt.cm.get_cmap(\"tab20b\", len(unique_clusters)) # Matplotlib's tab20b palette\ncluster_to_color = {cluster: cmap(i) for i, cluster in enumerate(unique_clusters)}\nif plot_df[\"cell_type\"].isna().any():\n  cluster_to_color[np.nan] = \"lightgrey\"\n\n# Plotting\nfig, ax = plt.subplots(figsize=(6,6))\n\n# Group by cell to draw polygons\nfor cell_id, group in plot_df.groupby('cell'):\n    cell_type = group[\"cell_type\"].iloc[0]\n    coords = group[['x_global_px', 'y_global_px']].values\n    polygon = mpatches.Polygon(coords, closed=True,\n                      facecolor=cluster_to_color[np.nan] if pd.isna(cell_type) else cluster_to_color[cell_type],\n                      edgecolor='black' if cell_id == coi else 'darkgrey',\n                      alpha=1.0 if cell_id == coi else 0.5)\n    ax.add_patch(polygon)\n    \n\n# Add scale bar, setting up arrays that are the axis limits since we'll be reducing the plotting window\nmake_scale_bar_py(ax, np.array([coi_x - square_edge_px / 2, coi_x + square_edge_px / 2]), np.array([coi_y - square_edge_px / 2, coi_y + square_edge_px / 2]))  \n\n# Set plot limits and aspect\nax.set_xlim(coi_x - square_edge_px / 2, coi_x + square_edge_px / 2)\nax.set_ylim(coi_y - square_edge_px / 2, coi_y + square_edge_px / 2)\nax.set_aspect('equal')\nax.axis('off')\n\n# Legend for fill colors with only colors in the visible region\n# Get current axis limits\nxlim = ax.get_xlim()\nylim = ax.get_ylim()\n\n# Identify cells whose polygons fall within the visible region\nvisible_cells = plot_df[\n    (plot_df['x_global_px'] &gt;= xlim[0]) & (plot_df['x_global_px'] &lt;= xlim[1]) &\n    (plot_df['y_global_px'] &gt;= ylim[0]) & (plot_df['y_global_px'] &lt;= ylim[1])\n]\n\n# Get unique visible cell types\nvisible_cell_types = visible_cells['cell_type'].dropna().unique().tolist()\nif visible_cells['cell_type'].isna().any():\n    visible_cell_types.append(np.nan)\n\n# Filter legend handles to only include visible cell types\nlegend_handles = [\n    mpatches.Patch(\n        color=color,\n        label=f\"Cluster {int(cluster)}\" if pd.notna(cluster) else \"Cluster NA\"\n    )\n    for cluster, color in cluster_to_color.items()\n    if cluster in visible_cell_types\n]\n\n# Add the filtered legend\nax.legend(handles=legend_handles, title=\"Cell type\", bbox_to_anchor=(1.05, 1), loc='upper left')\n\n# Save figure\nplt.tight_layout()\nplt.savefig(os.path.join(out_dir, \"python_celltype_polygons_cell100umsquare.png\"), dpi=300, bbox_inches='tight')\nplt.close()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n3.10 Overlay Specific Transcripts\nAdd transcripts of interest (e.g., KRT8) as points.\n\n\n\n\n\n\nTranscript File Performance Tip\n\n\n\nReading the full transcript file into memory can be computationally intensive, especially if you’re only interested in a subset of transcripts for plotting.\nInstead of loading the entire file, here we filter the relevant lines using a shell command before importing them into R with fread() or into Python. This can significantly reduce load time although with a large dataset it still may take a few minutes.\nFor even better performance in future workflows, you might convert the transcript file to a more efficient format like Parquet, which supports faster reads and selective column access.\n\n\n\nRPython\n\n\n\n\nCode\n## Read in transcripts\n\n# Define your file name as a variable\nfile_name &lt;- paste0(raw_data_dir, \"/\", slide_name, \"_tx_file.csv.gz\")\n\n# Construct the shell command using sprintf\n# fov is in column 1 and target is in column 9\ncmd &lt;- sprintf(\"zcat %s | awk -F',' 'NR==1 || ($1==\\\"100\\\" && $9==\\\"KRT8\\\")'\", file_name)\n\n# Read the filtered tx data\nfiltered_tx &lt;- fread(cmd = cmd)\n\n## Set up scale bar\nscale_bar &lt;- make_scale_bar_r(x_vals = cell_polygons %&gt;% filter(fov == 100) %&gt;% pull(x_global_px),\n                            y_vals =  cell_polygons %&gt;% filter(fov == 100) %&gt;% pull(y_global_px))\n\n## Plot it\nggplot(cell_polygons %&gt;% filter(fov == 100),\n       aes(x = x_global_px, y = y_global_px, group = cell)) +\n  geom_polygon(fill = \"lightgrey\", color = \"darkgrey\", linewidth = 0.3) +\n  geom_point(data = filtered_tx, aes(x = x_global_px, y = y_global_px), #Overlay transcript points\n             color = \"red\", size = 0.3) +\n  coord_fixed() +\n  theme_void()  +\n  scale_bar$bg +\n  scale_bar$rect +\n  scale_bar$label\n  \nggsave(paste0(out_dir, \"polygons_singleFOV_singleTx.png\"),\n       width = 6, height = 4, units = \"in\")\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\n# Define your file name as a variable\nfile_name = Path(raw_data_dir / f\"{slide_name}_tx_file.csv.gz\")\n\n# Construct the shell command using sprintf\n# fov is in column 1 and target is in column 9\ncmd = f\"zcat {file_name} | awk -F',' 'NR==1 || ($1==\\\"100\\\" && $9==\\\"KRT8\\\")'\"\n\n# Run the command and capture output\nresult = subprocess.run(cmd, shell=True, stdout=subprocess.PIPE, text=True)\n\n# Read the filtered result into a DataFrame\nfiltered_tx = pd.read_csv(io.StringIO(result.stdout))\n\n# Filter cell polygons to focus on one fov\nplot_df = cell_polygons[cell_polygons[\"fov\"] == 100]\n\n# Plot\nfig, ax = plt.subplots(figsize=(6, 4))\nfor _, group in plot_df.groupby(\"cell\"):\n    coords = group[[\"x_global_px\", \"y_global_px\"]].values\n    coords = np.vstack([coords, coords[0]])  # close the polygon\n    ax.fill(coords[:, 0], coords[:, 1], facecolor=\"lightgrey\", edgecolor=\"darkgrey\", linewidth=0.5, zorder=1)\n\n# Overlay transcript dots\nax.scatter(filtered_tx[\"x_global_px\"], filtered_tx[\"y_global_px\"], color=\"red\", s=0.3, zorder=2)\n\nax.set_aspect('equal', adjustable='box')\nax.axis('off')\n\n# Add scale bar\nmake_scale_bar_py(ax, plot_df[\"x_global_px\"], plot_df[\"y_global_px\"])\n\n# Save\nplt.savefig(os.path.join(out_dir, \"python_polygons_singleFOV_singleTx.png\"), bbox_inches='tight', pad_inches=0, dpi=300)\nplt.close()"
  },
  {
    "objectID": "posts/spatial-plotting/index.html#qc-module-visualizations",
    "href": "posts/spatial-plotting/index.html#qc-module-visualizations",
    "title": "Visualizing Spatial Transcriptomics: A Guide to Effective Plotting",
    "section": "4 QC Module Visualizations",
    "text": "4 QC Module Visualizations\nHere we generate plots to visualize many of the metrics output by the RNAQC plots module for AtoMx SIP.\nWe start by reading in the outputs of this module for use in multiple of the plots in this section. We also add one more column, SNR, which we calculate as mean transcripts per plex / mean negative probes per plex.\n\nRPython\n\n\n\n\nCode\nqc &lt;- read.csv(paste0(raw_data_dir, \"Per_FOV_data_quality_metrics.csv\"), # For convenience, we assume this is stored in the same directory as the flat files.\n               row.names = 1)\n\n# Set up plex for this dataset\ndataset_plex &lt;- 18935\n\n# Add per FOV SNR\nqc$SNR_Per_FOV &lt;- (qc$Mean_Transcripts_Per_Cell_Per_FOV / dataset_plex) / qc$Mean_Negative_Probe_Per_Plex_Per_Cell_Per_FOV\n\n\n\n\n\n\nCode\nqc = pd.read_csv(Path(raw_data_dir / f\"Per_FOV_data_quality_metrics.csv\"), index_col=0) # For convenience, we assume this is stored in the same directory as the flat files.\n\n# Set up plex for this dataset\ndataset_plex = 18935\n\n# Add per FOV SNR\nqc['SNR_Per_FOV'] = (qc['Mean_Transcripts_Per_Cell_Per_FOV'] / dataset_plex) / qc['Mean_Negative_Probe_Per_Plex_Per_Cell_Per_FOV']\n\n\n\n\n\n\n4.1 Distribution of QC Metrics\nHistograms showing the distribution for each per FOV metric.\n\nRPython\n\n\n\n\nCode\n# Extract fov metric columns to plot\nfov_metrics &lt;- grep(\"Per_FOV\", colnames(qc), value = TRUE)\n\nfor(fov_metric in fov_metrics){\n  ggplot(qc, aes(x = get(fov_metric))) +\n    geom_histogram(bins = 50, fill = \"steelblue\", color = \"white\") +\n    theme_minimal() +\n    labs(title = gsub(\"_\", \" \", fov_metric)) +\n    theme(axis.title.x=element_blank()) +\n    ylab(\"Number of FOVs\")\n  ggsave(paste0(out_dir, \"/Histogram_qc_\", fov_metric, \".png\"),\n         width = 8, height = 4, units = \"in\")\n}\n\n\n\nMean_Negative_Probe_Per_Plex_Per_Cell_Per_FOVMean_SystemControl_Per_Plex_Per_Cell_Per_FOVMean_Transcripts_Per_Cell_Per_FOVMean_Unique_Transcripts_Per_Cell_Per_FOVNumber_Cells_Per_FOVSNR_Per_FOVTotal_Transcripts_Per_FOV\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\n# Extract FOV metric columns\nfov_metrics = [col for col in qc.columns if 'Per_FOV' in col]\n\n# Generate histograms\nfor fov_metric in fov_metrics:\n    plt.figure(figsize=(10, 6))\n    plt.hist(qc[fov_metric].dropna(), bins=50, color='steelblue', edgecolor='white')\n    plt.title(fov_metric.replace('_', ' '))\n    plt.xlabel('')\n    plt.ylabel('Number of FOVs')\n    plt.tight_layout()\n    plt.savefig(f\"{out_dir}/python_Histogram_qc_{fov_metric}.png\", dpi=300)\n    plt.close()\n\n\n\nMean_Negative_Probe_Per_Plex_Per_Cell_Per_FOVMean_SystemControl_Per_Plex_Per_Cell_Per_FOVMean_Transcripts_Per_Cell_Per_FOVMean_Unique_Transcripts_Per_Cell_Per_FOVNumber_Cells_Per_FOVSNR_Per_FOVTotal_Transcripts_Per_FOV\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n4.2 Spatial visualization of per FOV metrics\nTo help identify spatial patterns in quality control metrics, we generate a spatial plot for each FOV. Each plot includes the FOV number overlaid for easy reference and comparison across the tissue.\n\nRPython\n\n\n\n\nCode\n# Extract fov metric columns to plot\nfov_metrics &lt;- grep(\"Per_FOV\", colnames(qc), value = TRUE)\n\n# Add xy positions for each FOV to qc dataframe\nfov_positions &lt;- as.data.frame(fov_positions)\nrow.names(fov_positions) &lt;- as.character(fov_positions$FOV)\nqc$x_global_px &lt;- fov_positions[as.character(qc$fov), \"x_global_px\"]\nqc$y_global_px &lt;- fov_positions[as.character(qc$fov), \"y_global_px\"]\n\n## Set up scale bar for all plots\nscale_bar &lt;- make_scale_bar_r(x_vals = qc %&gt;% pull(x_global_px),\n                            y_vals =  qc %&gt;% pull(y_global_px))\n\n## Plot each per FOV metric in space\nfor(fov_metric in fov_metrics){\n  ggplot(qc, \n         aes(x = x_global_px, y = y_global_px, \n             fill = get(fov_metric))) +\n    geom_tile(width = 4254, height = 4254) + #CosMx FOVs are 4254x4254 pixels\n    scale_fill_gradient(low = \"blue\", high = \"magenta\") +\n    geom_label(aes(label = fov)) + # Label each FOV in space\n    theme_void() +\n    labs(title = gsub(\"_\", \" \", fov_metric),\n         fill = gsub(\"_\", \" \", fov_metric)) +\n    theme(axis.title.x = element_blank(),\n          axis.title.y = element_blank()) +\n    coord_fixed() +\n    scale_bar$bg +\n    scale_bar$rect +\n    scale_bar$label\n    \n  \n  ggsave(paste0(out_dir, \"/XY_qc_\", fov_metric, \".png\"),\n         width = 12, height = 16, units = \"in\")\n}\n\n\n\nMean_Negative_Probe_Per_Plex_Per_Cell_Per_FOVMean_SystemControl_Per_Plex_Per_Cell_Per_FOVMean_Transcripts_Per_Cell_Per_FOVMean_Unique_Transcripts_Per_Cell_Per_FOVNumber_Cells_Per_FOVSNR_Per_FOVTotal_Transcripts_Per_FOV\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\n# Extract FOV metric columns\nfov_metrics = [col for col in qc.columns if 'Per_FOV' in col]\n\n# Add xy positions for each FOV to qc dataframe\nfov_positions.set_index('FOV', inplace=True)\nqc['x_global_px'] = qc['fov'].map(fov_positions['x_global_px'])\nqc['y_global_px'] = qc['fov'].map(fov_positions['y_global_px'])\n\n# Set up a color scale to use\nblue_magenta = mcolors.LinearSegmentedColormap.from_list(\"blue_magenta\", [\"blue\", \"magenta\"])\n\n# Plot each per FOV metric in space\nfor fov_metric in fov_metrics:\n    fig, ax = plt.subplots(figsize=(12, 16))\n    # The 's' parameter indicates the point size and was empirically determined for this dataset.\n    # You may need to increase or decrease it to get the boxes to fill the space in other datasets.\n    ax.scatter(qc['x_global_px'], qc['y_global_px'], c=qc[fov_metric], cmap='coolwarm', s=700, marker = \"s\")\n    scatter = ax.scatter(qc['x_global_px'], qc['y_global_px'], c=qc[fov_metric], cmap=blue_magenta, s=700, marker = \"s\")\n    cbar = fig.colorbar(scatter, ax=ax)\n    cbar.set_label(fov_metric.replace('_', ' '))\n    for i, row in qc.iterrows():\n        ax.text(row['x_global_px'], row['y_global_px'], str(row['fov']), fontsize=8, ha='center', va='center', color='black')\n    ax.set_title(fov_metric.replace('_', ' '))\n    ax.set_aspect('equal', adjustable='box')\n    ax.axis('off')\n    # Add scale bar\n    make_scale_bar_py(ax, qc[\"x_global_px\"], qc[\"y_global_px\"])\n    \n    plt.savefig(f\"{out_dir}/python_XY_qc_{fov_metric}.png\", dpi=300)\n    plt.close()\n\n\n\nMean_Negative_Probe_Per_Plex_Per_Cell_Per_FOVMean_SystemControl_Per_Plex_Per_Cell_Per_FOVMean_Transcripts_Per_Cell_Per_FOVMean_Unique_Transcripts_Per_Cell_Per_FOVNumber_Cells_Per_FOVSNR_Per_FOVTotal_Transcripts_Per_FOV\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n4.3 QC Metric by Cell Type\nIn addition to the outputs of the QC module, there are a number of QC metrics that can be extracted from the meta data and plotted by cell type. As an example here, we show transcripts per cell separated by cell type.\n\nRPython\n\n\n\n\nCode\ncell_meta$cell_type &lt;- as.character(cell_meta$leiden_cluster)\n\n# Use alphabet palette\nmy_pal &lt;- pals::alphabet(n = length(unique(cell_meta$cell_type)))\nnames(my_pal) &lt;- unique(cell_meta$cell_type)\n\nggplot(cell_meta, aes(x = cell_type, y = nCount_RNA, fill = cell_type)) +\n  geom_boxplot() +\n  scale_fill_manual(values = my_pal) +\n  theme_minimal() +\n  xlab(\"Cell type\") +\n  ylab(\"Transcript counts per cell\") +\n  labs(title = \"Transcript Count by Cell Type\") +\n  scale_y_log10() +\n  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +\n  theme(legend.position = \"none\")\nggsave(paste0(out_dir, \"/BarPlot_qc_txPerCell_cellType.png\"),\n       width = 6, height = 4, units = \"in\")\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\n# Convert leiden_cluster to string and assign to cell_type\n# Fill NaNs with a placeholder (e.g., -1) before converting\ncell_meta['leiden_cluster'] = cell_meta['leiden_cluster'].fillna(-1)\ncell_meta['cell_type'] = cell_meta['leiden_cluster'].astype(int).astype(str)\n\n# Convert NA values back\ncell_meta['leiden_cluster'] = cell_meta['leiden_cluster'].replace(-1, np.nan)\ncell_meta['cell_type'] = cell_meta['cell_type'].replace({'-1': 'Not assigned'})\n\n# Get unique cell types and assign colors\nunique_cell_types = sorted(cell_meta['cell_type'].unique(), key=lambda x: float(x) if x.isdigit() else float('inf'))\ncolors = plt.cm.get_cmap('tab20c', len(unique_cell_types)) #Use tab20c palette\ncolor_dict = {cell_type: colors(i) for i, cell_type in enumerate(unique_cell_types)}\n\n# Prepare data for boxplot\ndata = [cell_meta[cell_meta['cell_type'] == ct]['nCount_RNA'] for ct in unique_cell_types]\n\n# Create the boxplot\nfig, ax = plt.subplots(figsize=(12, 8))\nbox = ax.boxplot(data, patch_artist=True, labels=unique_cell_types)\n\n# Apply colors to boxes\nfor patch, ct in zip(box['boxes'], unique_cell_types):\n    patch.set_facecolor(color_dict[ct])\n\n# Customize plot\nax.set_yscale('log')\nax.set_xlabel('Cell type')\nax.set_ylabel('Transcript counts per cell')\nax.set_title('Transcript Count by Cell Type')\nplt.xticks(rotation=45, ha='right')\nplt.legend([], [], frameon=False)  # Remove legend\nplt.tight_layout()\n\n# Save the plot\nplt.savefig(f\"{out_dir}/python_BarPlot_qc_txPerCell_cellType.png\", dpi=300)\nplt.close()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n4.4 Per cell QC metrics in space\nAnother QC metric in the meta data is whether a cell has been ‘flagged’ by any of the QC steps in AtoMx. We can plot each cell’s ‘qcCellsFlagged’ status in space to look for spatial patterns in the cells get flagged. Keep an eye out for overplotting here, which can lead to the incorrect conclusion that all cells in a region have been lost. We reduce the opacity to counter this impression.\n\nRPython\n\n\n\n\nCode\n## Set up scale bar\nscale_bar &lt;- make_scale_bar_r(x_vals = cell_meta$CenterX_global_px,\n                            y_vals =  cell_meta$CenterY_global_px)\n\n## Plot it\nggplot(cell_meta[order(cell_meta$qcCellsFlagged),], #Ordering plots 'false' cells first\n       aes(CenterX_global_px, CenterY_global_px)) + \n  geom_point(aes(color = qcCellsFlagged), size = 0.01, alpha = 0.1) + \n  scale_color_manual(values=c(\"#D6DBDF\", \"#D86769\")) + \n  guides(colour = guide_legend(override.aes = list(size=3, alpha = 1))) + \n  labs(color = \"Flagged\") + \n  coord_fixed() + \n  theme_void()  +\n  scale_bar$bg +\n  scale_bar$rect +\n  scale_bar$label\n  \nggsave(paste0(out_dir, \"/qc_flaggedCells.png\"),\n       width = 4, height = 6, units = \"in\")\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\n# Define color mapping for flagged status\ncolor_map = {True: \"#D86769\", False: \"#D6DBDF\"}\n\n# To increase the visibility of the flagged cells, we split the data frame and plot the flagged cells second\nfalse_cells = cell_meta[cell_meta['qcCellsFlagged'] == False]\ntrue_cells = cell_meta[cell_meta['qcCellsFlagged'] == True]\n\n# Create the plot\nfig, ax = plt.subplots(figsize=(4, 6))\n# Cells not flagged\nax.scatter(\n    false_cells['CenterX_global_px'],\n    false_cells['CenterY_global_px'],\n    c=false_cells['qcCellsFlagged'].map(color_map),\n    s=0.01,\n    alpha =0.2,\n    zorder=1\n)\n\n# Cells flagged\nax.scatter(\n    true_cells['CenterX_global_px'],\n    true_cells['CenterY_global_px'],\n    c=true_cells['qcCellsFlagged'].map(color_map),\n    s=0.01,\n    alpha = 0.2,\n    zorder=2\n)\n\n# Add scale bar\nmake_scale_bar_py(ax, cell_meta[\"CenterX_global_px\"], cell_meta[\"CenterY_global_px\"])\n\n# Add a legend with larger marker size\nfrom matplotlib.lines import Line2D\nlegend_elements = [\n    Line2D([0], [0], marker='o', color='w', label='False',\n           markerfacecolor=color_map[False], markersize=6),\n    Line2D([0], [0], marker='o', color='w', label='True',\n           markerfacecolor=color_map[True], markersize=6)\n]\nax.legend(handles=legend_elements, title=\"Flagged\")\n\n# Fix aspect ratio and remove axes\nax.set_aspect('equal', adjustable='box')\nax.axis('off')\n\n# Save the plot\nplt.savefig(f\"{out_dir}/python_qc_flaggedCells.png\", dpi=300, bbox_inches='tight')\nplt.close()"
  },
  {
    "objectID": "posts/spatial-plotting/index.html#neighborhood-visualizations",
    "href": "posts/spatial-plotting/index.html#neighborhood-visualizations",
    "title": "Visualizing Spatial Transcriptomics: A Guide to Effective Plotting",
    "section": "5 Neighborhood Visualizations",
    "text": "5 Neighborhood Visualizations\nWe cover more extensive cell neighborhood analysis in a dedicated post, but include some summary visualizations here.\n\n5.1 Distance to Nearest Cell of Type A\nWe find that often we’re interested in examining how close a given cell is to a cell of a certain type, for example how close every cell is to the nearest macrophage. Here we make a spatial plot to show the distance to the nearest macrophage. Based on the marker genes and spatial distribution here we’ll designate unsupervised cell type 3 as macrophage.\n\nRPython\n\n\n\n\nCode\n# Separate macrophages and other cells\nmacrophages &lt;- cell_meta %&gt;% filter(leiden_cluster == 3) %&gt;% select(CenterX_global_px, CenterY_global_px)\nall_cells &lt;- cell_meta %&gt;% select(CenterX_global_px, CenterY_global_px)\n\n# Find nearest macrophage for each cell\nnn &lt;- FNN::get.knnx(data = macrophages, query = all_cells, k = 1)\n\n# Extract distances\ndistances &lt;- nn$nn.dist[, 1]\n\n# Add to original data\ncell_meta$nearest_macrophage_distance &lt;- distances\n\n# Convert to distance in microns\nmicrons_per_pixel = 0.12028\ncell_meta$nearest_macrophage_distance_um &lt;- cell_meta$nearest_macrophage_distance * microns_per_pixel\n\n# There are a few outliers in distance, so we cap the distance plotted\n\n# Calculate the 90th percentile cap\ncap_value &lt;- quantile(cell_meta$nearest_macrophage_distance_um, 0.9, na.rm = TRUE)\n\n# Cap the values\ncell_meta$distance_capped &lt;- pmin(cell_meta$nearest_macrophage_distance_um, cap_value)\n\n# Define breaks and labels\nbreaks &lt;- pretty(c(0, cap_value), n = 5)\nbreaks[length(breaks)] &lt;- cap_value\nlabels &lt;- as.character(breaks)\nlabels[length(labels)] &lt;- paste0(\"&gt; \", round(cap_value))\n\n## Set up scale bar\nscale_bar &lt;- make_scale_bar_r(x_vals = cell_meta$CenterX_global_px,\n                            y_vals =  cell_meta$CenterY_global_px)\n\n\n\n## Plot it\nggplot(cell_meta,\n       aes(x = CenterX_global_px, y = CenterY_global_px,\n           color = distance_capped)) +\n  geom_point(size = 0.1, alpha = 0.1) +\n  scale_color_viridis(name = \"Distance to\\nnearest mac.\\n(µm)\",\n                      breaks = breaks,\n                      labels = labels) + \n  coord_fixed() +\n  theme_void()  +\n  scale_bar$bg +\n  scale_bar$rect +\n  scale_bar$label\n\nggsave(paste0(out_dir, \"nearest_cell.png\"),\n       width = 4, height = 6, units = \"in\")\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\n# Separate macrophages and all cells\nmacrophages = cell_meta[cell_meta['leiden_cluster'] == 3][['CenterX_global_px', 'CenterY_global_px']]\nall_cells = cell_meta[['CenterX_global_px', 'CenterY_global_px']]\n\n# Find nearest macrophage for each cell\nnn_model = NearestNeighbors(n_neighbors=1)\nnn_model.fit(macrophages)\ndistances, _ = nn_model.kneighbors(all_cells)\n\n# Add distances to the original DataFrame\ncell_meta['nearest_macrophage_distance'] = distances[:, 0]\n\n# Convert to microns\nmicrons_per_pixel = 0.12028\ncell_meta['nearest_macrophage_distance_um'] = cell_meta['nearest_macrophage_distance'] * microns_per_pixel\n\n# Cap the 'nearest_macrophage_distance' at the 90th percentile\ncap_value = cell_meta['nearest_macrophage_distance_um'].quantile(0.9)\ncell_meta['distance_capped'] = np.minimum(cell_meta['nearest_macrophage_distance_um'], cap_value)\n\n# Define breaks and labels similar to R's pretty function\nbreaks = np.linspace(0, cap_value, 5)\nlabels = [f\"{int(b)}\" for b in breaks]\nlabels[-1] = f\"&gt; {int(cap_value)}\"\n\n## Plot\nfig, ax = plt.subplots(figsize=(4, 6))\nscatter = ax.scatter(\n    cell_meta['CenterX_global_px'],\n    cell_meta['CenterY_global_px'],\n    c=cell_meta['distance_capped'],\n    cmap='viridis',\n    s=0.1,\n    alpha=0.1,\n    zorder=1\n)\ncbar = fig.colorbar(scatter, ax=ax, label='Distance to\\nnearest mac.\\n(µm)')\ncbar.set_ticks(breaks)\ncbar.set_ticklabels(labels)\ncbar.solids.set(alpha=1)\nax.set_aspect('equal', adjustable='box')\nax.axis('off')\n\n# Add scale bar\nmake_scale_bar_py(ax, cell_meta[\"CenterX_global_px\"], cell_meta[\"CenterY_global_px\"])\n\nplt.savefig(f\"{out_dir}/python_nearest_cell.png\", dpi=300, bbox_inches='tight')\nplt.close()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n5.2 Cell type composition by annotation\nWe often want to show the cell type composition within a specific region or across patients. We don’t have multiple patients or slides in this dataset, so instead here we show the cell type composition by groups of FOVs, after splitting the sample into an upper and lower lobe. A more common use might be to show cell type composition by niche, but we have not calculated niches on this dataset.\n\nRPython\n\n\n\n\nCode\n# Add a basic lobe designation for demonstration purposes\ncell_meta$lobe &lt;- ifelse(cell_meta$CenterY_global_px &gt; 50000, \"upper\", \"lower\")\n\n# Add FOV group for demonstration similar to niche\ncell_meta &lt;- cell_meta %&gt;%\n  mutate(fov_group = letters[ceiling(fov / 20)])\n\n# Use polychrome palette\nmy_pal &lt;- pals::polychrome(n = length(unique(cell_meta$leiden_cluster)))\nnames(my_pal) &lt;- unique(cell_meta$leiden_cluster)\n\n\n# Plot cell composition by niche, split by lobe\nggplot(cell_meta,\n       aes(x = fov_group, fill = as.factor(leiden_cluster))) +\n  geom_bar(position = \"fill\") +\n  scale_fill_manual(values = my_pal, name = \"Cell type\") + \n  facet_wrap(~lobe, scales = \"free_x\") +\n  ylab(\"Fraction of cells\") +\n  xlab(\"FOV group (niche)\") +\n  theme_classic()\nggsave(paste0(out_dir, \"/barPlot_cellTypes_annotations.png\"),\n       width = 8, height = 4, units = \"in\")\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\n# Add a basic lobe designation for demonstration purposes\ncell_meta['lobe'] = cell_meta['CenterY_global_px'].apply(lambda y: 'upper' if y &gt; 50000 else 'lower')\n\n# Add FOV group for demonstration similar to niche\ncell_meta['fov_group'] = cell_meta['fov'].apply(lambda x: string.ascii_lowercase[int(np.ceil(x / 20)) - 1])\n\n# Get unique cell types and assign colors\nunique_cell_types = cell_meta['leiden_cluster'].unique()\ncolors = plt.cm.get_cmap('tab20', len(unique_cell_types))\ncolor_dict = {cell_type: colors(i) for i, cell_type in enumerate(unique_cell_types)}\n\n# Prepare data\ngrouped = cell_meta.groupby(['lobe', 'fov_group', 'leiden_cluster']).size().reset_index(name='count')\ngrouped['fraction'] = grouped.groupby(['lobe', 'fov_group'])['count'].transform(lambda x: x / x.sum())\n\n# Plot\nlobes = grouped['lobe'].unique()\nniches = grouped['fov_group'].unique()\ncell_types = grouped['leiden_cluster'].unique()\n\nfig, axes = plt.subplots(1, len(lobes), figsize=(6 * len(lobes), 6), sharey=True)\n\nif len(lobes) == 1:\n    axes = [axes]\n\nfor ax, lobe in zip(axes, lobes):\n    data = grouped[grouped['lobe'] == lobe]\n    lobe_niches = sorted(data['fov_group'].unique())\n    bottom = pd.Series(0, index=lobe_niches, dtype='float64')\n    for ct in cell_types:\n        values = data[data['leiden_cluster'] == ct].set_index('fov_group')['fraction'].reindex(lobe_niches, fill_value=0)\n        ax.bar(lobe_niches, values.values, bottom=bottom[lobe_niches].values, label=ct, color=color_dict.get(ct, '#333333'))\n        bottom[lobe_niches] += values\n    ax.set_title(f\"Lobe: {lobe}\")\n    ax.set_xlabel(\"FOV group (niche)\")\n    ax.set_ylabel(\"Fraction of cells\")\n\nhandles, labels = axes[-1].get_legend_handles_labels()\nlabels = [str(int(float(label))) if label.replace('.', '', 1).isdigit() else label for label in labels]\nfig.legend(handles, labels, title=\"Cell type\", bbox_to_anchor=(1.02, 0.5), loc='center left')\n\nplt.tight_layout()\nplt.savefig(f\"{out_dir}/python_barPlot_cellTypes_annotations.png\", bbox_inches='tight', dpi=300)\nplt.close()"
  },
  {
    "objectID": "posts/spatial-plotting/index.html#summary",
    "href": "posts/spatial-plotting/index.html#summary",
    "title": "Visualizing Spatial Transcriptomics: A Guide to Effective Plotting",
    "section": "6 Summary",
    "text": "6 Summary\nThis post introduced a suite of visualization techniques for CosMx spatial transcriptomics data starting from flat file inputs. Whether you’re assessing data quality, visualizing spatial structure, or exploring cell interactions, these plots can provide a powerful first look."
  },
  {
    "objectID": "posts/subcellular/index.html",
    "href": "posts/subcellular/index.html",
    "title": "Analyzing genes’ subcellular localization",
    "section": "",
    "text": "1 Introduction\nRNA transcript locations are a standard output of CosMx experiments, but it’s uncommon for data analysis to make use of them. We speculate that the localization of transcripts within cells might reveal some undiscovered biological gems to those willing to go searching. Here we present a small demonstration of how this information might be explored. We use a cell pellet array constructed by printing 37 cell lines onto a single slide:\n\n\n\n\n\n\n\n\n\n\n\n2 Setup\nWe ran the CosMx Human Whole Transcriptome Panel, and collected a single FOV from each cell line. This produced 18935-plex data with between 600-3400 cells per cell line. Typical for a cell line experiments, this study produced great data, with the average cell returning &gt;4000 counts.\nStandard CosMx output includes each transcript’s cellular compartment: nucleus, cytoplasm, or membrane. For this simple demonstration, we focus on the nucleus and cytoplasm, where most transcripts are found. Our analysis was straightforward: for each cell line, we simply took the log2 ratio of each gene’s expression in the nucleus vs. in the cytoplasm. This allowed us to identify genes with bias towards either compartment, and to study how cell lines differ in regard to subcellular localization.\n\n\n3 Results\nNuclear and cytoplasmic expression tended to track each other for most genes, with a small subset of genes showing strong enrichment in the nucleus. For example, see the results from the 22RV1 cell line:\n\n\n\n\n\n\n\n\n\nTo create a census of nucleus-enriched genes, we recorded all genes attaining 4-fold enrichment in the nucleus vs. the cytoplasm in at least one cell line:\n\n\n\n\n\n\n\n\n\nFinally, we looked for genes whose nuclear/cytoplasmic ratio changed across cell lines. One top hit was RPLP2:\n\n\n\n\n\n\n\n\n\n\n\n4 Discussion\nThis post demonstrates the possibility of studying genes’ subcellular locations within and across cell types. Other, more complicated approaches are of course possible. RNA velocity can be estimated from the nuclear/cytoplasmic ratio, using subcellular location as a proxy for how recently an mRNA molecule was transcribed, e.g. with scVelo. It should also be possible to look for genes whose transcripts tend to cluster near each other in intracellular space, or for pairs of genes that cluster. Recent packages offer a few approaches on this theme, including CellSP, BENTO, ELLA and INSTANT.\nMultiomics data will open new questions as well, for example allowing us to study whether any genes tend to fall atop the signal from any proteins. Or, even without multiomics data, we can use our morphology markers to ask questions of intracellular locations, for example, in the below image, what genes have been captured in the vesicles?"
  },
  {
    "objectID": "posts/image-segmentation-models/index.html",
    "href": "posts/image-segmentation-models/index.html",
    "title": "Advancing cell segmentation in spatial omics: new models for diverse morphologies",
    "section": "",
    "text": "Cell segmentation is a foundational step in spatial omics analysis. Inaccurate boundaries can lead to the misassignment of transcripts or proteins, ultimately distorting cellular profiles and downstream interpretations. To address this, we developed a robust image-based segmentation pipeline that leverages deep learning to generate accurate and biologically meaningful cell masks across a wide range of tissue types and imaging conditions.\nIn this post, we introduce our full segmentation pipeline and describe the three custom-trained models that power it. These models improve segmentation fidelity by tailoring input channels, training data composition, and post-processing workflows to specific biological challenges.\nLike other items in our CosMx Analysis Scratch Space, the usual caveats and license applies.\nYou can cite this post as electronic materials in various formats shown below.\n\nAPAMLABibTeXRISEndNote\n\n\nWu, L., Wardhani, A., & Phan, J. (2025). Advancing cell segmentation in spatial omics: new models for diverse morphologies. Retrieved from https://nanostring-biostats.github.io/CosMx-Analysis-Scratch-Space/posts/image-segmentation-models/\n\n\nWu, Lidan, Aster Wardhani, and Joseph-Tin Phan. Advancing cell segmentation in spatial omics: new models for diverse morphologies. 16 Jul 2025, https://nanostring-biostats.github.io/CosMx-Analysis-Scratch-Space/posts/image-segmentation-models/\n\n\n@misc{Wu2025CosMxCellSeg\n  title = {Advancing cell segmentation in spatial omics: new models for diverse morphologies},\n  author = {Lidan Wu and Aster Wardhani and Joseph-Tin Phan},\n  year = {2025},\n  url = {https://nanostring-biostats.github.io/CosMx-Analysis-Scratch-Space/posts/image-segmentation-models/},\n  note = {Accessed: 2026-01-29}\n}\n\n\nTY  - ELEC\nTI  - Advancing cell segmentation in spatial omics: new models for diverse morphologies\nAU  - Lidan Wu\nAU  - Aster Wardhani\nAU  - Joseph-Tin Phan\nPY  - 2025\nUR  - https://nanostring-biostats.github.io/CosMx-Analysis-Scratch-Space/posts/image-segmentation-models/\nER  -\n\n\n%0 Electronic Article\n%T Advancing cell segmentation in spatial omics: new models for diverse morphologies\n%A Lidan Wu\n%A Aster Wardhani\n%A Joseph-Tin Phan\n%D 2025\n%U https://nanostring-biostats.github.io/CosMx-Analysis-Scratch-Space/posts/image-segmentation-models/"
  },
  {
    "objectID": "posts/image-segmentation-models/index.html#nuclear-segmentation-model",
    "href": "posts/image-segmentation-models/index.html#nuclear-segmentation-model",
    "title": "Advancing cell segmentation in spatial omics: new models for diverse morphologies",
    "section": "3.1 Nuclear Segmentation Model",
    "text": "3.1 Nuclear Segmentation Model\nDesigned to work across many tissue types, this model takes a single-channel nuclear stain (e.g., DAPI, Histone stain) as input. It prioritizes accuracy in nucleus identification, even in densely packed or noisy imaging conditions. This model forms the backbone for subcellular compartment labeling."
  },
  {
    "objectID": "posts/image-segmentation-models/index.html#generic-segmentation-model",
    "href": "posts/image-segmentation-models/index.html#generic-segmentation-model",
    "title": "Advancing cell segmentation in spatial omics: new models for diverse morphologies",
    "section": "3.2 Generic Segmentation Model",
    "text": "3.2 Generic Segmentation Model\nThis model segments complete cell boundaries using two imaging channels: a required channel for general cytoplasmic or membrane staining, and an optional channel for nuclear staining. It is optimized for tissues with relatively uniform morphology and minimal extended protrusions, such as non-neural samples."
  },
  {
    "objectID": "posts/image-segmentation-models/index.html#neural-segmentation-model",
    "href": "posts/image-segmentation-models/index.html#neural-segmentation-model",
    "title": "Advancing cell segmentation in spatial omics: new models for diverse morphologies",
    "section": "3.3 Neural Segmentation Model",
    "text": "3.3 Neural Segmentation Model\nTo address the unique challenges of brain tissue, including highly irregular cell shapes, long processes, and closely apposed glial and neuronal cells, we developed a neural-specific model that uses three channels: nuclear, neuronal, and glial stains. This model more accurately segments astrocytes, neurons with elongated axons, and densely packed cerebellum regions.\n\n\n\n\n\n\nFigure 2: Neural cell segmentation model: input and output overview. Morphological stains from brain tissue—nuclear (green), neuronal (red), and glial (blue) markers—are combined into 3-channel inputs to the neural segmentation model (top panel). The Cellpose-style model processes these inputs to produce cell probability maps and spatial gradients (bottom panel), which are used to reconstruct accurate cell masks, even for complex neural morphologies."
  },
  {
    "objectID": "posts/panel-comparison/index.html",
    "href": "posts/panel-comparison/index.html",
    "title": "Guide to comparing data from different CosMx® panels",
    "section": "",
    "text": "Choosing the right panel for a spatial transcriptomics study is not always a trivial exercise. Higher-plex panels have the obvious appeal of more data per cell and a view into a greater scope of biology, while lower-plex panels are lower-cost and faster to run. To help choose a panel, investigators often run the same tissue through multiple panels. Here we recommend analyses for these datasets.\nThere are a lot of ways to compare two datasets, and a lot of energy is spent comparing metrics like plex, counts per cell, counts per gene per cell, background levels, segmentation accuracy, etc… (Perhaps even more energy is spent arguing about which of these metrics are most important.) What actually matters, of course, isn’t any single metric: it’s the richness of biological insight you are able to extract from a dataset. While data quality is important, its importance lies entirely in how it impacts your ability to extract biological conclusions from your data. To get at the rather broad concept of “biological richness”, we suggest two standard analyses:\n\nHow deep and clean are the cell typing results?\nHow much do you learn from a differential expression analysis?\n\nWe suggest these comparisons because they capture the two key phases of most analyses. You begin with cell typing, characterizing the basic layout of your tissue. Then, perhaps after exploratory analyses, you ask a specific biological question. Very often, this question takes the form of a differential expression analysis. For example, “How do tumor cells respond when proximal to T-cells?”, “How do microglia react to amyloid beta plaques?”, or “How do intratumoral macrophages differ in responders vs. non-responders?” Thus by performing a relevant differential expression analysis, we can get a sense of the richness of results produced by two panels.\nTo demonstrate this approach, compare CosMx Human 6k Discovery Panel results and CosMx Human Whole Transcriptome Panel results collected from serial sections from a colorectal tumor. Use the code below as a template for running similar comparisons in your own data (after QC, normalization, etc…)."
  },
  {
    "objectID": "posts/panel-comparison/index.html#gaining-a-gestalt-of-cell-type-resolution",
    "href": "posts/panel-comparison/index.html#gaining-a-gestalt-of-cell-type-resolution",
    "title": "Guide to comparing data from different CosMx® panels",
    "section": "2.1 Gaining a gestalt of cell type resolution",
    "text": "2.1 Gaining a gestalt of cell type resolution\nFirst, we’ll ask a simple, high-level question: how many cell types can be detected, and how well-resolved are they? Our goal here is not to carefully validate every cell type call; rather, we just want to get a sense of how rich and crisp the cell typing results are. Our usual expectation is that a given tissue has 10-20 highly distinct cell types, and that most panels are sufficient to resolve them.\n(Beyond broad cell types, we may wish for more nuanced dissection of cell states. We will get at this ability with an analysis of T-cell subtyping accuracy, and with differential expression analysis, which characterizes changes within a cell type across space.)\nTo get at a general sense of the cell type granularity you can see with each panel, we’ll simply run unsupervised clustering and UMAP. Below is code to quickly perform these steps beginning with a Seurat object exported from AtoMx® SIP:\n\n# get hvgs, scale and run PCA:\nseu &lt;- NormalizeData(seu) \nseu &lt;- FindVariableFeatures(seu, selection.method = \"vst\", nfeatures = 3000)\nseu &lt;- ScaleData(seu, features = VariableFeatures(seu))\nseu &lt;- RunPCA(seu, features = VariableFeatures(seu))\n\n# cluster:\nseu &lt;- FindClusters(seu, resolution = 1)\n\n# umap:\nseu &lt;- RunUMAP(seu, dims = 1:30, n.neighbors = 40, metric = \"cosine\", min.dist = 0.01, spread = 5)\n\n# plot umap and cell types:\ndistinct_colors &lt;- c(\n  \"#e6194b\", \"#3cb44b\", \"#ffe119\", \"#0082c8\", \"#f58231\", \"#911eb4\", \"#46f0f0\", \"#f032e6\",\n  \"#d2f53c\", \"#fabebe\", \"#008080\", \"#e6beff\", \"#aa6e28\", \"#fffac8\", \"#800000\", \"#aaffc3\",\n  \"#808000\", \"#ffd8b1\", \"#000080\", \"#808080\", \"#FFFFFF\", \"#000000\", \"#a9a9a9\", \"#DC143C\",\n  \"#00FFFF\", \"#7FFF00\", \"#FF7F50\", \"#6495ED\", \"#DC143C\", \"#00CED1\", \"#FFD700\", \"#ADFF2F\",\n  \"#4B0082\", \"#FF69B4\", \"#CD5C5C\", \"#20B2AA\", \"#9370DB\", \"#3CB371\", \"#FF4500\", \"#DA70D6\",\n  \"#7B68EE\", \"#00FA9A\", \"#B22222\", \"#5F9EA0\"\n)\n\nDimPlot(seu, cols = rep(distinct_colors, 10)) + NoLegend()\n\n\n\n\n\n\n\n\n\n\nWhile the UMAP plots appear quite different at first, we see on closer examination that the broad structure is similar in both cases, with the same islands and bridges and largely the same clustering results in both datasets. If we were inclined to do so, modifying the UMAP parameters could probably make either dataset more strongly resemble the other. So in this example, our check for cell type resolution comes in reassuringly as a tie.\nFor a more thorough evaluation of cell typing quality, consider the following additional analyses:\n\nPlot cell types in physical space and confirm biological sanity\nRun a marker ID heatmap and confirm that markers for distinct cell types concentrate in different clusters."
  },
  {
    "objectID": "posts/panel-comparison/index.html#evaluating-accuracy-of-fine-grained-cell-typing",
    "href": "posts/panel-comparison/index.html#evaluating-accuracy-of-fine-grained-cell-typing",
    "title": "Guide to comparing data from different CosMx® panels",
    "section": "2.2 Evaluating accuracy of fine-grained cell typing",
    "text": "2.2 Evaluating accuracy of fine-grained cell typing\nWe also want to assess the quality of cell typing. For this comparison, we’ll focus on immune cells, which are convenient because there is widespread agreement about their marker genes and because they appear in most tissues. If your tissue in question has very few immune cells (say, &lt;2000), you may want to assess cell typing accuracy with other cell types.\nFor immune cell typing, we recommend our newly-released method HieraType.\nUse the below code to quickly identify and subtype immune cells, then produce a heatmap of marker genes. This code picks up where the previous left off. Specifically, it assumes we have a Seurat object, including UMAP results. See the HieraType package documentation for how to run outside the Seurat ecosystem.\nNote: to prevent background counts from confusing the evaluation of marker heatmaps, we’ll subtract background from each cluster’s mean expression profile prior to plotting. A cluster’s mean negprobe counts gives us a fairly accurate estimate of the level of background in its marker genes counts.\n\n# install HieraType:\nif (FALSE) {\n  remotes::install_github(\"Nanostring-Biostats/CosMx-Analysis-Scratch-Space\", \n                          subdir = \"_code/HieraType\", ref = \"Main\")\n}\n# load package:\nlibrary(HieraType)\nlibrary(ggplot2)\n\n# define a pipeline to automatically call broad cell types then proceed through fine T-cell subtypes:\nct_pipeline &lt;- make_pipeline(\n  markerslists = list(\"l1\" = HieroType::markerslist_l1,\n                      \"l2\" = HieroType::markerslist_immunemajor,\n                      \"lt\" = HieroType::markerslist_tcellmajor,\n                      \"lt4\" = HieroType::markerslist_cd4tminor,\n                      \"lt8\" = HieroType::markerslist_cd8tminor\n  ),\n  priors = list(\"l2\" = \"l1\",\n                 \"lt\" = \"l2\",\n                 \"lt4\" = \"lt\",\n                 \"lt8\" = \"lt\"\n  ),\n  priors_category = list(\"l2\" = \"immune\",\n                         \"lt\" = \"tcell\",\n                         \"lt4\" = \"cd4t\",\n                         \"lt8\" = \"cd8t\"\n  )\n)\n\nhtres &lt;-  HieroType::run_pipeline(\n  pipeline = ct_pipeline,\n  counts_matrix = Matrix::t(seu[[\"RNA\"]]@counts),\n  adjacency_matrix = as(seu@graphs$umapgrph, \"dgCMatrix\")\n)\n\n# primary result: the cell type calls and posterior probabilities:\nprobdf &lt;- htres$post_probs$l1\n\n## prepare data for marker gene heatmap:\nfc_subclus_ctl_gran &lt;- clusterwise_foldchange_metrics(counts = seu[[\"RNA\"]]@counts,\n                                                      metadata = htres$post_probs[[1]],\n                                                      cluster_column = \"celltype_granular\"\n)\n# subtract background from the mean per-cluster expression profiles:\nfor (name in unique(htres$post_probs[[1]]$celltype_granular)) {\n  isthiscelltype &lt;- htres$post_probs[[1]]$celltype_granular == name\n  meannegthiscelltype &lt;- Matrix::mean(seu@assays$negprobes$counts[, isthiscelltype])\n  \n  fc_subclus_ctl_gran$cluster_expr[fc_subclus_ctl_gran$cluster == name] &lt;- \n    pmax(fc_subclus_ctl_gran$cluster_expr[fc_subclus_ctl_gran$cluster == name] - meannegthiscelltype, 0)\n}\n# create the heatmap:\nhm_unsup &lt;- marker_heatmap(fc_subclus_ctl_gran,\n                           extras = c(\"CD3D\", \"CD4\", \"FOXP3\", \"CD8B\", \"CD8A\")\n)\nprint(hm_unsup)\n\nThe marker heatmaps from both datasets are below, first 6k, then WTX:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFor most purposes, we won’t care about small differences between these heatmaps; rather, we just want to check that both sets of cell typing results are sane at an equivalently granular level. Comparing the marker gene heatmaps from both datasets, we see basic sanity in both cases, and cleaner marker profiles in the WTX data, suggesting either more accurate cell typing or better cell segmentation.\nWe’ll also want to look at our cell type calls in space as a final sanity check."
  },
  {
    "objectID": "posts/segmentation-error-evaluation/index.html",
    "href": "posts/segmentation-error-evaluation/index.html",
    "title": "Evaluating Cell Segmentation Error based on Transcriptional Spatial Profiles using FastReseg",
    "section": "",
    "text": "1 Introduction\nAccurate cell segmentation that assigns transcripts to cell locations is critical to data quality of spatial transcriptomics assays and the proper interpretation of downstream differential expression analysis results. But it’s very challenging for tissue sections where cells are tightly packaged with shared, 3D boundaries and uneven morphology staining.\nThe FastReseg R package offers a rapid way to evaluate the performance of existing cell segmentation and to perform refinement given the spatial transcriptional profiles.\n\nThe evaluation process starts with a cluster-specific reference expression profiles that are either derived from cell typing of query spatial data set given its current image-based cell segmentation or from external non-spatial data sets, like scRNA-seq.\nGiven the provided reference profiles, FastReseg algorithm scores individual transcripts for the goodness-of-fit within their respective cells based on the probability of each gene belonging to each cell type.\nFastReseg then scores each cell for its spatial dependency of transcript score profiles under its most likely cell type given the overall transcriptional profiles. As confirmed by the membrane-stained images, cells with boundary errors at the junction of different cell types, exhibit strong spatial dependency in their transcript score profile and thus can be easily identified.\nFastReseg further identifies the spatially connected groups of transcripts with low goodness-of-fit within incorrectly segmented cells.\nA set of heuristic rules on neighborhood cell typing and transcript number are then applied to the identified transcript groups to decide on the re-segmentation actions, like merging, splitting and trimming. The re-segmented results show no significant spatial dependency on transcript score of individual cells, suggesting the successful correction of poorly segmented cells.\n\n\n\n\n\n\n\nFigure 1: Schematic of FastReseg workflow\n\n\n\nYou can find the FastReseg package here. See the corresponding tutorial inside the package for more details. Additional resources regarding the working principles, performance characterization and impact of some tuning parameters could be found in FastReseg manuscript (Wu, Beechem, and Danaher 2025).\nThe required inputs for FastReseg include:\n\ncounts: a cell-by-gene counts matrix for entire dataset.\nclust: a vector of cluster assignments for each cell in counts; use NULL to automatically assign the cell cluster for each cell based on maximum transcript score of given the provided refProfiles.\nrefProfiles: a gene-by-cluster matrix of cluster-specific expression profiles; default = NULL to use external cluster assignments.\ntransDF_fileInfo: a data.frame with each row for each individual file of per-FOV transcript data.frame, columns include the file path of per FOV transcript data.frame file, annotation columns like slide and fov to be used as prefix when creating unique cell_ID across entire dataset.\n\nwhen NULL, use the transcript data.frame transcript_df directly.\n\n\nThis post will show you how to prepare your inputs if you have data assembled in the structure used by the Technology Access Program (TAP); similar outputs are available from the AtoMx® Spatial Informatics Portal (SIP). You can download an example public dataset from here. The ReadMe associated with this example data set on pancreas shows the data structures of each file used in this post. For AtoMx users (version 2.0.1 or later), a custom module is also available to run FastReseg analysis directly on CosMx® RNA studies hosted within the AtoMx® SIP platform.\n\nSection 2 Prepare inputs from basic data files\nSection 3 Run segmentation evaluation\nSection 4 Run full pipeline to correct putative segmentation error identified\n\nLike other items in our CosMx Analysis Scratch Space, the usual caveats and license applies.\n\n\n2 Prepare inputs from basic data files\nHere we start from the basic data files exported from AtoMx® SIP.\nWhile one can use cluster-specific expression profiles from other studies as refProfiles, here we take advantages of the existing cell typing derived from current cell segmentation in this data set and use it as clust.\n\n# load existing cell typing results \ncellTypeRes &lt;- readRDS(\"CellType_Accessory_Data/Pancreas_celltype_InSituType.rds\")\n\nvalidCells &lt;- cellTypeRes[['cell_ID']]\nclust &lt;- setNames(cellTypeRes[['cell_types']], nm = cellTypeRes[['cell_ID']])\n\nInspecting the cell typing results and the ReadMe associated with this data set, we can know that this data set uses c_[slide ID]_[fov ID]_[cell ID] format to get cell ids unique across entire data set.\nWe next to load raw expression matrix for all genes and cells with available cell typing results.\n\n# load raw expression matrix and assign unique cell_ID to each one \ncounts &lt;- data.table::fread(\"Pancreas_exprMat_file.csv\")\n\n# use same slide ID as the existing cell typing results\ncell_ids &lt;- paste0('c_1_', counts[['fov']], '_', counts[['cell_ID']])\n\n# get valid gene names\nall_rnas &lt;- grep(\"fov|cell_ID|Negative|SystemControl\", \n                 colnames(counts), value = TRUE, invert = TRUE)\n\ncounts &lt;- as.matrix(counts[, .SD, .SDcols = all_rnas])\nrownames(counts) &lt;- cell_ids\n\ncounts &lt;- as(counts[validCells, , drop = FALSE], \"sparseMatrix\") \n\nWe then load the transcript file which contains all molecules’ coordinates and cell segmentation information. For faster processing in downstream FastReseg pipeline that is paralleled by input transcript files for different spatial regions, we recommend to split the full transcript data into multiple files by FOV (Field of View) and export those per-FOV transcript information as individual csv files. We would pass their file paths to FastReseg functions through transDF_fileInfo data.frame.\n\nfullTx &lt;- data.table::fread(\"Pancreas_tx_file.csv\")\n\n# add unique id for each transcript\nfullTx[['transcript_id']] &lt;- seq_len(nrow(fullTx))\n\n# remove extracellular transcripts which has cell_ID = 0 in tx file \nfullTx &lt;- fullTx[cell_ID !=0, ]\n\n# keep only the necessary info\nfullTx &lt;- fullTx[, .SD, .SDcols = c('transcript_id', 'cell', 'x_global_px', \n                                    'y_global_px', 'z', 'target', 'fov')]\n\n# split by FOV and export as per FOV csv file\ntxDir &lt;- \"perFOV_txFile\"\nif(!dir.exists(txDir)) dir.create(txDir)\n\nallFOVs &lt;- unique(fullTx[['fov']])\n\ntransDF_fileInfo &lt;- lapply(allFOVs, function(fovId){\n  perFOV_filePath &lt;- fs::path(txDir, paste0('fov_', fovId, '_tx_data.csv'))\n  data.table::fwrite(fullTx[fov == fovId, ], file = perFOV_filePath)\n  \n  # since global coordinates of each molecule are available\n  # use 0 for stage coordinates to disable conversion of local to global coordinates\n  df &lt;- data.frame(file_path = perFOV_filePath, \n                   slide = 1, \n                   fov = fovId, \n                   stage_X = 0, \n                   stage_Y = 0)\n  return(df)\n})\n\ntransDF_fileInfo &lt;- do.call(rbind, transDF_fileInfo)\n\nFastReseg evaluates segmentation in physical space and thus it’s preferred to convert all 3D coordinates into same unit. The relevant default parameters of FastReseg are set with respect to micrometer in coordinate unit. According to the ReadMe, the pixel size for this data set is 0.12028 µm per pixel and the z step size is 0.8 µm per z slice. We would pass this information to FastReseg functions to do the coordinate conversion. If your data is already in micrometer unit, you can use 1 for pixel size and z step to disable the conversion.\n\npixel_size &lt;- 0.12028\nzstep_size &lt;- 0.8\n\nBy default, FastReseg would use 75% of available cores on your PC to do parallel processing of per-FOV transcript files in batch. If you have big per-FOV transcript file size (200+ MB per file) or limited memory available, it’s recommended to reduce the amount of cores used. You can control the number of cores in use by passing percentCores argument to FastReseg wrapper functions or set the core number directly with options(mc.cores = X), where X is the number of cores you would like to use. The set option approach would overwrite the percentCores argument.\n\n\n\n\n\n\nNote\n\n\n\nToo many large FOVs being processed in same batch could hit the memory limit and abort the current processing. Below is an example error message when memory limit was reached.\n Error in FUN(X[[i]], …) : subscript out of bounds In addition: Warning messages: 1: In parallel::mclapply(X = seq_len(nrow(transDF_fileInfo)), mc.allow.recursive = TRUE, : scheduled cores 1, 3, 4, 7, 8, 10, 11 did not deliver results, all values of the jobs will be affected 2: In parallel::mclapply(X = seq_len(nrow(transDF_fileInfo)), mc.allow.recursive = TRUE, : scheduled core 12 encountered error in user code, all values of the job will be affected \n\n\nSince the example data set in use is a Whole Transcriptome (WTx) spatial data set with high number of unique genes and large per-FOV transcript file size, here we cautiously reduce the % of core number to 0.25.\n\npercentCores &lt;- 0.25\n\n\n\n3 Run segmentation evaluation\nNow we have all the inputs needed to run FastReseg pipelines. For segmentation evaluation, one can use FastReseg::fastReseg_flag_all_errors() function to run through all the FOVs.\n\n# path to output folder\noutDir_flagErrors &lt;- \"res1f_flagErrors\"\n\nflagAll_res &lt;- FastReseg::fastReseg_flag_all_errors(\n  counts = counts,\n  clust = clust,\n  refProfiles = NULL,\n  \n  # one can use `clust = NULL` if providing `refProfiles`\n  \n  transcript_df = NULL,\n  transDF_fileInfo = transDF_fileInfo,\n  filepath_coln = 'file_path',\n  prefix_colns = NULL, # to use existing cell IDs that are unique across entire data set \n  fovOffset_colns = c('stage_Y','stage_X'), # match XY axes between stage and each FOV\n  pixel_size = pixel_size, \n  zstep_size = zstep_size,\n  transID_coln = 'transcript_id', \n  transGene_coln = \"target\",\n  cellID_coln = \"cell\", \n  spatLocs_colns = c('x_global_px', 'y_global_px', 'z'),\n  extracellular_cellID = NULL, \n  \n  # control core number used for parallel processing\n  percentCores = percentCores, \n  \n  # cutoff of transcript number to do spatial modeling\n  flagModel_TransNum_cutoff = 50, \n  \n  flagCell_lrtest_cutoff = 5, # cutoff for flagging wrongly segmented cells\n  svmClass_score_cutoff = -2, # cutoff for low vs. high transcript score\n  path_to_output = outDir_flagErrors, # path to output folder\n  return_trimmed_perCell = TRUE, # flag to return per cell expression matrix after trimming all flagged transcripts \n  ctrl_genes = NULL # optional to include name for control probes in transcript data.frame, e.g. negative control probes\n  )\n\n# extract spatial evaluation outcomes of valid cells\nmodStats_ToFlagCells &lt;- flagAll_res[['combined_modStats_ToFlagCells']]\n\nThe function above returns the statistics for evaluating each cell for spatial dependent model against null model. Based on the P value lrtest_Pr or the negative log10 value lrtest_nlog10P, one can select for cells with strong spatial dependency in transcript score profile. Those cells are likely to contain contaminating transcripts for neighbor cells.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ntranscript_num\nmodAlt_rsq\nlrtest_ChiSq\nlrtest_Pr\nUMI_cellID\nlrtest_nlog10P\ntLLR_maxCellType\nflagged\nfile_idx\n\n\n\n\n315\n0.1076159\n35.86547\n0.0000419\nc_1_51_1\n4.377932\nMacrophage\nFALSE\n1\n\n\n309\n0.0744980\n23.92246\n0.0044256\nc_1_51_10\n2.354028\nDuctal\nFALSE\n1\n\n\n1676\n0.0976644\n172.24037\n0.0000000\nc_1_51_100\n31.676496\nDuctal\nTRUE\n1\n\n\n753\n0.0928050\n73.34062\n0.0000000\nc_1_51_1000\n11.974934\nDuctal\nTRUE\n1\n\n\n892\n0.1512712\n146.30190\n0.0000000\nc_1_51_1001\n26.936616\nDuctal\nTRUE\n1\n\n\n1220\n0.0802211\n102.01879\n0.0000000\nc_1_51_1002\n17.211741\nAcinar.2\nTRUE\n1\n\n\n\n\n# histogram for spatial dependency in all cells\ntmp_flag &lt;- which(!is.na(modStats_ToFlagCells$lrtest_nlog10P)) # exclude cells with too few transcript number\nhist(modStats_ToFlagCells$lrtest_nlog10P[tmp_flag], \n     breaks = \"FD\", \n     xlab = \"-log10(lrtest p.value)\",\n     main = paste0(\"Histogram of spatial dependency, mean = \", \n                   round(mean(modStats_ToFlagCells$lrtest_nlog10P[tmp_flag]), 2)))\nabline(v = mean(modStats_ToFlagCells$lrtest_nlog10P[tmp_flag]), col=\"red\", lwd=3, lty=2)\n\n\n\n\n\n\n\n\n\n# cutoff to flag for cells with strong spatial dependency in transcript score profiles\nflagCell_lrtest_cutoff  = 5\n\nmodStats_ToFlagCells[['flagged']] &lt;- (modStats_ToFlagCells[['lrtest_nlog10P']] &gt; flagCell_lrtest_cutoff )\nflagged_cells &lt;- modStats_ToFlagCells[['UMI_cellID']][modStats_ToFlagCells[['flagged']]]\n\nmessage(sprintf(\"%d cells, %.4f of all evaluated cells, \\nare flagged for resegmentation with lrtest_nlog10P &gt; %.1f.\", \n                 length(flagged_cells), length(flagged_cells)/nrow(modStats_ToFlagCells), flagCell_lrtest_cutoff))\n\n33210 cells, 0.6791 of all evaluated cells, \nare flagged for resegmentation with lrtest_nlog10P &gt; 5.0.\n\n\nLet’s visualize some flagged cells with various degrees of spatial dependency in transcript profiles\n\n# focus on 1st per-FOV file\ntranscript_df &lt;- read.csv(paste0(outDir_flagErrors, \"/1_flagged_transDF.csv\"))\n\nrownames(modStats_ToFlagCells) &lt;- modStats_ToFlagCells$UMI_cellID\ncells_to_plot &lt;- modStats_ToFlagCells[flagged_cells, 'lrtest_nlog10P']\nnames(cells_to_plot) &lt;- flagged_cells\n\ncells_to_plot &lt;- cells_to_plot[flagged_cells %in% transcript_df[[\"UMI_cellID\"]]]\n\ncells_to_plot &lt;- cells_to_plot[order(cells_to_plot, decreasing = T)]\ncells_to_plot &lt;- cells_to_plot[seq(1, length(cells_to_plot), \n                                   by = ceiling(length(cells_to_plot)/25))]\n\nFastReseg::plotSpatialScoreMultiCells(chosen_cells = names(cells_to_plot), \n                                      cell_labels = round(cells_to_plot, 2), \n                                      transcript_df = transcript_df, \n                                      cellID_coln = \"UMI_cellID\", \n                                      transID_coln = \"UMI_transID\",\n                                      score_coln = \"score_tLLR_maxCellType\", \n                                      spatLocs_colns = c(\"x\",\"y\"),\n                                      point_size = 0.5)\n\n\nYou can see that cells with large lrtest_nlog10P value exhibited strong spatial dependency in their transcript score profiles under their best fitted cell type (i.e. score_tLLR_maxCellType). Below we would zoom in to one of the flagged cells (c_1_51_1211 with lrtest_nlog10P = 49.82) and visualize its transcript score profiles in 3D.\n\ndata = FileAttachment(\"assets/chosenCell_flagged_transDF.csv\").csv({ typed: true })\n\n\n\n\n\n\n\nviewof colorColumn = Inputs.select(\n  ['score_tLLR_maxCellType'], \n  { label: 'Colored by', \n    value: 'score_tLLR_maxCellType'\n  }\n)\n\nviewof lowerLimit = Inputs.range(\n  [-10, 0], \n  { label: 'Lower Limit', \n    value: -10, \n    step: 0.1\n  }\n)\n\nviewof upperLimit = Inputs.range(\n  [-10, 0], \n  { label: 'Upper Limit', \n    value: 0, \n    step: 0.1\n  }\n)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nPlotly = await require(\"https://cdn.plot.ly/plotly-2.32.0.min.js\")\n\n// document element for plot\nplotDiv = {\n  const div = html`&lt;div id=\"plotlyDiv\" style=\"width:100%;height:600px;\"&gt;&lt;/div&gt;`;\n  return div;\n}\n\n\n// Function to create the 3D scatter plot\nfunction createPlot(data, colorColumn, lowerLimit, upperLimit, div) {\n  div=div||DOM.element('div')\n  div.id=\"plotlyDiv\"\n  \n  var trace = {\n    x:data.map(d =&gt; d.x),\n    y:data.map(d =&gt; d.y),\n    z:data.map(d =&gt; d.z),\n    mode: 'markers',\n     marker: {\n        size: 3,\n        color: data.map(d =&gt; d[colorColumn]),\n        colorscale: [\n          [0.000, \"rgb(252, 253, 191)\"], \n          [0.056, \"rgb(252, 236, 173)\"],\n          [0.111, \"rgb(253, 218, 156)\"],\n          [0.167, \"rgb(254, 201, 141)\"],\n          [0.222,\"rgb(254, 183, 126)\"],\n          [0.278, \"rgb(254, 167, 114)\"],\n          [0.333, \"rgb(253, 149, 103)\"],\n          [0.389, \"rgb(251, 131, 95)\"],\n          [0.444,\"rgb(247, 113, 92)\"],\n          [0.500, \"rgb(241, 96, 93)\"],\n          [0.556, \"rgb(232, 83, 98)\"],\n          [0.611, \"rgb(219, 71, 106)\"],\n          [0.667, \"rgb(205, 64, 113)\"],\n          [0.722, \"rgb(189, 57, 119)\"],\n          [0.778, \"rgb(174, 52, 123)\"],\n          [0.833, \"rgb(159, 47, 127)\"],\n          [0.889, \"rgb(0, 149, 175)\"],\n          [0.944, \"rgb(0, 93, 158)\"], \n          [1.000, \"rgb(38, 24, 95)\"]\n        ],\n        showscale: true,\n        cmin: Math.min(lowerLimit, upperLimit), \n        cmax: Math.max(lowerLimit, upperLimit), \n        colorbar: { title: colorColumn }\n      },\n    type: 'scatter3d',\n    text: data.map(d =&gt; `target: ${d.target}&lt;br&gt;score_tLLR_maxCellType:&lt;br&gt;${d.score_tLLR_maxCellType}`),\n    hoverinfo: 'text'\n  }\n  \n  Plotly.newPlot(div,[trace],{})\n  return div\n  \n \n}\n\n\nfigDiv = createPlot(data, colorColumn, lowerLimit, upperLimit, plotDiv)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n4 Run full pipeline to correct putative segmentation error identified\nIf cell segmentation correction is desired, one can use FastReseg::fastReseg_full_pipeline() function to not only flag but also correct the identified putative cell segmentation errors.\n\n\n\n\n\n\nNote\n\n\n\nThe current defaults for separating out poor-fit transcripts are on the conservative ends. To make the separation more aggressive with less constraint in spatial neighborhood, please refer to the manual of e1071::svm() function on what arguments one can adjust and pass to the FastReseg functions via svm_args list variable. Example arguments include kernel type, scale, gamma and type of svm classification machine.\n\n\n\n\n\n\n\n\nInclude control probes\n\n\n\nIf you would like to keep the control probes, e.g. negative probes, in the post-resegmentation data, you can pass the names of those control probes as a vector to the function via ctrl_genes argument. Those ctrl_genes would be assigned with same transcript scores under all cell types and thus the only way they changed their cell ID assignment would be due to the presence of poor-fit transcriptional zone in proximity. Of note, to avoid significant interference from those ctrl_genes, it’s recommended to have total counts of those genes below 1% of total counts of all genes in each cell.\n\n\n\n# path to output folder\noutDir_full &lt;- \"res2_fullPipeline\"\n\nrefineAll_res &lt;- FastReseg::fastReseg_full_pipeline(\n  counts = counts,\n  clust = clust,\n  refProfiles = NULL,\n  \n  # one can use `clust = NULL` if providing `refProfiles`\n  \n  transcript_df = NULL,\n  transDF_fileInfo = transDF_fileInfo,\n  filepath_coln = 'file_path',\n  prefix_colns = NULL, # to use existing cell IDs that are unique across entire data set \n  fovOffset_colns = c('stage_Y','stage_X'),\n  pixel_size = pixel_size,\n  zstep_size = zstep_size,\n  transID_coln = 'transcript_id',\n  transGene_coln = \"target\",\n  cellID_coln = \"cell\",\n  spatLocs_colns = c('x_global_px', 'y_global_px', 'z'),\n  extracellular_cellID = NULL,\n  \n  # control core number used for parallel processing\n  percentCores = percentCores, \n  \n  # cutoff of transcript number to do spatial modeling\n  flagModel_TransNum_cutoff = 50, \n  \n  # Optionally, one can set various cutoffs to NULL for automatic calculation from input data\n  # Refer to `FastReseg::runPreprocess()` for more details\n  \n  # distance cutoff for neighborhood searching at molecular and cellular levels, respectively\n  molecular_distance_cutoff = 2.7, # 2.7um is recommended for CosMx RNA dataset\n  cellular_distance_cutoff = NULL, \n  \n  # cutoffs for transcript scores and number for cells under each cell type\n  score_baseline = NULL,\n  lowerCutoff_transNum = NULL,\n  higherCutoff_transNum= NULL,\n  imputeFlag_missingCTs = TRUE,\n  \n  # Settings for error detection and correction, refer to `FastReseg::runSegRefinement()` for more details\n  flagCell_lrtest_cutoff = 5, # cutoff to flag for cells with strong spatial dependency in transcript score profiles\n  svmClass_score_cutoff = -2,   # cutoff of transcript score to separate between high and low score classes\n  groupTranscripts_method = \"dbscan\",\n  spatialMergeCheck_method = \"leidenCut\", \n  cutoff_spatialMerge = 0.5, # spatial constraint cutoff for a valid merge event\n  \n  path_to_output = outDir_full,\n  save_intermediates = TRUE, # flag to return and write intermediate results to disk\n  return_perCellData = TRUE, # flag to return per cell level outputs from updated segmentation \n  combine_extra = FALSE # flag to include trimmed and extracellular transcripts in the exported `updated_transDF.csv` files \n)\n\nThe re-segmentation pipeline would generate new transcript data.frame and cell expression matrix after the segmentation refinement. The updated results should be treated as a new data set and go through the standard single-cell analysis pipeline, including QC, normalization, and cell typing, etc. While the updated_cellID matches with their original source cell ID in most cases, cells involved in the evaluation of a potential merging event may have their updated_cellID unrelated to their original source cell ID. You can track the change of cell assignment for each transcript group via either the reseg_actions returned by the pipeline function or the spatial coordinates of each transcript.\n\n\n5 Conclusions\nThis post serves as a quick-start guide to use FastReseg package on spatial transcriptomic data set. The package has several parameters one can adjust to tune the identification of wrongly segmented transcript groups and the rules used for cell segmentation correction. These include\n\ncutoffs for spatial model evaluation and flagging for poor-fit cells & transcripts: flagModel_TransNum_cutoff, flagCell_lrtest_cutoff, svmClass_score_cutoff;\ndistance cutoffs used to define neighborhood: molecular_distance_cutoff,cellular_distance_cutoff;\nmethod and rules used for grouping and separating poor-fit transcripts in space:svm_args, groupTranscripts_method, config_spatNW_transcript;\ncutoffs and rules used for segmentation correction: score_baseline, lowerCutoff_transNum, higherCutoff_transNum\nadditional spatial constraint on merging event during error correction: spatialMergeCheck_method, cutoff_spatialMerge\n\nMany of those parameters have reasonable defaults for most spatial data sets and could be derived from your data using FastReseg::runPreprocess() function. For new user or new sample type, it’s recommended to process just one per-FOV transcript data using FastReseg::fastReseg_perFOV_full_process() functions first and check out the impact of the parameters chosen. Please refer to FastReseg tutorial, Modular functions for individual tasks section, for more details.\n\n\n\n\n\nReferences\n\nWu, Lidan, Joseph M. Beechem, and Patrick Danaher. 2025. “Using Transcripts to Refine Image Based Cell Segmentation with FastReseg.” Scientific Reports 15 (1): 30508. https://doi.org/10.1038/s41598-025-08733-5."
  },
  {
    "objectID": "posts/visualize-cellular-neighborhood-in-gallery-mode/index.html",
    "href": "posts/visualize-cellular-neighborhood-in-gallery-mode/index.html",
    "title": "Visualize cellular neighborhood in gallery mode",
    "section": "",
    "text": "A complete CosMx dataset will contain cell metadata, morphology/protein images and cell label results of cell segmentation. We’ve created a toolkit for visualizing the neighborhood of query cells in terms of protein staining, cell segmentation border, numeric and categorical metadata. (Note: we are not performing cell typing or cell segmetnation here, just drawing boundaries from the existing cell label/segmetnation results.)\nYou can find the package here. See the corresponding tutorial inside the package for more details.\nThe inputs required:\n\ncell metadata with unique cell_ID in format of c_[slide]_[fov]_[CellId].\nEither file path to CellStatsDir that contains per FOV level of cell label images, morphology C902 images and optional ProteinDir that contains per FOV level of protein images.\nOr file path to napari-cosmx dataset which contains stitched images for cell label, morphology and optional protein images of entire slide.\n\nThis code expects the file format output generated by CosMx Single Molecular Imager (SMI) and napari-cosMx plugin. Here are the example data/folder structure of the required input files.\n\nExample cell metadata:\n\n\n\nExample CellStatsDir and ProteinDir under raw data folder of given slide.\n\nEach FOV subfolder under CellStatsDir contains cell label images of given FOV.\n\n\n\n\nMorphology2D subfolder under CellStatsDir contains multi-channel morphology images of each FOV.\n\n\n\nEach FOV subfolder under ProteinDir contains a folder called ProteinImages, which has single-channel images for all the protein profiled for the given FOV.\n\n\n\nExample napari-cosmx dataset with stitched images: labels for cell labels, protein/[proteinName] for single-channel protein images, other folders (e.g. DNA) for single-channel morphology images.\n\n\nBelow are the example outputs of plotting query cells’ neighborhood:\n\nPlotting morphology images and cell borers of query cells’s neighborhood\n\n\n\nPlotting numeric and categorical metadata of query cells’ neighborhood"
  },
  {
    "objectID": "posts/visualize-cellular-neighborhood-in-gallery-mode/index.html#visualize-cellular-neighborhood-in-gallery-mode",
    "href": "posts/visualize-cellular-neighborhood-in-gallery-mode/index.html#visualize-cellular-neighborhood-in-gallery-mode",
    "title": "Visualize cellular neighborhood in gallery mode",
    "section": "",
    "text": "A complete CosMx dataset will contain cell metadata, morphology/protein images and cell label results of cell segmentation. We’ve created a toolkit for visualizing the neighborhood of query cells in terms of protein staining, cell segmentation border, numeric and categorical metadata. (Note: we are not performing cell typing or cell segmetnation here, just drawing boundaries from the existing cell label/segmetnation results.)\nYou can find the package here. See the corresponding tutorial inside the package for more details.\nThe inputs required:\n\ncell metadata with unique cell_ID in format of c_[slide]_[fov]_[CellId].\nEither file path to CellStatsDir that contains per FOV level of cell label images, morphology C902 images and optional ProteinDir that contains per FOV level of protein images.\nOr file path to napari-cosmx dataset which contains stitched images for cell label, morphology and optional protein images of entire slide.\n\nThis code expects the file format output generated by CosMx Single Molecular Imager (SMI) and napari-cosMx plugin. Here are the example data/folder structure of the required input files.\n\nExample cell metadata:\n\n\n\nExample CellStatsDir and ProteinDir under raw data folder of given slide.\n\nEach FOV subfolder under CellStatsDir contains cell label images of given FOV.\n\n\n\n\nMorphology2D subfolder under CellStatsDir contains multi-channel morphology images of each FOV.\n\n\n\nEach FOV subfolder under ProteinDir contains a folder called ProteinImages, which has single-channel images for all the protein profiled for the given FOV.\n\n\n\nExample napari-cosmx dataset with stitched images: labels for cell labels, protein/[proteinName] for single-channel protein images, other folders (e.g. DNA) for single-channel morphology images.\n\n\nBelow are the example outputs of plotting query cells’ neighborhood:\n\nPlotting morphology images and cell borers of query cells’s neighborhood\n\n\n\nPlotting numeric and categorical metadata of query cells’ neighborhood"
  },
  {
    "objectID": "posts/napari-cosmx-intro/index.html",
    "href": "posts/napari-cosmx-intro/index.html",
    "title": "Getting Started with the napari-cosmx plugin",
    "section": "",
    "text": "Figure 1: Nine Fields of View (FOVs) of a whole-transcriptome Pancreas dataset visualized with the napari-cosmx plugin. DAPI and PanCK are shown in blue and green, respectively. Endocrine cells in the Islets of Langerhans can be identified by their transcript abundance of marker genes (points). Red = GCG (alpha cells), orange = INS (beta cells), cyan = SST (delta cells)."
  },
  {
    "objectID": "posts/napari-cosmx-intro/index.html#what-is-napari",
    "href": "posts/napari-cosmx-intro/index.html#what-is-napari",
    "title": "Getting Started with the napari-cosmx plugin",
    "section": "1.1 What is Napari?",
    "text": "1.1 What is Napari?\nStepping back for a second. What exacty is Napari? Napari is an open-source Python project that runs a Qt-based desktop GUI for interactive visualization of scientific images. The application has layers of different types, similar to what you might find in application like Photoshop or Procreate."
  },
  {
    "objectID": "posts/napari-cosmx-intro/index.html#what-is-the-napari-cosmx-plugin",
    "href": "posts/napari-cosmx-intro/index.html#what-is-the-napari-cosmx-plugin",
    "title": "Getting Started with the napari-cosmx plugin",
    "section": "1.2 What is the napari-cosmx plugin?",
    "text": "1.2 What is the napari-cosmx plugin?\nThe napari-cosmx plugin enables viewing of data generated by the CosMx SMI platform in Napari. Tissue morphology layers generated by CosMx SMI are stored as zarr files and displayed as image layers and standard controls such as opacity, gamma, and contrast limits can be use to interact with the tissue. Protein results are also viewed as an image layer in Napari. For CosMx RNA experiments, the detected transcripts are viewed as a points layer in Napari. Cell segmentation results are displayed as an image layer of the cell boundaries. The cell shapes can also be colored by metadata such as cell type. Figure 2 shows some examples of these in an animated format.\n\n\n\n\n\n\n\n\nFigure 2: Example animation made with napari-cosmx showing ligand-receptor interactions in a healthy prostate sample. Cell types fill in the cell boundaries. When cells are transparent, one can see more easily see the spatial location of S100A8 and S100A9 ligand RNA transcripts with the TLR4 receptor transcript. While animations are certainly not needed for all purposes, this one highlights that the plugin can color RNA transcripts (points layer), cell-level metadata like cell types (labels layer), and cell boundaries (image layer). It can also visualize IF image layers (not shown here; see Figure 1 for example of IF staining).\n\n\n\n\n\nBeyond the basic interactivity and viewing of napari, other posts in this series will provide examples of tips and tricks as well as more advanced analysis. See the series topics for what’s coming ahead!"
  },
  {
    "objectID": "posts/napari-cosmx-intro/index.html#sec-installing",
    "href": "posts/napari-cosmx-intro/index.html#sec-installing",
    "title": "Getting Started with the napari-cosmx plugin",
    "section": "2.1 Installing napari-cosmx",
    "text": "2.1 Installing napari-cosmx\nThe specific download instructions depend on your operating system (see tabs below) but the general procedure is the same: 1) installing Napari 0.4.17 and 2) installing the napari-cosmx plugin.\n\n\n\n\n\n\nNote\n\n\n\nThe napari-cosmx plugin was developed with Napari 0.4.17. There are some breaking changes that we have noticed if using the plugin with newer version of Napari (e.g., 0.4.18). At the time of writing this post, please make sure to install version 0.4.17.\n\n\n\nWindows InstallMacOS/Unix Install\n\n\n\n\n\n\n\n\nNote\n\n\n\nDepending on your browser and security settings you may get warnings when downloading or running some of the links below.\n\n\n\n2.1.0.1 Part 1: Installing Napari\n\n\nThe Napari project contains platform-specific bundled apps for each release that don’t require you to first install a Python environment. You simply run the installer and a link will be added to your Start Menu as with a typical app installation. The napari-CosMx plugin currently expects Napari 0.4.17.\nClick to download the Windows Installer\n\n\n\n\n\n\n\n\n\n\n\nFigure 3: The Windows Installer.\n\n\n\n\n\n\n2.1.0.2 Part 2: Installing napari-cosmx\n\nDownload the whl file and license in asests/napari-cosmx releases.\nGo to the folder where the whl file is in your File Explorer and choose Copy as Path.\nNow launch Napari from the Start menu in Windows.\n\n\nPro tip: If launching for the first time, the application may take a moment to appear. Avoid launching multiple instances.\n\n\nIn napari, open up the &gt;_ button that is located on the bottom left (see Figure 4 for example).\nType pip install into the console (i.e., with a single space after the word ‘install’).\nPaste the location of the whl file\nPress enter to execute\nYou should receive a message in the console that several packages were successfully installed including the napari-cosmx package.\nClose and re-start napari\n\n\n\n\n\n\n\n\n\nFigure 4: Example showing how to install the napari-cosmx file. Your file name and path will look different. Yellow circle shows the location of the &gt;_ ipython prompt.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nDepending on your browser and security settings you may get warnings when downloading or running some of the links below.\n\n\n\n2.1.0.3 Part 1: Installing Napari\nVisit the Napari 0.4.17 release page. Scroll all the way to the bottom and expand the section that says “Assets” (Figure 5). Download the pkg file that is appropriate for your operating system (i.e., napari-0.4.17-macOS-x86_64.pkg for Mac). Open the downloaded file and install via the instructions on screen (you can accept the defaults). When finished, launch Napari via the Applications folder.\n\nPro tip: If launching for the first time, the application may take a moment to appear. Avoid launching multiple instances.\n\n\n\n\n\n\n\n\n\nFigure 5: Screenshot of Napari packages. Blue highlighted package is appropriate for Mac. Other operating systems’ packages are also available but untested.\n\n\n\n\n\n\n\n2.1.0.4 Part 2: Installing napari-cosmx\n\nDownload the whl file and license in asests/napari-cosmx releases.\nIn Napari, open up the &gt;_ button that is located on the bottom left (see Figure 6 for example).\nType pip install into the console (i.e., with a single space after the word ‘install’).\nPaste the location of the whl file\nPress enter to execute\nYou should receive a message in the console that several packages were successfully installed including the napari-cosmx package.\nClose and re-start napari\n\n\n\n\n\n\n\n\n\nFigure 6: Example showing how to install the napari-cosmx file. Your file name and path will look different. Yellow circle shows the location of the &gt;_ ipython prompt."
  },
  {
    "objectID": "posts/napari-cosmx-intro/index.html#sec-napari-ready-files",
    "href": "posts/napari-cosmx-intro/index.html#sec-napari-ready-files",
    "title": "Getting Started with the napari-cosmx plugin",
    "section": "2.2 Napari-ready slide folder",
    "text": "2.2 Napari-ready slide folder\nThe napari-cosmx plugin expects a slide that has been prepared using the stitching (Section 2.4) method within the plugin itself. If you do not already have a napari-ready slide, you can download a simple, single-FOV example that we have created here). This single-FOV dataset was derived from the mouse brain public dataset. The full data download is not needed for our current purposes but those interested in exploring the full data can download it here.\nAt the very minimum, the napari-ready slide folder contains two top-level elements:\n\nimages folder. Within the images folder, there are subfolders for each immunofluorescence channel and one folder for the cell boundaries (labels).\ntargets.hdf5 file that contains the RNA (or protein) targets.\n\nAn example can be see below (Figure 7).\n\n\n\n\n\n\n\n\nFigure 7: Example layout of a napari-ready folder. In this example, the ‘parent folder’ (i.e., the folder you would drag and drop into Napari) is named single_fov_napari_example and contains the images folder with subfolders containing various zarr files within and the targets.hdf5 file.\n\n\n\n\n\nIf you would like to see the details of the zarr file structure for the images folder in our single-FOV example, expand the code chunk blow.\n\n\nCode\n$ tree -f\n.\n├── ./images\n│   ├── ./images/DNA\n│   │   ├── ./images/DNA/0\n│   │   │   └── ./images/DNA/0/0\n│   │   │       └── ./images/DNA/0/0/0\n│   │   ├── ./images/DNA/1\n│   │   │   └── ./images/DNA/1/0\n│   │   │       └── ./images/DNA/1/0/0\n│   │   ├── ./images/DNA/2\n│   │   │   └── ./images/DNA/2/0\n│   │   │       └── ./images/DNA/2/0/0\n│   │   └── ./images/DNA/3\n│   │       └── ./images/DNA/3/0\n│   │           └── ./images/DNA/3/0/0\n│   └── ./images/labels\n│       ├── ./images/labels/0\n│       │   └── ./images/labels/0/0\n│       │       └── ./images/labels/0/0/0\n│       ├── ./images/labels/1\n│       │   └── ./images/labels/1/0\n│       │       └── ./images/labels/1/0/0\n│       ├── ./images/labels/2\n│       │   └── ./images/labels/2/0\n│       │       └── ./images/labels/2/0/0\n│       └── ./images/labels/3\n│           └── ./images/labels/3/0\n│               └── ./images/labels/3/0/0\n└── ./targets.hdf5\n\n\nWe can also create a file named _metadata.csv that can be used for cell-level labeling. For more information on that, please see Section 2.5."
  },
  {
    "objectID": "posts/napari-cosmx-intro/index.html#sec-loading-slides",
    "href": "posts/napari-cosmx-intro/index.html#sec-loading-slides",
    "title": "Getting Started with the napari-cosmx plugin",
    "section": "2.3 Loading a slide into napari-cosmx",
    "text": "2.3 Loading a slide into napari-cosmx\n\n\n\n\n\n\nNote\n\n\n\nYou may have noticed that I put this section before the section on how to create (or ‘stitch’) napari-ready files. This is due to the current implementation of the napari-cosmx code base. Specifically, this is because the widget used for stitching is available once we launch the plugin. So in order to be able to stitch, we need to have some pre-existing slide to load into the plugin.\nFor individuals comfortable with scripting in unix/python, we have a method to stitch images without the need for the napari GUI. See our post on programmatic stitching for the how-to.\n\n\nTo launch and view CosMx data with the napari-cosmx plugin:\n\nNavigate to a napari-ready slide folder. If you need a minimum example, see Section 2.2 above.\nOpen Napari from the Start Menu (Windows) or the Application folder (Mac).\nDrag the parent folder of the slide into the the Napari application. If you are using the single-FOV example above, this would be the folder named single_fov_napari_example. Otherwise, the napari-ready folder is whichever folder contains images and targets.hdf5 (see Section 2.2).\nNapari will ask if you would like to open via the napari-cosmx plugin or another method. Select the napari-cosmx plugin and press okay."
  },
  {
    "objectID": "posts/napari-cosmx-intro/index.html#sec-stitching",
    "href": "posts/napari-cosmx-intro/index.html#sec-stitching",
    "title": "Getting Started with the napari-cosmx plugin",
    "section": "2.4 How to create slides from Raw data",
    "text": "2.4 How to create slides from Raw data\nAt the time of writing, the process to create Napari ready files follows this framework:\n\nExport Raw data from AtoMx SIP (v1.3+) (Section 2.4.1)\nLaunch napari-cosmx within Napari (Section 2.4.2)\nUse the stitch widget to create napari-ready slide from raw data (Section 2.4.3)\n\n\n\n\n\n\n\nNote\n\n\n\nOne of the main advantages of AtoMx SIP is that the data are stored for you. However, napari-cosmx currently requires the raw data downloaded and stored locally. Raw data can be quite large (100s of GBs per slide). It is possible to store the data on a networked drive but we have noticed that stitching performance is slower, depending on your network speed. Storing the data on a high-capacity and fast I/O external hard drive may also be an option.\n\n\n\n2.4.1 1. Export Raw Data\nIn AtoMx SIP, in the Study details panel on the upper left, click Export (Figure 8).\n\n\n\n\n\n\n\n\nFigure 8: Click Export (available in AtoMx SIP version 1.3+).\n\n\n\n\n\nConfigure your export with the options indicated in Figure 9 and click EXPORT. If you would like to view metadata (optional). You can go ahead and download the Seurat data now or as a separate step (i.e., Seurat data is not needed for stitching napari files).\n\n\n\n\n\n\n\n\nFigure 9: Example configuration for exporting. For more information on extracting cell-level metadata, see Section 2.5.\n\n\n\n\n\nWhen the export is ready, download the data. You can do this over the sftp protocol in a variety of application. Here, I’m using Cyberduck but you can use other programs.\nIn Cyberduck, click Open Connection. In the dropdown menu, select SFTP and enter the URL, username, and your (AtoMx) password. Then click Connect. Example: Figure 10.\n\n\n\n\n\n\n\n\nFigure 10: Example configuration for Cyberduck SFTP.\n\n\n\n\n\nOnce connected, find the relevant folder, right click, and select Download As... (Figure 11). Choose the location on your computer to store the data. You may be able to store it on a networked drive but this is currently untested.\n\n\n\n\n\n\n\n\nFigure 11: Download raw data somewhere on your desktop.\n\n\n\n\n\n\n\n2.4.2 2. Launch napari-cosmx\nIn order to use the stitching widget in the plugin, we must first launch the plugin. Currently, the only way to do that is to load an existing napari-ready folder. This can be any Napari slide (e.g., a previous study or the single-FOV example described in Section 2.2).\n\n\n2.4.3 3. Stitching images\nOnce napari-cosmx is launched, the stitching widget is located on the right-hand panel (Figure 12).\n\n\n\n\n\n\n\n\nFigure 12: Example showing a launched napari-cosmx plugin with a possibly-unrelated slide. To stitch, a new slide, Click Browse... in the Stitch Images widget located on the right-hand side of Napari.\n\n\n\n\n\nWe need to tell napari-cosmx where the raw data that we exported are located locally. In the right-hand panel there is a Stitch Images widget. Click Browse... and navigate to the parent folder containing the slide’s raw data.\nYour downloaded raw data folder name will be unique to your slide and you can rename it to whatever makes sense for your workflow. For this example, I renamed it raw_data (Figure 13). Click on the raw data folder and select Open. In the Stitch Images widget, you should see the path of the raw data folder printed. If an unexpected format was detected, there will be an error message (e.g., Figure 14).\n\n\n\n\n\n\n\n\nFigure 13: Browsing to the location of the raw data that you want to stitched. For more information on the structure of the raw data, see the next post in the series.\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 14: Stitching widget prints the path to the correctly formatted raw data (left) or provides an error message if not formatted correctly (right). Note that only the correctly formatted location can proceed to the next step (choosing otuput folder).\n\n\n\n\n\nNext, select the location where you want the plugin to return the napari-ready files. It is recommended not to store it in the same location as the raw data. Here, I’m pointing it to a location adjacent to the raw data that I named stitched_example (Figure 15).\n\n\n\n\n\n\n\n\nFigure 15: Select output folder.\n\n\n\n\n\nFinally, click Stitch. Note: currently there is no refreshing or printing of messages. Please do not click Stitch more than once. You may see Napari become unresponsive, see the “spinning beach ball” (Mac), etc. Depending on the number of FOVs, computer configuration, and analyte type, this can take several minutes. Once complete, you should see messages that resemble that of Figure 16. If you see the last line See output folder for results, you successfully converted the raw data into napari-ready files!\nTo view the results, simply close napari, reopen it, and drag your newly created results into the application.\n\n\n\n\n\n\n\n\nFigure 16: Messages from a successfully completed stitching run.\n\n\n\n\n\nThat’s it! To view the newly stitched slide, close Napari, re-open it, and drag the folder into Napari."
  },
  {
    "objectID": "posts/napari-cosmx-intro/index.html#sec-adding-metadata",
    "href": "posts/napari-cosmx-intro/index.html#sec-adding-metadata",
    "title": "Getting Started with the napari-cosmx plugin",
    "section": "2.5 Adding and viewing metadata",
    "text": "2.5 Adding and viewing metadata\nWhile there will be dedicated posts that discuss tips and tricks for using the napari-cosmx plugin, here I’ll discuss one of the most powerful uses: viewing cell types.\nWhile not needed for the basic stitching, the Seurat file that is downloaded from AtoMx SIP can contain important cell-level information. For example, if cell typing was performed in AtoMx, each cell will have a label with its cell type.\nIn this section, I’ll show you the basic principle for converting the meta data within the Seurat object into a csv file that can be understood by the napari-cosmx plugin. Users should have a basic understanding of R in order to use this feature. I’ll also need to switch our example dataset since the minimal single-FOV example dataset was from raw data and not analyzed in AtoMx so we don’t have any cell-level cell type information. Here, the specific column of interest will have the prefix RNA_nbclust and suffix clusters. In the code below, we’ll change that name to simply cell_types. We’ll also need a column named cell_ID in the metadata. We need to write the metadata columns to a file specifically named _metadata.csv and have that file located in the napari-ready folder.\n\n\nCode\n# This is R code\nlibrary(Seurat)\nlibrary(plyr)\nlibrary(dplyr)\n# sem_path will be wherever you downloaded your Seurat object\nsem_path &lt;- \"/path/to/your/seuratObject.RDS\"\nsem &lt;- readRDS(sem_path)\nmeta &lt;- sem@meta.data\nmeta &lt;- meta %&gt;% select(starts_with(\"RNA_nbclust\")) %&gt;% select(ends_with(\"clusters\"))\ncolnames(meta)[1] &lt;- 'cell_types'\nmeta$cell_ID &lt;- row.names(meta) # adds cell_ID column\nrownames(meta) &lt;- NULL\nmeta &lt;- meta %&gt;% relocate(cell_ID) # moves cell_ID to first column position\nwrite.table(meta, file=\"/path/to/inside/napari-ready-folder/_metadata.csv\", \n            sep=\",\", col.names=TRUE, row.names=FALSE, quote=FALSE)\n\n\nNow, when we drag and drop the napari-ready folder, the metadata that you extracted from Seurat will be available to view using the right-hand widget named Color Cells (Figure 17).\n\n\n\n\n\n\n\n\nFigure 17: When metadata are available in the _metadata.csv file, it’s possible to color cells based on a cell-level metadata value (e.g., cell types)."
  },
  {
    "objectID": "posts/background/index.html",
    "href": "posts/background/index.html",
    "title": "How does background impact CosMx data, and when does it matter?",
    "section": "",
    "text": "CosMx data includes off-target “background” counts from off-target probe binding, appearing randomly at a low frequency across the dataset. In this article, we’ll discuss how background impacts data analysis. Many details follow, but our main findings are simple:\n\nFor analyses where statistics are calculated across many cells, for example differential expression or spatial correlation analysis, the impact of background approaches zero.\nFor analyses of single cell profiles, for example cell typing or UMAP projections, background contributes a small amount of noise/error. But by far the major driver of noise in single cell profiles is sensitivity / readout sparsity, not background.\nAnalyses of single genes in single cells, for example calling cells as +/- for a marker gene, perform poorly regardless of background levels, except for perhaps the top ~10% high-expressing genes. We recommend a smoothing / imputation approach to make this kind of analysis reliable.\n\nNote: For details of the origins of background counts, see Appendix 1.\nNote: This document focuses on background. But always worth bearing in mind is that segmentation errors have a far more deleterious impact on data quality. See Appendix 2 for a brief discussion."
  },
  {
    "objectID": "posts/background/index.html#introduction",
    "href": "posts/background/index.html#introduction",
    "title": "How does background impact CosMx data, and when does it matter?",
    "section": "",
    "text": "CosMx data includes off-target “background” counts from off-target probe binding, appearing randomly at a low frequency across the dataset. In this article, we’ll discuss how background impacts data analysis. Many details follow, but our main findings are simple:\n\nFor analyses where statistics are calculated across many cells, for example differential expression or spatial correlation analysis, the impact of background approaches zero.\nFor analyses of single cell profiles, for example cell typing or UMAP projections, background contributes a small amount of noise/error. But by far the major driver of noise in single cell profiles is sensitivity / readout sparsity, not background.\nAnalyses of single genes in single cells, for example calling cells as +/- for a marker gene, perform poorly regardless of background levels, except for perhaps the top ~10% high-expressing genes. We recommend a smoothing / imputation approach to make this kind of analysis reliable.\n\nNote: For details of the origins of background counts, see Appendix 1.\nNote: This document focuses on background. But always worth bearing in mind is that segmentation errors have a far more deleterious impact on data quality. See Appendix 2 for a brief discussion."
  },
  {
    "objectID": "posts/background/index.html#how-much-background-is-there",
    "href": "posts/background/index.html#how-much-background-is-there",
    "title": "How does background impact CosMx data, and when does it matter?",
    "section": "How much background is there?",
    "text": "How much background is there?\nIn most 6000-plex datasets, background is somewhere between 0.01 and 0.05 counts per plex per cell. To get a fuller sense of the range of background, see below for results from a set of 6k datasets of varying quality.\n\n\n\n\n\n\n\n\n\nFigure 1: signal and background across 6k datasets of widely varying data quality. a. Datasets’ mean background (mean counts per negprobe per cell) plotted against mean signal (mean RNA counts per cell). b. Datasets’ proportion of background counts plotted against mean signal. Proportion of background counts is estimated with: (mean counts per negprobe per cell)(plex)/(mean RNA counts per cell).\nFrom Figure 1, we see that datasets with more signal (raw counts) tend to also have more background, but that background does not rise as quickly as signal. For a nuanced discussion of how background behaves within a dataset, see Appendix 3."
  },
  {
    "objectID": "posts/background/index.html#case-1-impact-of-background-when-calculating-summary-statistics-over-many-cells",
    "href": "posts/background/index.html#case-1-impact-of-background-when-calculating-summary-statistics-over-many-cells",
    "title": "How does background impact CosMx data, and when does it matter?",
    "section": "Case 1: Impact of background when calculating summary statistics over many cells",
    "text": "Case 1: Impact of background when calculating summary statistics over many cells\nCosMx datasets tend to be large, containing hundreds of thousands of cells in total, and at least thousands of cells from most individual cell types. This high sample size gives us high statistical power and precision whenever we calculate summary statistics over cells, for example when performing differential expression or computing spatial correlations. The law of large numbers assures us that as N increases, the noise in our data averages out, leaving us with precise estimates. Thus background, which mainly acts to add random noise to the data, does not obscure trends that occur over large numbers of cells.\nTo demonstrate what statistical theory assures us, we’ll simulate CosMx data for which we can attribute each count to real RNA or background. Our simulation is simple: using a CosMx dataset, we’ll take a gene for which only a very small percentage of counts are background, i.e. one of our highest expressers. Then we’ll down-sample it until it has half as many counts as the average gene. This down-sampled data will behave like a low-expression gene with near-zero background. Finally, we’ll take background counts from a negative control gene and use them as simulated background atop the down-sampled values, producing data akin to a low-expressing gene with typical background, for which 22.3% of counts are background.\nFirst, let’s get a visceral feel for what background looks like by plotting our simulated counts across space:\n\n\n\n\n\n\n\n\n\nFigure 2: spatial plots of simulated real and background counts from a typical gene in a typical 6k dataset. Top row: single cell expression in space. The right three plots are on the same color scale. Bottom row: total expression in a sliding window along the highlighted regions in the spatial plots. The right three plots are on the same vertical scale. Left: COL1A1 is a high expresser in this dataset. Center left: COL1A1 counts were down-sampled 42-fold to create a simulated gene of average expression level and negligible background. Center right: background counts (from a negative control gene). Right: Background added to the down-sampled data to simulate a gene of average expression and average background, for which 22.4% of counts are background.\nThe spatial pattern of this gene’s expression is equally clear with and without background. This example serves to demonstrate a general principle: since background occurs randomly, it does little to obscure spatial trends in gene expression. We can also demonstrate this without use of simulation. Figure 3 below shows two low expressers displaying clear spatial patterns.\n\n\n\n\n\n\n\n\n\nFigure 3: spatial plots of two low expressers.\nNow let’s see how background impacts hard statistics. Using the same simulation, we’ll perform a differential expression analysis. Mimicking (somewhat simplisticly) a typical use case, in which we study how a single cell type modules gene expression across spatial context, we’ll measure how gene expression in fibroblasts changes between the top vs. bottom halves of the tissue. To do this, we’ll run a simple t-test on normalized expression. We run this toy analysis on the downsampled / “negligible background” data, and on the data with simulated background added back in. When we analyze all 18871 fibroblasts, we find that adding background leaves our point estimate and confidence interval essentially intact:\n\n\n\n\n\n\n\n\n\n\n\nEstimate\nLower 95% conf interval\nUpper 95% conf interval\np-value\n\n\n\n\nDownsampled to simulate near-zero background\n0.000107\n7.35e-05\n0.000140\n3.4e-10\n\n\nWith simulated background\n0.000108\n7.4e-05\n0.000143\n6.91e-10\n\n\n\nTable 1: Differential expression results from 18871 fibroblasts. A linear model comparing expression in the upper vs. lower half of the tissue was run for two expression vectors. Top row: COL1A1 counts were down-sampled 85-fold to create a simulated gene of low expression level and negligible background. Bottom row: Background was added to the down-sampled data to simulate a gene of low expression and average background.\nTo simulate a rare cell type where our sample size is less overpowering, we can re-run our analysis on a random subset of merely 1000 fibroblasts. When we do so, the fundamental finding remains: adding background to the data barely budges our estimates, confidence intervals and p-values. Remember, this is a gene for which 22.3% of counts are background.\n\n\n\n\n\n\n\n\n\n\n\nEstimate\nLower 95% conf interval\nUpper 95% conf interval\np-value\n\n\n\n\nDownsampled to simulate near-zero background\n0.000165\n8.14e-06\n0.000321\n0.0392\n\n\nWith simulated background\n0.000175\n1.64e-05\n0.000334\n0.0307\n\n\n\nTable 2: Differential expression results from 1000 fibroblasts, simulating a rare cell type. For a random subset of 1000 fibroblasts, a linear model comparing expression in the upper vs. lower half of the tissue was run for two expression vectors. Top row: COL1A1 counts were down-sampled 85-fold to create a simulated gene of average expression level and negligible background. Bottom row: Background was added to the down-sampled data to simulate a gene of average expression and average background.\nCode for the above simulation can be found here."
  },
  {
    "objectID": "posts/background/index.html#case-2-impact-of-background-when-analyzing-single-cell-expression-profiles",
    "href": "posts/background/index.html#case-2-impact-of-background-when-analyzing-single-cell-expression-profiles",
    "title": "How does background impact CosMx data, and when does it matter?",
    "section": "Case 2: Impact of background when analyzing single-cell expression profiles",
    "text": "Case 2: Impact of background when analyzing single-cell expression profiles\nNow, instead of analyzing one gene over many cells, we’ll see what happens when we analyze all the genes in a single cell. For this, we’ll need a new simulation. We first define a “true” expression profile as the average expression of macrophages in a scRNA-seq study (taken from the “ioprofiles” data from the InSituType R package). Then, we use this “true” profile to simulate a single cell’s non-background counts. Specifically, we sample from a multinomial distribution, with N equal to 590 (the average per-cell non-background count level in a typical 6k dataset), and with probabilities proportional to the expression levels of the 6k panel in our “true” profile. Finally, we simulate background atop the single cell profile, using a Poisson distribution with rate = 0.017.\nThese simulation settings mimic a middle-of-the-road 6k dataset selected from the datasets in Figure 1, with an expected 698 counts per cell, of which 15.5% are background. Simulating a single cell under this setting, we obtained 676 counts, of which 12.9% were background. This represents a typical cell from a typical 6k dataset (Figure 4).\n\n\n\n\n\n\n\n\n\nFigure 4: simulated real and background counts for a typical cell in 6k data. Bars show the counts from all genes in the 6k panel. Red vs. blue portions of bars denote background vs. real counts.\nFor the definitive parts of the profile, i.e. the highly-expressed genes, background does not distort our impression. Rather, it primarily contributes single-count values across a random selection of truly 0-count genes.\nFigure 3 gives us a gestalt for what a single cell profile with background looks like. But we truly care about is how well that observed profile reflects the cell’s true expression profile. A perfect assay would of course count every one of the ~300,000 mRNA molecules in a cell. In real-world settings where we measure closer to 1,000 molecules, we can measure a single cell profile’s accuracy by comparing its N observed counts to the expected counts obtained by sampling N mRNA molecules at random from the cell. With that in mind, let’s see how background impacts the fidelity of our measured gene expression profiles to the ground truth. First, we plot our simulated expression profile, with and without background, against the expected counts:\n\n\n\n\n\n\n\n\n\nFigure 5. Simulated single-cell profile for a cell with 589 real counts, with and without an additional 87 background counts, in linear (top row) and log-scale (bottom row). (For log-scale plots, zeroes have been rounded up to 0.5.)\nThe simulated “observed” profiles with and without background have almost the same correlation to the ground truth. In other words, background contributes little to the error.\nNotice that even the profile without background is not terribly close to the truth. This divergence can’t be caused by background; rather, it’s caused by sampling error: because the counts are so sparse, they are noisy.\n(A brief digression into theory: because we’re sampling such a low percentage of the cell’s RNA molecules, each gene’s counts are effectively Poisson-distributed. The CV (sd / mean) of a Poisson distribution with mean µ is 1/sqrt(µ). In English: Poisson data with low means is noisy.)\nTo see how sparsity drives error, we can re-run our simulation for a cell with 20,000 RNA counts:\n\n\n\n\n\n\n\n\n\nFigure 6. Simulated single-cell profile for a cell with 20,000 real counts and 2971 background counts (12.9% of the total), in linear and log-scale.\nThe observed profile now correlates closely with the ground truth. We can conclude that sparsity more than background leads our observed counts to diverge from cells’ true profiles. Code for the above simulation can be found here."
  },
  {
    "objectID": "posts/background/index.html#case-3-impact-of-background-on-analyses-of-single-genes-in-single-cells.",
    "href": "posts/background/index.html#case-3-impact-of-background-on-analyses-of-single-genes-in-single-cells.",
    "title": "How does background impact CosMx data, and when does it matter?",
    "section": "Case 3: Impact of background on analyses of single genes in single cells.",
    "text": "Case 3: Impact of background on analyses of single genes in single cells.\nIn analyses of this sort, e.g. trying to declare a cell as +/- for a marker gene, background does act as a headwind. If we see only 1 count of a gene in a cell, the existence of background means we cannot be confident that the gene is truly expressed in the cell. We can calculate the impact of background in this setting directly, without simulation. (We assume that both real and background counts arise from Poisson distributions with different rates.) Figure 7 below shows how our ability to call gene presence/absence varies based on expression level, background, and the count threshold at which we call presence.\n\n\n\n\n\n\n\n\n\nFigure 7. performance metrics for calling cells as +/- for a gene. (top left): sensitivity to call a cell as positive for a gene vs. the gene’s expected expression level per cell. This relationship is shown for thresholds of 1 count (cells with &gt;=1 counts are called positive) and 2 counts. (other panels) The true positive rate for cells called positive for a gene vs. the gene’s expected expression level per cell. Curves are shown for two count thresholds and for typical background (0.02 counts/plex/cell) and 40-fold lower background (0.005 counts/plex/cell). Vertical position indicates the percent of cells that are called positive are truly positive. The three panels correspond to (b) common cell types (50% of cells are positive), (c) somewhat rare cell types (10%) and (d) rare cell types (1%). Code for this simulation is available here.\nFrom Figure 7, we get a broad picture of the performance of calling marker gene positivity. Panel (a) conveys a few important if unsurprising lessons. First, sensitivity rises with expression level; second, it drops when we require more counts to make a cell. Third, sensitivity to detect a gene is quite poor until expected counts rise to ~3 per cell. In high-plex spatial transcriptomics in 2024, genes at this level are uncommon and would be considered high expressers. Put another way: sensitivity to detect gene positivity within a single cell is generally poor, regardless of background level. In panel (b), we see that for common cell types, background causes a low but acceptable rate of false positive calls. For cell types with 10% prevalence (panel c), background results in a 20% false detection rate using a threshold of 1 count, forcing a tradeoff between loss in sensitivity or the admission of some false positive cells to our positive calls. For cell types with 1% prevalence (panel d), a threshold of 1 count produces unacceptable levels of false positives, forcing a threshold of 2 counts and therefore a lower sensitivity.\nNote: keep in mind that prevalence can be contextual: a tiny proportion of all cells may be FOXP3+, but looking within T-cells, FOXP3 positivity could reach 10%. Thus by looking for gene positivity within a sensible subset of cells we can improve our detection performance.\nThere is a powerful countermeasure to this limitation, described here. To summarize briefly, we can derive smoothed/imputed gene expression values for crucial marker genes by borrowing information from similar cells. For a given cell, we identify the 50 cells most closely resembling its expression profile, and we replace the cell’s observed expression profile with the average expression profile of those 50 most similar cells. This negotiates a favorable variance/bias tradeoff: we bias the cell to look like its neighbors in expression space, but we squash noise due to sparsity and background. (In particular, a cell may contain a background count of a marker gene, but it’s vanishingly unlikely that very many of its expression space neighbors will have background in that same gene.) This approach works for any gene that correlates with other aspects of a cell’s expression state. For example, Treg cells aren’t just CD4 T cells with some FOXP3; FOXP3+ and FOXP3- T-cells have more extensive expression differences that allow this smoothing approach to attribute FOXP3 expression to Tregs and not to other CD4 T cells.\nIn summary, regardless of background level, analyses of single genes in single cells (e.g. of marker genes) have low sensitivity except for high expressing genes. Background increases the false positive rate of marker gene detection, mainly in rare cell types. To overcome inaccuracy resulting from both low expression and background, use imputed marker gene expression."
  },
  {
    "objectID": "posts/background/index.html#appendix1",
    "href": "posts/background/index.html#appendix1",
    "title": "How does background impact CosMx data, and when does it matter?",
    "section": "Appendix 1: Origins of background in spatial transcriptomics",
    "text": "Appendix 1: Origins of background in spatial transcriptomics\nBackground counts are simply instances where the instrument calls an RNA transcript that isn’t there. In CosMx data, background happens through two mechanisms.\nFirst, in “FalseCode” style background, reporter probes can colocalize with each other in space by random chance and then be misconstrued as a gene’s barcode. This kind of background is very rare, on the order of 0.005 counts per plex per cell. It can arise from false spot detection, from off-target binding of reporter probes, or from reporter codes from two closely adjacent transcripts combining to form the barcode of a third gene. This kind of background can be measured with our FalseCode negative controls, which are barcodes with no corresponding probes in hybridization reaction.\nSecond, in “NegProbe” style background, a hybridization probe binds to the wrong target, then is correctly detected through reporter probes. This is the dominant form of background, occurring at 0.01-0.04 counts per plex per cell in most datasets. Our “NegProbe” controls, which are standard hybridization probes targeting sequences not found in any known genome, measure both this kind of background and FalseCode style background. Because they capture both sources of background, our analyses only need consider NegProbes levels."
  },
  {
    "objectID": "posts/background/index.html#appendix2",
    "href": "posts/background/index.html#appendix2",
    "title": "How does background impact CosMx data, and when does it matter?",
    "section": "Appendix 2: contrasting the harm of background vs. of segmentation errors",
    "text": "Appendix 2: contrasting the harm of background vs. of segmentation errors\nBackground arises at random, and so impacts the data as noise. Segmentation errors, on the other hand, are not random: cells in different spatial contexts will be contaminated by different genes. This causes bias in the data. And while noise averages out at high sample sizes, bias does not. Thus segmentation errors are a far more pernicious influence on data quality than background and sparsity. For further discussion, see here."
  },
  {
    "objectID": "posts/background/index.html#appendix3",
    "href": "posts/background/index.html#appendix3",
    "title": "How does background impact CosMx data, and when does it matter?",
    "section": "Appendix 3: How is background distributed?",
    "text": "Appendix 3: How is background distributed?\nAs a first-order approximation, negprobe-style background happens with equal probability to all genes. (Beyond the first-order view, we have observed small subsets of negprobes with elevated background, usually not dramatically above the other negprobes.) We usually see cells’ background rising in proportion to their total expression: a tumor cell with twice the counts of another tumor cell is probably experiencing twice the background. Areas of necrosis will generate higher background, likely due to a more charged and thus more sticky surface for nucleic acid probes. Negprobes also seem to appear more densely outside of cells."
  },
  {
    "objectID": "posts/background/index.html#appendix4",
    "href": "posts/background/index.html#appendix4",
    "title": "How does background impact CosMx data, and when does it matter?",
    "section": "Appendix 4: Measuring cells’ background",
    "text": "Appendix 4: Measuring cells’ background\nBecause background is so low, averaging around 0.01-0.04 counts per cell in the 6000plex panel across all the 20 NegProbes, a single cell’s negprobe signal is too unstable to give a precise estimate of its background rate. (Most cells have 0 NegProbe counts, while their true background rate is surely greater than zero.) When we need to estimate single cells’ background levels, we estimate this from their total counts: we calculate the mean background counts per total counts across the dataset, then apply this ratio to each individual cell’s total counts."
  },
  {
    "objectID": "posts/cosmx-cell-profiles/index.html#introduction",
    "href": "posts/cosmx-cell-profiles/index.html#introduction",
    "title": "Cell typing with CosMx® SMI Cell Profiles",
    "section": "Introduction",
    "text": "Introduction\nCell typing CosMx Spatial Molecular Imager (SMI) data can be done in several ways. One of these is to employ a reference matrix of known cell type profiles using our Insitutype package (manuscript, GitHub repository, and GitHub FAQ). While spatially-naive scRNAseq-derived profiles work well (e.g., Cell Profile Library), platform differences can extend the iterative process of celltyping (Danaher et al. 2022). To that end, we present CosMx SMI-derived cell profiles, available on the GitHub repository CosMx-Cell-Profiles."
  },
  {
    "objectID": "posts/cosmx-cell-profiles/index.html#overview",
    "href": "posts/cosmx-cell-profiles/index.html#overview",
    "title": "Cell typing with CosMx® SMI Cell Profiles",
    "section": "Overview",
    "text": "Overview\nThe CosMx-Cell-Profiles repository contains a library of cell profile matrices with accompanying statistics and metadata. For each featured tissue, the profiles matrix gives the average expression of a variety of relevant cell types. Each matrix in the library was derived from one or more CosMx SMI experiments of a mix of panels. There are profiles from healthy and cancerous adult human samples as well as mouse brain.\nEach profile contains the following components:\n\nCell profiles matrix\nCell type annotations\nBasic statistics\nTarget statistics\nMetadata"
  },
  {
    "objectID": "posts/cosmx-cell-profiles/index.html#file-types",
    "href": "posts/cosmx-cell-profiles/index.html#file-types",
    "title": "Cell typing with CosMx® SMI Cell Profiles",
    "section": "File Types",
    "text": "File Types\n\nCell Profiles Matrix\nEach cell profiles matrix is a CSV file of targets by cell types. Each cell type’s profile is a unique column. Each target is a unique row. Where multiple experiments were combined, only the intersection of targets was used. The profiles were generated using InSituType::Estep(), which removes background readout (negative probes) when calculating the net expression profile for each cell type. For details, refer to the InSituType manual.\n\n\n\n\n\nSnippet of a cell profiles matrix.\n\n\n\n\n\n\nCell Type Annotations\nTo put cell types in context, we offer both cell type hierarchies and ontology terms.\nR file defining a nested list object so users can group cell type categories. Human-readable ensures non-R users (e.g., Python) can parse and use.\n\n\n\n\n\n\nNote\n\n\n\nNote that some inner nodes on the hierarchies are both lower-granularity categorizations as well as a final cell type included in the profiles themselves.\n\n\n\n\n\n\n\nSnippet of a cell type hierarchy.\n\n\n\n\nCell Ontology annotations are also provided for all nodes on the hierarchies. Where applicable, the identified match and/or parent (more general) matches are provided. For other cell types, where no node or parent node matches are found, we instead provide the closest term. Finally, the column in_profiles indicates whether the table row corresponds to a cell type present in the profiles (independent of whether it is an internal or terminal node within the hierarchies).\n\n\nBasic Statistics\nCSV files of basic statistics on the profiles: number of input cells of each type per profile, standard deviation for each target, etc.\n\n\n\n\n\nSnippet of basic statistics for a set of profiles.\n\n\n\n\n\n\n\n\n\nSnippet of input cell counts of each cell type for a set of profiles.\n\n\n\n\n\n\nTarget Statistics\nCSV files of average and standard deviation of targets in profiles so that users may remove targets as desired. Unlike the cell profiles, the average values by cell type and target here are simple means that do not use the negative probe values.\n\n\n\n\n\nSnippet of input cell standard deviations matrix of each cell type for a set of profiles.\n\n\n\n\n\n\nMetadata\nJSON file on experimental design and attribution, including collaborators (if applicable), species, tissue type/substructure, CosMx SMI instrument version, input panel, etc.\n\n\n\n\n\n\nImportant note\n\n\n\nIf you use the cell profiles in your work, please include citations applicable for the relevant tissue(s).\n\n\n\n\n\n\n\nSnippet of input metadata for a set of cell profiles."
  },
  {
    "objectID": "posts/cosmx-cell-profiles/index.html#usage",
    "href": "posts/cosmx-cell-profiles/index.html#usage",
    "title": "Cell typing with CosMx® SMI Cell Profiles",
    "section": "Usage",
    "text": "Usage\n\n\n\n\n\n\nImportant note\n\n\n\nIf you use the cell profiles in your work, please include citations applicable for the relevant tissue(s). See the Metadata file for more information.\n\n\nThese matrices can be downloaded directly and loaded into environments for analysis with Insitutype.\nCaution:\n\nWe do not recommend combining CosMx SMI-derived cell type profiles with scRNA-seq derived profiles in cell typing. For example, we advise against combining the CosMx SMI IO profiles with scRNA-seq profiles for the tissue type.\nNote that some inner nodes on the hierarchies are both lower-granularity categorizations as well as a final cell type included in the profiles themselves.\nIf you choose to combine multiple CosMX SMI-derived profiles into a single hybrid reference, please see our Scratch Space post here for guidance."
  },
  {
    "objectID": "posts/cosmx-cell-profiles/index.html#methodology",
    "href": "posts/cosmx-cell-profiles/index.html#methodology",
    "title": "Cell typing with CosMx® SMI Cell Profiles",
    "section": "Methodology",
    "text": "Methodology\nAll profiles were derived from CosMx SMI experiments. Projects with high-confidence cell typing were identified and permission obtained from collaborators/customers where necessary. Cell type names were corrected for consistent style. Where necessary, poor-confidence typed cells as well as genes with high discordance between CosMx SMI-derived and scRNA-seq derived profiles were removed. In profiles built from multiple experiments, only the intersection of targets was used. InSituType::Estep() was run to generate mean expression profiles from the raw counts of cells x targets, negative probe counts, and given cell types.\nPlease note the profiles, while derived from CosMx SMI experiments, may not contain the exact suite of targets of current CosMx SMI panel products."
  },
  {
    "objectID": "posts/cosmx-cell-profiles/index.html#contribution",
    "href": "posts/cosmx-cell-profiles/index.html#contribution",
    "title": "Cell typing with CosMx® SMI Cell Profiles",
    "section": "Contribution",
    "text": "Contribution\nIf you would like to contribute to the CosMx Cell Profiles repository with data from your experiments, please contact us at support.spatial@bruker.com. Broadly speaking, the process involves a license agreement, finalized cell typing, and generation of the standardized file types of the repository as outlined above."
  },
  {
    "objectID": "posts/spatial-algorithm-zoo/index.html",
    "href": "posts/spatial-algorithm-zoo/index.html",
    "title": "The spatial algorithms zoo: recommended algorithms and efficient code",
    "section": "",
    "text": "Spatial statistics is a well-developed field, with deep statistical methodology and highly efficient open-source tools. In CosMx data, where a single study can contain millions of cells, computational efficiency is vital. Here we recommend some toolkits we’ve found useful:\n\n\n\nFast nearest-neighbors search\nMeasuring a gene’s spatial autocorrelation\nMeasuring spatial correlation between two genes\nCounting occurrences within cell neighborhoods\n\n\n\n\n\n\n\nneighbors &lt;- FNN::get.knnx(data = xy, # 2-column matrix of xy locations\n                           query = xy, \n                           k = 50)\n# returns 2 outputs: a matrix of each cell's nearest neighbor indices (including itself),\n#  and a matrix of distances to these neighbors.\n\n(This also works for neighbors in expression space - just input the top 20 PCs instead of xy locations.)\n\n\n\nSee the function nearestNeighborGraph in the Insitucor package\n\n# xy is a 2-column matrix of xy locations\nneighbors &lt;- InSituCor:::nearestNeighborGraph(x = xy[, 1], y = xy[, 2], n=50)\n\nNote this matrix is populated by distances, not by simple 1/0 values.\n\n\n\nSee the function radiusBasedGraph in the Insitucor package\n\n# xy is a 2-column matrix of xy locations\nneighbors &lt;- InSituCor:::radiusBasedGraph(x = xy[, 1], y = xy[, 2], R = 0.1)\n\nNote this matrix is populated by distances, not by simple 1/0 values.\n\n\n\n\nOur goal here is to measure how much a gene’s expression depends on spatial location. Genes with strong spatial dependence are presumably more interesting, deserving human attention. A much-less-than-comprehensive list of methods is below.\nMethods:\n\nMoran’s I statistic: This is a time-honored method in spatial statistics, published in 1950. Using the analytical rather than the permutation p-value speeds it up greatly, and we find their performance to be similar.\nSpatialDE: the first attempt to measure spatial autocorrelation in spatial transcriptomics. Can be slow.\nMaxspin: A more recent method using machine learning and information theory to get performance improvements. Can be slow.\nSPARK-X: Runs at speed similar to Moran’s I.\n\n\n\n\nWhen two or more genes are spatially correlated it can be of high biological interest. These genes might regulate each other via cell-cell communication, or they could be jointly regulated by some latent variable in the microenvironment.\nMethods for measuring spatial correlation between genes include:\n\nLee’s L: another spatial statistics classic.\nSpatialDE\n\nHowever, we have found methods like the above to be unsatisfying, since genes with cell-type-specific expression end up sharing strong spatial correlations. E.g. CD19 and MS4A1 are expressed mainly by B-cells, so if B-cells are spatially clustered, then these genes will be spatially correlated, but for biologically trivial reasons. To isolate more interesting spatial correlations, we developed: - InSituCor. This is our recommended approach. It can analyze hundreds of thousands of cells and thousands of genes in minutes.\n\n\n\nAnalysts will often want to score cells for how often something occurs in their neighborhoods. For example, you might want to know how many T-cell neighbors each cell has, or how many transcripts of a gene surround it.\nThe below code demonstrates how to use the spatstat::marktable function to do this.\n\n# \"xy\"\" is a 2-column matrix of cell locations\n# \"clust\"\" is a vector of cell type assignments\n# create a point process object:\npp &lt;- spatstat.geom::ppp(xy[, 1], xy[, 2], xrange = range(xy[, 1]), yrange = range(xy[, 2]))\nmarks(pp) &lt;- clust\nmarks(pp) &lt;- as.factor(marks(pp))\n# count neighbors of each db cluster:\nmt05 &lt;- spatstat::marktable(X = pp, R = 0.05, N = NULL, exclude=TRUE, collapse=FALSE)\nrownames(mt05) &lt;- names(which(use))"
  },
  {
    "objectID": "posts/spatial-algorithm-zoo/index.html#table-of-contents",
    "href": "posts/spatial-algorithm-zoo/index.html#table-of-contents",
    "title": "The spatial algorithms zoo: recommended algorithms and efficient code",
    "section": "",
    "text": "Fast nearest-neighbors search\nMeasuring a gene’s spatial autocorrelation\nMeasuring spatial correlation between two genes\nCounting occurrences within cell neighborhoods"
  },
  {
    "objectID": "posts/spatial-algorithm-zoo/index.html#fast-nearest-neighbors-search",
    "href": "posts/spatial-algorithm-zoo/index.html#fast-nearest-neighbors-search",
    "title": "The spatial algorithms zoo: recommended algorithms and efficient code",
    "section": "",
    "text": "neighbors &lt;- FNN::get.knnx(data = xy, # 2-column matrix of xy locations\n                           query = xy, \n                           k = 50)\n# returns 2 outputs: a matrix of each cell's nearest neighbor indices (including itself),\n#  and a matrix of distances to these neighbors.\n\n(This also works for neighbors in expression space - just input the top 20 PCs instead of xy locations.)\n\n\n\nSee the function nearestNeighborGraph in the Insitucor package\n\n# xy is a 2-column matrix of xy locations\nneighbors &lt;- InSituCor:::nearestNeighborGraph(x = xy[, 1], y = xy[, 2], n=50)\n\nNote this matrix is populated by distances, not by simple 1/0 values.\n\n\n\nSee the function radiusBasedGraph in the Insitucor package\n\n# xy is a 2-column matrix of xy locations\nneighbors &lt;- InSituCor:::radiusBasedGraph(x = xy[, 1], y = xy[, 2], R = 0.1)\n\nNote this matrix is populated by distances, not by simple 1/0 values."
  },
  {
    "objectID": "posts/spatial-algorithm-zoo/index.html#measuring-a-genes-spatial-autocorrelation",
    "href": "posts/spatial-algorithm-zoo/index.html#measuring-a-genes-spatial-autocorrelation",
    "title": "The spatial algorithms zoo: recommended algorithms and efficient code",
    "section": "",
    "text": "Our goal here is to measure how much a gene’s expression depends on spatial location. Genes with strong spatial dependence are presumably more interesting, deserving human attention. A much-less-than-comprehensive list of methods is below.\nMethods:\n\nMoran’s I statistic: This is a time-honored method in spatial statistics, published in 1950. Using the analytical rather than the permutation p-value speeds it up greatly, and we find their performance to be similar.\nSpatialDE: the first attempt to measure spatial autocorrelation in spatial transcriptomics. Can be slow.\nMaxspin: A more recent method using machine learning and information theory to get performance improvements. Can be slow.\nSPARK-X: Runs at speed similar to Moran’s I."
  },
  {
    "objectID": "posts/spatial-algorithm-zoo/index.html#measuring-spatial-correlation-between-two-genes",
    "href": "posts/spatial-algorithm-zoo/index.html#measuring-spatial-correlation-between-two-genes",
    "title": "The spatial algorithms zoo: recommended algorithms and efficient code",
    "section": "",
    "text": "When two or more genes are spatially correlated it can be of high biological interest. These genes might regulate each other via cell-cell communication, or they could be jointly regulated by some latent variable in the microenvironment.\nMethods for measuring spatial correlation between genes include:\n\nLee’s L: another spatial statistics classic.\nSpatialDE\n\nHowever, we have found methods like the above to be unsatisfying, since genes with cell-type-specific expression end up sharing strong spatial correlations. E.g. CD19 and MS4A1 are expressed mainly by B-cells, so if B-cells are spatially clustered, then these genes will be spatially correlated, but for biologically trivial reasons. To isolate more interesting spatial correlations, we developed: - InSituCor. This is our recommended approach. It can analyze hundreds of thousands of cells and thousands of genes in minutes."
  },
  {
    "objectID": "posts/spatial-algorithm-zoo/index.html#counting-occurrences-within-cell-neighborhoods",
    "href": "posts/spatial-algorithm-zoo/index.html#counting-occurrences-within-cell-neighborhoods",
    "title": "The spatial algorithms zoo: recommended algorithms and efficient code",
    "section": "",
    "text": "Analysts will often want to score cells for how often something occurs in their neighborhoods. For example, you might want to know how many T-cell neighbors each cell has, or how many transcripts of a gene surround it.\nThe below code demonstrates how to use the spatstat::marktable function to do this.\n\n# \"xy\"\" is a 2-column matrix of cell locations\n# \"clust\"\" is a vector of cell type assignments\n# create a point process object:\npp &lt;- spatstat.geom::ppp(xy[, 1], xy[, 2], xrange = range(xy[, 1]), yrange = range(xy[, 2]))\nmarks(pp) &lt;- clust\nmarks(pp) &lt;- as.factor(marks(pp))\n# count neighbors of each db cluster:\nmt05 &lt;- spatstat::marktable(X = pp, R = 0.05, N = NULL, exclude=TRUE, collapse=FALSE)\nrownames(mt05) &lt;- names(which(use))"
  },
  {
    "objectID": "posts/tree-cell-typing/index.html",
    "href": "posts/tree-cell-typing/index.html",
    "title": "Using a tree-based approach to cell type CosMx® datasets",
    "section": "",
    "text": "We developed the InSituType (Danaher et al. 2022) algorithm to perform cell typing on spatial transcriptomics data, based on a likelihood model that weighs the evidence from every transcript, and this has been shown to work well for many datasets. However, when working with higher-plex datasets or attempting to perform fine-grained cell typing, we have found that a nested approach can generate more satisfactory results than the original implementation in some data sets. Here we provide a small package, InSituTree, that extends InSituType and provides a specialized application for its use. For more ideas and suggestions on cell typing, please see other cell typing posts on the Scratch Space blog and the FAQs provided with the InSituType package.\nLike other items in our CosMx Analysis Scratch Space, the usual caveats and license apply.\n\nSection 2 Overview of InSituTree approach\nSection 3 Example usage of InSituTree\nSection 4 Additional recommendations\nSection 5 Conclusions"
  },
  {
    "objectID": "posts/tree-cell-typing/index.html#original-hierachy",
    "href": "posts/tree-cell-typing/index.html#original-hierachy",
    "title": "Using a tree-based approach to cell type CosMx® datasets",
    "section": "4.1 Original hierachy",
    "text": "4.1 Original hierachy\n\n\n|- Tissue \n  |- Cholangiocyte \n  |- Stellate cell \n  |- Hepatocyte \n    |- Hepatocyte A \n    |- Hepatocyte B \n    |- Hepatocyte C \n    |- Hepatocyte D \n    |- Hepatocyte E \n  |- Endothelial cells \n    |- Portal endothelial cells \n    |- Periportal LSEC \n    |- Central venous LSEC \n|- Immune \n  |- Lymphoid \n    |- B cell \n    |- NK like cells \n    |- T cell \n      |- T cell CD3 alpha beta \n      |- T cell gamma delta \n  |- Macrophage \n    |- Non-inflammatory macrophage \n    |- Inflammatory macrophage \n|- Other \n  |- Erythroid"
  },
  {
    "objectID": "posts/tree-cell-typing/index.html#refined-hierarchy",
    "href": "posts/tree-cell-typing/index.html#refined-hierarchy",
    "title": "Using a tree-based approach to cell type CosMx® datasets",
    "section": "4.2 Refined hierarchy",
    "text": "4.2 Refined hierarchy\n\n\n|- Cholangiocyte \n|- Stellate cell \n|- Hepatocyte \n  |- Hepatocyte A \n  |- Hepatocyte B \n  |- Hepatocyte C \n  |- Hepatocyte D \n  |- Hepatocyte E \n|- Endothelial cells \n  |- Portal endothelial cells \n  |- Periportal LSEC \n  |- Central venous LSEC \n|- Lymphoid \n  |- B cell \n  |- NK like cells \n  |- T cell \n    |- T cell CD3 alpha beta \n    |- T cell gamma delta \n|- Macrophage \n  |- Non-inflammatory macrophage \n  |- Inflammatory macrophage \n|- Erythroid"
  },
  {
    "objectID": "posts/high-plex-spatial/index.html",
    "href": "posts/high-plex-spatial/index.html",
    "title": "What is high-plex spatial transcriptomics for?",
    "section": "",
    "text": "What is high-plex spatial transcriptomics for?\nHigh-plex single cell spatial transcriptomics data is a little awe-inspiring: even a perfunctory analysis of a single run produces a terabyte of data, gorgeous images, and spatial relationships from the scale of centimeters to micrometers that you could spend weeks exploring.\nBut ultimately, you don’t need amazing images, you need answers to biological questions. Here I’ll lay out questions typically asked with spatial transcriptomics, and I’ll suggest a more expansive approach that reveals spatial single-cell data to be perhaps the most productive question-posing machine in molecular biology.\nData analysis begins with two fundamental pieces: a matrix of all cells’ gene expression, and their spatial locations: \nAs with any single cell dataset, we begin by using the gene expression matrix to call cell types. Then, simply coloring our spatial map by cell type, we obtain an intricate picture of tissue structure.\n\nEven this simplistic analysis is valuable: most experts examining these plots come away with new insights and new questions.\nQuestions answered with cell type + location:\n\nHow is each immune cell type spread through this tumor? Where are the inflammatory vs. the suppressive macrophages trafficking?\nDo we see more memory T-cell invasion in post-treatment samples?\nWhat immune cell types tend to physically interact with each other?\n\nMost early analyses of spatial transcriptomic data stop here. They wrap questions like the above in formal statistics (“spatial clustering” / “niche analysis”, “cell proximity analysis”), and publish what is usually already a compelling story. But if we take this analysis just a little farther, we can begin to ask a staggering number of questions. The power of this data isn’t its ability to get single cell expression profiles, nor its ability to describe spatial variation: it’s the ability to do both of these at the same time. By simultaneously measuring single cells’ phenotypes (gene expression) and environments (the phenotypes of surrounding cells), we can interrogate how phenotype responds to environment. What can we say about a cell’s environment? Consider the below closeup of a PDAC tumor. “T-cell 1” is in a lymphoid structure, surrounded by B-cells and endothelial cells. These cells are expressing certain levels of ligands that bind receptors on T-cells. In contrast, “T-cell 2” has invaded into the tumor bed and is mainly surrounded by tumor cells, plus a few macrophages, and these cells are signaling the T-cell with a different set of genes.\n\nIn short, we can trivially derive over 1000 variables describing each cell’s environment. And now, for every cell type, we can measure how every gene responds to every environmental variable. This amounts to roughly 20 * 1000 * 1000 = 20 million questions. Or, in a study across multiple tissues, we might ask these 20 million questions separately for each tissue. (Note that in a lower-plex technology, where a panel of ~300 genes might be devoted almost entirely to cell typing, the number of interesting questions to be asked drops precipitously.)\nIn short, a standard analysis can lead to millions of hypothesis tests. Single-cell data without spatial information, and spatial data at larger-than-single-cell resolution, can’t come close to this.\nQuestions on how phenotype responds to environment:\n\nHow do tumor cells modulate gene expression in the face of T-cell attack?\nHow do macrophages in the stroma differ from macrophages in the tumor interior?\nWhat genes do T-cells express when exposed to inflammatory cytokines?"
  },
  {
    "objectID": "posts/aligned_rna_exp_matrix/index.html",
    "href": "posts/aligned_rna_exp_matrix/index.html",
    "title": "CosMx® Multiomics: Deriving an expression matrix from aligned CosMx RNA data",
    "section": "",
    "text": "1 CosMx® SMI Aligned RNA to Expression matrix\nWhen running a multiomic CosMx® SMI experiment, RNA data must be aligned to protein data as described in the post here. This alignment generates new transcript location files for each FOV in a folder with the suffix _Shifted, as shown in panel (b) of the screenshot below (Figure 1).\n\n\n\n\n\n\n\n\nFigure 1: Output of RNA alignment to protein data\n\n\n\n\n\nFor downstream analysis, it’s common to create an expression matrix that captures gene expression for every cell on the slide. This brief post includes R code demonstrating how to extract transcripts for each cell and combine them into a single sparse matrix. After loading the three indicated libraries and the three functions, the key function is load_aligned_RNA_to_expMat. The resulting matrices, one for endogenous targets and another for Negative Probes, can be used directly or converted into a convenient format, such as a Seurat object with the function CreateSeuratObject, for further processing.\n\n\nCode\n# ---- Load required libraries ----\nlibrary(data.table)    # Fast file reading and data manipulation\nlibrary(Matrix)        # Sparse matrix operations\nlibrary(future.apply)  # Parallel processing\n\n# ---- Helper: Pad a sparse matrix to full gene/cell dimensions ----\npad_matrix &lt;- function(mat, all_genes, all_cells) {\n  out &lt;- Matrix(0, nrow = length(all_genes), ncol = length(all_cells), \n                sparse = TRUE,\n                dimnames = list(all_genes, all_cells))\n  out[match(rownames(mat), all_genes), match(colnames(mat), all_cells)] &lt;- mat\n  return(out)\n}\n\n# ---- Helper: Load one target file into sparse matrices ----\nload_to_exp_mat &lt;- function(target_file, slide_number) {\n  calls &lt;- fread(target_file, \n                 select = c(\"CellId\", \"fov\", \"codeclass\", \"target\"))\n  if (nrow(calls) == 0) return(list(Endogenous = NULL, Negative = NULL))\n  \n  # Get gene sets BEFORE filtering CellId == 0\n  all_endogenous &lt;- unique(calls[codeclass == \"Endogenous\", target])\n  all_negative &lt;- unique(\n    calls[grepl(\"Neg\", codeclass, ignore.case = TRUE), target])\n  \n  # Remove extracellular transcripts\n  calls &lt;- calls[CellId != 0]\n  \n  # Add slide-wide cell ID\n  calls[, cell_ID := paste0(\"c_\", slide_number, \"_\", fov, \"_\", CellId)]\n  all_cells &lt;- unique(calls$cell_ID)\n  \n  # Function to build sparse matrix for a given type\n  make_sparse &lt;- function(type, genes) {\n    subset &lt;- calls[codeclass == type]\n    if (nrow(subset) == 0) {\n      return(Matrix(0, nrow = length(genes), ncol = length(all_cells), \n                    sparse = TRUE,\n                    dimnames = list(genes, all_cells)))\n    }\n    counts &lt;- subset[, .N, by = .(target, cell_ID)]\n    sparseMatrix(i = match(counts$target, genes),\n                 j = match(counts$cell_ID, all_cells),\n                 x = counts$N,\n                 dims = c(length(genes), length(all_cells)),\n                 dimnames = list(genes, all_cells))\n  }\n  \n  list(Endogenous = make_sparse(\"Endogenous\", all_endogenous),\n       Negative = make_sparse(\"Negative\", all_negative))\n}\n\n# ---- Main Function ----\n#' Load aligned RNA data into sparse expression matrices\n#'\n#' Reads multiple target call files from an aligned RNA directory \n#' and returns two sparse matrices: \n#' one for endogenous targets (genes) and one for negative controls.\n#'\n#' @param aligned_RNA_dir Path to aligned RNA data \n#' (folder ending with \"_Shifted\")\n#' @param slide_number Slide number used in cell IDs\n#' @return A named list with two sparse matrices: \"Endogenous\" and \"Negative\"\n#' @examples\n#' exp_matrices &lt;- load_aligned_RNA_to_expMat(\n#'                      \"AnalysisResults/7hzxsoa7rs_Shifted\", 2)\n#' \n#' library(Seurat)\n#' sem &lt;- CreateSeuratObject(exp_matrices[[\"Endogenous\"]])\n#' \n \n\nload_aligned_RNA_to_expMat &lt;- function(aligned_RNA_dir, slide_number) {\n  # Validate input\n  if (!dir.exists(aligned_RNA_dir)) stop(\"Directory does not exist\")\n  \n  # Get target call files\n  target_call_files &lt;- list.files(aligned_RNA_dir, \n                                  pattern = \"_complete_code_cell_target_call_coord.csv\",\n                                  recursive = TRUE, full.names = TRUE)\n  if(length(target_call_files) == 0) stop(\"No target call files found\")\n  \n  # Parallel load of all FOVs\n  plan(multisession)  # Set parallel backend\n  exp_mat_list &lt;- future_lapply(target_call_files, load_to_exp_mat, \n                                slide_number = slide_number)\n  \n  # Collect all genes and cells across FOVs\n  all_endogenous_genes &lt;- unique(\n    unlist(lapply(exp_mat_list, function(x) rownames(x[[\"Endogenous\"]]))))\n  all_negative_genes &lt;- unique(\n    unlist(lapply(exp_mat_list, function(x) rownames(x[[\"Negative\"]]))))\n  all_cells &lt;- unique(\n    unlist(lapply(exp_mat_list, function(x) colnames(x[[\"Endogenous\"]]))))\n  \n  # Combine matrices across FOVs\n  combine_mats &lt;- function(type, all_genes) {\n    mats &lt;- lapply(exp_mat_list, function(x) pad_matrix(x[[type]], \n                                                        all_genes, all_cells))\n    Reduce(`+`, mats)\n  }\n  \n  list(Endogenous = combine_mats(\"Endogenous\", all_endogenous_genes),\n       Negative = combine_mats(\"Negative\", all_negative_genes))\n}\n\n\nOnce you have this expression matrix and / or Seurat object, you are ready to continue with downstream tertiary analysis. As mentioned in the alignment post, after alignment all cell metadata and segmentation information is contained in the protein data and thus can be extracted from the protein run outputs. As one example of a downstream analysis utilizing both the RNA and protein data, see our recently released approach for multiomic cell typing."
  },
  {
    "objectID": "posts/multiomics-hieratype/index.html",
    "href": "posts/multiomics-hieratype/index.html",
    "title": "Integrated RNA + protein multiomic cell typing using HieraType",
    "section": "",
    "text": "1 Introduction\nThis post showcases how the HieraType cell typing package can be used for integrated same-slide multiomic (protein + rna) cell typing.\nAs an example, we use a breast cancer tissue sample with both 64-plex protein and WTx 18,935 plex RNA assayed. We start by comparing cell typing with three approaches:\n\nboth RNA + protein\nprotein-only\nRNA-only\n\nWe compare cell typing performance and show that, overall, protein-only and RNA-only cell typing calls show more disagreement with each other than they do with with integrated multiomic cell type calls. We also demonstrate evidence of improved coherence of cell type labels with the defining marker genes and proteins when using an integrated approach that makes use of both analytes.\nFinally, we show a simple yet effective way to integrate unsupervised clusters with supervised immune cell type labels generated with HieraType. This can enable granular detection of novel or tissue-specific cell types along with well known immune cell types.\nCode for this analysis end-to-end can be found by skipping ahead here.\n\n\n2 A quick look at the tissue\nHere’s a quick look at this breast cancer tissue, where unsupervised clustering was performed using both the pearson residual normalized RNA + protein. Code for creating these unsupervised clusters is here. Next, we’ll compare multiomic immune cell typing performance with RNA-only or protein-only cell typing.\n\n\n\n\n\n3 Evidence multiomics can improve cell typing\nWe used the Adjusted Rand Index (ARI) metric to quantify the agreement between protein-only, RNA-only, and multiomic cell type labels (code). ARI is a numerical measure of similarity between two data clusterings (Rand 1971). We found protein-only and RNA-only cell typing calls show more disagreement with each other than they do with with integrated multiomic cell type calls, with:\n\n\\(ARI(\\text{multiomic,RNA-only})= 0.679\\)\n\\(ARI(\\text{multiomic, protein-only})= 0.589\\)\n\\(ARI(\\text{protein-only, RNA-only})= 0.483\\)\n\nWe compared the agreement between celltype predictions and canonical protein markers and RNA markers, and found that the multiomic cell type labels often show stronger alignment than RNA-only or protein-only cell typing. ( Code for RNA-only, protein-only, multiomic HieraType calls.)\n\n3.0.1 T cell improvement demonstration via area under the ROC curves\nFor example, the figure below shows ROC curves for T cell predictions along with three canonical cell type markers for T cells (one protein, and two RNA). In this context, for a given level of marker expression, ‘sensitivity’ refers to the frequency a cell is labeled a T-cell (for all cells above that threshold of marker expression). ‘Specificity’ refers to the proportion of times a cell is labeled anything other than a T-cell (for all cells below that threshold).\nIf we treat our normalized marker expression as a gold standard for cell type calling, then we would want to see high sensitivity and specificity of the T cell calls depending on whether marker expression is high or low. In general, larger area under the ROC curve indicates better agreement between cell type calls and marker expression.\n\n\n\nAbove, as we might expect, we see that using RNA-only for calling T cells does not optimize agreement between CD3 protein (AUC=0.871). Unsurprisingly, agreement improves when using CD3 protein directly for celltyping (protein-only AUC=0.927). In this case, we actually observed the best AUC when both RNA and protein were used jointly (multiomics AUC=0.937).\nA perhaps unsurprising theme that emerged from these cell typing comparisons was that we often see the worst agreement for protein markers when using RNA-only for celltyping, and the worst agreement for RNA markers when using protein-only for celltyping. Meanwhile, using both RNA and protein analytes often yields the best or nearly-best agreement for both marker types. This is further shown above in the middle-and-right panels when looking at CD3D and CD2 RNA markers. Multiomic celltyping outperforms protein-only by the widest margin, and also slightly outperforms RNA-only.\nOne interesting point of note when comparing the shapes of the ROC curves above is the smoothness of the curve for the CD3 protein marker, compared to the CD2 and CD3D RNA markers (which show a sharper bump closer to the lower-left corner where sensitivity=0 and specificity=1). Due to the sparsity of RNA counts, we see a sharp spike in sensitivity close to an expression threshold at which cells have a single count of the marker gene. Because RNA-only cell typing uses only the RNA markers, the AUC is larger and more influenced around this local threshold of a single marker gene count, while protein-only and multiomic cell type labels are impacted directly by marker protein expression.\n\n\n3.0.2 Improved AUC across immune cell types\nWe saw a similar trend as that demonstrated above across immune cell types.\nHere, for the most important ‘index markers’ of each immune cell type, we show the area under the ROC curve for RNA-only, protein-only, and multiomic celltyping results (code for this analysis can be found here in the end-to-end code section). In general, there appears to be an improvement in AUC for both RNA and protein markers compared to if one of the analytes were removed.\nAverage AUC was highest for multiomic celltyping across all markers and celltypes, with\n\n\\(\\overline{AUC}(\\text{multiomic}) = 0.711\\)\n\\(\\overline{AUC}(\\text{RNA-only}) = 0.709\\)\n\\(\\overline{AUC}(\\text{protein-only}) = 0.701\\)\n\n\n\n\n\n\n\n4 Running HieraType using Protein + RNA\nBelow, we’ll step through the process of generating cell type labels with multiomic data. The code for using HieraType with protein data uses very similar syntax as a regular HieraType call, with a few exceptions worth calling out.\n\nProtein naming convention\nHieraType works from a set of pre-defined ‘markers’ which correspond to each cell type we hope to classify. For multiomic or protein-only data, protein marker names must end with the suffix “_protein” in our markerslist objects.\nFor example, here is the HieraType package multiomic markerslist for CD8 T cells (cd8t).\n\nprint(HieraType::markerslist_multiomic_tcellmajor$cd8t)\n\n\n\n$index_marker\n[1] \"CD8A\"        \"CD8B\"        \"CD8_protein\"\n\n$predictors\n [1] \"CD8_protein\"    \"CD3_protein\"    \"CCR7_protein\"   \"CD45RA_protein\" \"CD27_protein\"   \"GZMA_protein\"  \n [7] \"GZMB_protein\"   \"LAG3_protein\"   \"TCF7_protein\"   \"CD3D\"           \"CD3E\"           \"CD3G\"          \n[13] \"CD8A\"           \"CD8B\"           \"IL7R\"           \"CD27\"           \"SELL\"           \"CCR7\"          \n[19] \"TCF7\"           \"LEF1\"           \"FOXP1\"          \"BACH2\"          \"KLF2\"           \"CD28\"          \n[25] \"ICOS\"           \"STAT3\"          \"STAT5\"          \"RUNX3\"          \"BATF\"           \"EOMES\"         \n[31] \"TBX21\"          \"PRDM1\"          \"PDCD1\"          \"LAG3\"           \"TIGIT\"          \"HAVCR2\"        \n[37] \"GZMK\"           \"GZMA\"           \"GZMB\"           \"PRF1\"           \"GNLY\"           \"KLRG1\"         \n[43] \"KLRD1\"          \"IFNG\"           \"CCL5\"           \"CX3CR1\"         \"NKG7\"           \"FAS\"           \n[49] \"FASLG\"          \"IL2\"            \"CD244\"          \"CXCR3\"          \"KLRB1\"          \"TOX\"           \n[55] \"NR4A2\"          \"BCL6\"           \"CXCL13\"        \n\n$use_offclass_markers_as_negative_predictors\n[1] TRUE\n\n\n\n\nProtein data normalization and constructing a multiomic adjacency_matrix\n\n\n\n\n\n\nNote\n\n\n\nBelow, we make use of the scPearsonPCA package. This R package provides convenience functions for getting the principal component embeddings for pearson-residual normalized data directly from a raw counts matrix. When normalized protein is also available, we can get the PC decomposition from both RNA and normalized protein using the functions below. For more detail on the package, please check out the README.\n\n\nProtein data should be normalized, then combined with a sparse un-normalized RNA counts matrix before passing to HieraType. Here we’ll use pearson residuals from a gamma regression model as a normalization method, although other reasonable methods might be considered and left to the user’s disgression. We then add the “_protein” suffix to the protein names, so they’ll align with the HieraType markerlists.\n\n## normalize each protein taking pearson residuals from gamma generalized linear model.\npgamm &lt;- scPearsonPCA::pearson_normalize_gamma_glm(as.matrix(sem_protein[[\"RNA\"]]@counts)\n                                                   ,upper_q_thresh = 0.99\n                                                   ,lower_q_thresh = 0.01\n                                                   )\nrownames(pgamm) &lt;- paste0(rownames(pgamm), \"_protein\")\n\nHere we conduct a principal component decomposition from combined RNA and proteins across all cells; this can be used to give us the cells x cells similarity graph we’ll pass to HieraType.\n\n## select genes from RNA data to use for PCA analysis.\n## Take the top 2k features as well as any pre-defined celltyping markers from HieraType\nsem_rna &lt;- Seurat::FindVariableFeatures(sem_rna, nfeatures = 2000)\nmarkerg &lt;- unlist(lapply(c(\n  HieraType::markerslist_l1\n  ,HieraType::markerslist_immune\n  ,HieraType::markerslist_cd8tminor\n  ,HieraType::markerslist_cd4tminor\n  ,HieraType::markerslist_tcellmajor\n), \"[[\", \"predictors\"))\nuse_genes &lt;- unique(c(sem_rna@assays$RNA@var.features, intersect(markerg, rownames(sem_rna))))\n\n### total counts and gene frequency from RNA data computed across full dataset\ntc &lt;- Matrix::colSums(sem_rna[[\"RNA\"]]@counts)\ngenefreq &lt;- scPearsonPCA::gene_frequency(sem_rna[[\"RNA\"]]@counts)\n\n# Multiomic RNA and Protein cluster analysis\npcaobj_multi &lt;- scPearsonPCA::sparse_quasipoisson_pca_seurat_multiomic(sem_rna[[\"RNA\"]]@counts[use_genes,]\n                                                                       ,totalcounts = tc\n                                                                       ,grate = genefreq[use_genes]\n                                                                       ,xother = pgamm ## normalized protein\n                                                                       ,do.scale = TRUE\n                                                                       ,do.center = TRUE\n                                                                       ,scale.max = 10\n                                                                       ,ncores = 1\n)\n\n### Make a cell-cell adjacency matrix for HieraType \nmulti_simgrph &lt;- uwot::similarity_graph(pcaobj_multi$reduction.data@cell.embeddings\n                                  ,n_neighbors = 30\n                                  ,nn_method = \"annoy\"\n                                  ,metric = 'cosine'\n                                  )\nrownames(multi_simgrph) &lt;- colnames(multi_simgrph) &lt;- rownames(pcaobj_multi$reduction.data@cell.embeddings)\n\n\n\nHieraType call\nHere we construct our ‘multiomic’ expression matrix which includes our sparse RNA counts with the normalized protein expression, then we call HieraType::run_pipeline .\n\n#### combining sparse RNA counts and normalized proteins into a single matrix 'multimat'\noverlapping_cells &lt;- intersect(colnames(sem_protein), colnames(sem_rna))\nmultimat &lt;- Matrix::t(pgamm[,overlapping_cells])\nmultimat &lt;- cbind(multimat, Matrix::t(sem_rna[[\"RNA\"]]@counts[use_genes,overlapping_cells]))\n\n\n### Define pipeline, using multiomic markerslists\npipeline_io_multiomics &lt;- HieraType::make_pipeline(\n  markerslists = list(\n    \"l1\" = HieraType::markerslist_multiomic_l1\n    ,\"l2\" = HieraType::markerslist_multiomic_immune\n    ,\"lt\" = HieraType::markerslist_multiomic_tcellmajor\n    ,\"lt4minor\" = HieraType::markerslist_multiomic_cd4tminor\n    ,\"lt8minor\" = HieraType::markerslist_multiomic_cd8tminor\n  )\n  ,priors = list(\n    \"l2\" = \"l1\"\n    ,\"lt\" = \"l2\"\n    ,\"lt4minor\" = \"lt\"\n    ,\"lt8minor\" = \"lt\"\n  )\n  ,priors_category = list(\n    \"l2\" = \"immune\"\n    ,\"lt\" = \"tcell\"\n    ,\"lt4minor\" = \"cd4t\"\n    ,\"lt8minor\" = \"cd8t\"\n  )\n)\n\n### Run the celltyping pipeline\nmultictobj &lt;- HieraType::run_pipeline(\n   pipeline = pipeline_io_multiomics\n   ,totalcounts= tc[rownames(multimat)]\n   ,gene_wise_frequency = genefreq\n   ,counts_matrix = multimat \n   ,adjacency_matrix = multi_simgrph[rownames(multimat), rownames(multimat)]\n )\n\n\n\nOutputs\nFor extensive description of the outputs we get from HieraType, we refer the reader to the original post. Here, we’ll demonstrate how to make a few marker heatmaps from the RNA and protein data to sanity check our cell typing results.\n\nmultictobj$post_probs[[1]][1:10] ## posterior probabilities for each cell type\n\n\n\n        cell_ID celltype_thresh celltype_granular best_score_granular\n1     c_1_100_1          immune          monocyte           0.2832607\n2    c_1_100_10          plasma            plasma           0.9505284\n3   c_1_100_100      epithelial        epithelial           0.9894404\n4  c_1_100_1000              l1         cd4_naive           0.1029328\n5  c_1_100_1001              l1       endothelial           0.3917291\n6  c_1_100_1002          immune        macrophage           0.2146396\n7  c_1_100_1003          plasma            plasma           0.9697994\n8  c_1_100_1004          immune         dendritic           0.3165272\n9  c_1_100_1005              l1        fibroblast           0.2769950\n10 c_1_100_1006          plasma            plasma           0.9283903\n   best_score_thresh\n1          0.9979747\n2          0.9505284\n3          0.9894404\n4          0.4220678\n5          0.3917291\n6          0.5871081\n7          0.9697994\n8          0.9999999\n9          0.2769950\n10         0.9283903\n\n\n\n### Use the major cell type categories for a heatmap\nppmulti &lt;- copy(multictobj$post_probs$l1)\nppmulti[,celltype_multi_major:=celltype_granular]\nppmulti[grepl(\"cd4\",celltype_multi_major),celltype_multi_major:=\"cd4_tcell\"]\nppmulti[grepl(\"cd8\",celltype_multi_major),celltype_multi_major:=\"cd8_tcell\"]\nppmulti[grepl(\"mono|macro\",celltype_multi_major),celltype_multi_major:=\"macrophage_monocyte\"]\n\n### fold change metrics to show in RNA heatmap\nfctbl_rna &lt;- \nclusterwise_foldchange_metrics(sem_rna[[\"RNA\"]]@counts[use_genes,]\n                               ,totalcounts = Matrix::colSums(sem_rna[[\"RNA\"]]@counts)\n                               ,metadata = ppmulti\n                               ,cluster_column = \"celltype_multi_major\"\n                               ,cellid_column = \"cell_ID\"\n                               )\n\nhm_rna &lt;- add_ncells(marker_heatmap(fctbl_rna))\nprint(hm_rna)\n\n\n\n\nFor the protein data, almost all proteins have some positive measurement in each cell. We can use the pearson residuals to set a cutoff for computing the proportion of positive cells by marker and by cell type. Below, we’ll use cutoff of ‘pearson residual &gt; 1’ to determine the size of the bubble in the heatmap.\n\nfctbl_protein &lt;- \nclusterwise_foldchange_metrics_protein(sem_protein[[\"RNA\"]]@counts[,overlapping_cells]\n                               ,metadata = ppmulti\n                               ,cluster_column = \"celltype_multi_major\"\n                               ,propd = (pgamm[,overlapping_cells] &gt; 1))\n\nhm_protein &lt;- add_ncells(marker_heatmap(fctbl_protein))\nprint(hm_protein)\n\n\n\n\n\n\n\n5 Integrating unsupervised clusters with immune cell type labels\nHieraType was designed to find celltypes with known, pre-specified markers. Often, unsupervised clustering is sufficiently granular to identify very distinct tissue-specific clusters, but may not identify commune immune cell types of interest due to relative sparsity of the immune markers. We demonstrate an easy way (code) to reconcile the labels between HieraType and unsupervised clustering; keeping the HieraType label when a cell is classified as immune, and taking the unsupervised cluster label otherwise. This can be a useful technique regardless of whether one is using RNA, protein, or both to cell type their single cell dataset.\n\n\n\n\n\n6 Conclusion\nThe HieraType method constructs continuous celltype metagene scores, which are then probabilistically clustered to classify cell types. Because these metagene scores are continuous and the clustering uses flexible gaussian mixture models, the inputted expression can be fluidly specified in terms of RNA markers, protein markers, or some combination of both. This allows for an elegant and efficient solution for fully integrated celltyping when both protein and RNA are available.\nOverall, we’ve found improved cell typing performance when both analytes are used compared to either analyte on its own across multiple multiomic datasets, and as demonstrated for the breast cancer sample in this post.\nWhile the HieraType method is fully supervised and cannot identify novel cell types not specified in a ‘markerslist’, we demonstrate an easy approach for integrating unsupervised clusters with HieraType immune cell typing calls, enabling high resolution cell typing for both immune cell types as well as epithelial or tissue context specific cell types which may not have a known marker profile a priori. This can help reap benefits of both unsupervised and supervised approaches - well controlled pre-specified immune cell typing combined with granular unsupervised epithelial clusters.\n\n\n7 End-to-end detailed analysis code\nFor completeness, here are a few end-to-end code blocks for each analysis step.\n\nReading in the data\n\n#remotes::install_github(\"Nanostring-Biostats/CosMx-Analysis-Scratch-Space\", \n#                        subdir = \"_code/HieraType\", ref = \"Main\")\n#remotes::install_github(\"Nanostring-Biostats/CosMx-Analysis-Scratch-Space\", \n#                        subdir = \"_code/scPearsonPCA\", ref = \"Main\")\n\nlibrary(ggplot2)\nlibrary(ggrepel)\nlibrary(data.table)\nlibrary(scPearsonPCA)\nlibrary(HieraType)\nlibrary(data.table)\nlibrary(pROC)\nlibrary(mclust)\n\n## Note, using a v3-style Seurat Object below, i.e., `sem[[\"RNA\"]]@counts`\n## For v5-style, the syntax would be like `sem[[\"RNA\"]]$counts`\noptions(Seurat.object.assay.version = \"v3\")  \n\nsem_protein &lt;- readRDS(\"Breast/sem_protein.rds\")\nsem_rna &lt;- readRDS(\"Breast/sem_rna.rds\")\nsem_rna &lt;- subset(sem_rna, nCount_RNA &gt;=100)\n\n\n\nNormalizing protein data\n\n## normalize each protein taking pearson residuals from gamma generalized linear model.\npgamm &lt;- scPearsonPCA::pearson_normalize_gamma_glm(as.matrix(sem_protein[[\"RNA\"]]@counts)\n                                                   ,upper_q_thresh = 0.99\n                                                   ,lower_q_thresh = 0.01\n                                                   )\nrownames(pgamm) &lt;- paste0(rownames(pgamm), \"_protein\")\n\n\n\nMultiomic pearson residual PCA analysis using the protein and RNA\n\n## select genes from RNA data to use for PCA analysis.\n## Will take the top 2k features as well as any pre-defined immune celltyping markers from HieraType\nsem_rna &lt;- Seurat::FindVariableFeatures(sem_rna, nfeatures = 2000)\nmarkerg &lt;- unlist(lapply(c(\n  HieraType::markerslist_l1\n  ,HieraType::markerslist_immune\n  ,HieraType::markerslist_cd8tminor\n  ,HieraType::markerslist_cd4tminor\n  ,HieraType::markerslist_tcellmajor\n), \"[[\", \"predictors\"))\nuse_genes &lt;- unique(c(sem_rna@assays$RNA@var.features, intersect(markerg, rownames(sem_rna))))\n\n### total counts and gene frequency from RNA data computed across full dataset\ntc &lt;- Matrix::colSums(sem_rna[[\"RNA\"]]@counts)\ngenefreq &lt;- scPearsonPCA::gene_frequency(sem_rna[[\"RNA\"]]@counts)\n\n### add a '_protein' suffix to the protein names - helps differentiate proteins and RNA's with the same name. \nrownames(pgamm) &lt;- paste0(rownames(pgamm), \"_protein\")\n\n### Principal components derived from the combined covariance matrix of pearson residual normalized RNA and protein.\n### \npcaobj_multi &lt;- scPearsonPCA::sparse_quasipoisson_pca_seurat_multiomic(sem_rna[[\"RNA\"]]@counts[use_genes,]\n                                                                       ,totalcounts = tc\n                                                                       ,grate = genefreq[use_genes]\n                                                                       ,xother = pgamm ## normalized protein\n                                                                       ,do.scale = TRUE\n                                                                       ,do.center = TRUE\n                                                                       ,scale.max = 10\n                                                                       ,ncores = 1\n)\n\n\n\nPC_ 1 \nPositive:  CD45_protein, CD4_protein, CD39_protein, CD16_protein, Channel-CD45_protein, Fibronectin_protein, CD3_protein, Vimentin_protein, CD40_protein, CD14_protein \n       HLA-DR_protein, STING_protein, SMA_protein, ICAM1_protein, CD68_protein, CD163_protein, CD11c_protein, ICOS_protein, CD20_protein, CD8_protein \nNegative:  AZGP1, KRT7, KRT18, NAMPT, KRT8, KRT19, FASN, S100A11, DBI, SERHL2 \n       MYL6, EPCAM, ASPH, PRDX2, ALDOA, WFDC2, CYB5A, GSTP1, TMBIM6, NFIX \nPC_ 2 \nPositive:  VIM, SPARC, COL3A1, COL1A1, COL1A2, CD39_protein, IGFBP7, HLA-DRB1, CST3, TIMP2 \n       HLA-DRA, AEBP1, CD74, LUM, COL6A2, CD40_protein, CD16_protein, BGN, CYBA, COL6A1 \nNegative:  pan-RAS_protein, p53_protein, Channel-PanCK_protein, CD127_protein, EGFR_protein, NF-kB p65_protein, EpCAM_protein, CTLA4_protein, TCF7_protein, LAMP1_protein \n       Beta-catenin_protein, Ki-67_protein, CD138_protein, VISTA_protein, FOXP3_protein, Her2_protein, LAG3_protein, CD45RA_protein, DBI, SERHL2 \nPC_ 3 \nPositive:  H3C15, H3C2, H3-7, H4C14, H4C11, H3C10, H3C13, H4C12, H3C7, H2AC16 \n       H2BC4, H1-5, H2BC9, H1-2, H2AC18, H2AC11, H2BC18, H3C8, H3C11, H1-3 \nNegative:  KRT19, p53_protein, FOXP3_protein, LAG3_protein, NDRG1, TCF7_protein, Her2_protein, CTLA4_protein, IgD_protein, KRT8 \n       Channel-PanCK_protein, CD56_protein, VEGFA, LDHA, CD123_protein, AFMID, GZMB_protein, PGK1, ALDOA, iNOS_protein \nPC_ 4 \nPositive:  HLA-DRB1, HLA-DRA, CD74, HLA-DR_protein, APOE, Channel-CD68_protein, CD11c_protein, CD45_protein, LYZ, HLA-DQB1 \n       CD68_protein, CTSD, HLA-DPA1, C1QC, IFI30, CD16_protein, APOC1, HLA-DQA1, C1QB, CD4_protein \nNegative:  CD123_protein, CD34_protein, GZMB_protein, IGFBP7, CD31_protein, COL4A1, SPARC, CD56_protein, LAG3_protein, FOXP3_protein \n       COL4A2, IgD_protein, PLVAP, Her2_protein, GITR_protein, HSPG2, 4-1BB_protein, LAMA4, p53_protein, SMA_protein \nPC_ 5 \nPositive:  PLVAP, COL4A1, CD34_protein, KDR, Beta-catenin_protein, CD31_protein, EGFL7, EpCAM_protein, COL4A2, AQP1 \n       FLT1, HSPG2, SHANK3, PODXL, A2M, LAMP1_protein, CD34, ECSCR, INSR, STC1 \nNegative:  PD-L2_protein, FOXP3_protein, LAG3_protein, 4-1BB_protein, GITR_protein, CD56_protein, GZMB_protein, iNOS_protein, Her2_protein, IgD_protein \n       GZMA_protein, PD-1_protein, CD11b_protein, CD19_protein, TCF7_protein, CD163_protein, CD123_protein, CTLA4_protein, IL-18_protein, Bcl-2_protein \n\n\n\n### Make a cell-cell adjacency matrix for HieraType \nmulti_simgrph &lt;- uwot::similarity_graph(pcaobj_multi$reduction.data@cell.embeddings\n                                  ,n_neighbors = 30\n                                  ,nn_method = \"annoy\"\n                                  ,metric = 'cosine'\n                                  )\nrownames(multi_simgrph) &lt;- colnames(multi_simgrph) &lt;- rownames(pcaobj_multi$reduction.data@cell.embeddings)\n\n\n###  Unsupervised clusters using multiomic cell-cell adjacency graph\nsem_rna[[\"multigrph\"]] &lt;- Seurat::as.Graph(multi_simgrph[colnames(sem_rna),colnames(sem_rna)])\nsem_rna &lt;- Seurat::FindClusters(sem_rna, graph.name=\"multigrph\")\nsem_rna@meta.data$clusters_multi_unsup &lt;- sem_rna@meta.data$seurat_clusters\n\nxyp_multi_unsup &lt;- xyplot(\"clusters_multi_unsup\", metadata = sem_rna@meta.data, ptsize = 0.05) + coord_fixed()\n\nggsave(\"figures/xyp_multi_unsup.png\"\n       ,plot=xyp_multi_unsup\n       ,device = \"png\"\n       ,width = 1181 * sqrt(20)\n       ,height=689 * sqrt(20)\n       ,units = 'px'\n)\n\n\n\nMultiomic cell typing code using HieraType\n\n## Define the pipeline using multiomic markerlists in HieraType package\n\noverlapping_cells &lt;- intersect(colnames(sem_protein), colnames(sem_rna))\nmultimat &lt;- Matrix::t(pgamm[,overlapping_cells])\nmultimat &lt;- cbind(multimat, Matrix::t(sem_rna[[\"RNA\"]]@counts[use_genes,overlapping_cells]))\n\n\npipeline_io_multiomics &lt;- HieraType::make_pipeline(\n  markerslists = list(\n    \"l1\" = HieraType::markerslist_multiomic_l1\n    ,\"l2\" = HieraType::markerslist_multiomic_immune\n    ,\"lt\" = HieraType::markerslist_multiomic_tcellmajor\n    ,\"lt4minor\" = HieraType::markerslist_multiomic_cd4tminor\n    ,\"lt8minor\" = HieraType::markerslist_multiomic_cd8tminor\n  )\n  ,priors = list(\n    \"l2\" = \"l1\"\n    ,\"lt\" = \"l2\"\n    ,\"lt4minor\" = \"lt\"\n    ,\"lt8minor\" = \"lt\"\n  )\n  ,priors_category = list(\n    \"l2\" = \"immune\"\n    ,\"lt\" = \"tcell\"\n    ,\"lt4minor\" = \"cd4t\"\n    ,\"lt8minor\" = \"cd8t\"\n  )\n)\n\nmultictobj &lt;- HieraType::run_pipeline(\n  pipeline = pipeline_io_multiomics\n  ,totalcounts= tc[rownames(multimat)]\n  ,gene_wise_frequency = genefreq\n  ,counts_matrix = multimat\n  ,adjacency_matrix = multi_simgrph[rownames(multimat), rownames(multimat)]\n)\n\n\n\nRNA-only cell typing\n\n### RNA-only PCA and similarity graph\npcaobj_rna &lt;- scPearsonPCA::sparse_quasipoisson_pca_seurat(sem_rna[[\"RNA\"]]@counts[use_genes,]\n                                                       ,totalcounts = tc\n                                                       ,grate = genefreq[use_genes]\n                                                       ,do.scale = TRUE\n                                                       ,do.center = TRUE\n                                                       ,scale.max = 10\n                                                       ,ncores = 1\n)\n\n### Make a cell-cell adjacency matrix for HieraType \nrna_simgrph &lt;- uwot::similarity_graph(pcaobj_rna$reduction.data@cell.embeddings\n                                  ,n_neighbors = 30\n                                  ,nn_method = \"annoy\"\n                                  ,metric = 'cosine'\n                                  )\nrownames(rna_simgrph) &lt;- colnames(rna_simgrph) &lt;- rownames(pcaobj_rna$reduction.data@cell.embeddings)\n\n## RNA-only hieratype\nrnactobj &lt;- HieraType::run_pipeline(\n  pipeline = pipeline_io_multiomics ## the _protein markers are automatically excluded, \n                                    ## because they won't be found in the counts_matrix below\n  ,totalcounts= tc[rownames(multimat)]\n  ,gene_wise_frequency = genefreq[use_genes]\n  ,counts_matrix = multimat[,use_genes] ## exclude proteins, only use the 'use_genes'.  \n  ,adjacency_matrix = rna_simgrph[rownames(multimat), rownames(multimat)]\n)\n\n\n\nProtein-only cell typing\n\npgamm_prot &lt;- pgamm\nrownames(pgamm_prot) &lt;- gsub(\"_protein$\", \"\", rownames(pgamm_prot))\nsem_protein &lt;- Seurat::SetAssayData(sem_protein,layer = \"data\", new.data = pgamm_prot)\nsem_protein &lt;- Seurat::ScaleData(sem_protein)\nsem_protein &lt;- Seurat::RunPCA(sem_protein, features = rownames(sem_protein))\n### Make a cell-cell adjacency matrix for HieraType \nprotein_simgrph &lt;- uwot::similarity_graph(sem_protein@reductions$pca@cell.embeddings\n                                  ,n_neighbors = 30\n                                  ,nn_method = \"annoy\"\n                                  ,metric = 'cosine'\n                                  )\nrownames(protein_simgrph) &lt;- colnames(protein_simgrph) &lt;- rownames(sem_protein@reductions$pca@cell.embeddings)\n#### Make a copy of the cell typing pipeline to use for protein\n#### -- Remove 'mast' cells, which dont have a specific protein marker.\n#### -- remove the minor T8 and T4 subtypes\npipeline_io_protein &lt;- pipeline_io_multiomics\npipeline_io_protein$markerslists$l2$mast &lt;- NULL\npipeline_io_protein$markerslists$lt4minor &lt;- NULL\npipeline_io_protein$markerslists$lt8minor &lt;- NULL\npipeline_io_protein$priors$lt4minor &lt;- NULL\npipeline_io_protein$priors$lt8minor &lt;- NULL\npipeline_io_protein$priors_category$lt4minor &lt;- NULL\npipeline_io_protein$priors_category$lt8minor &lt;- NULL\n\nproteinctobj &lt;- HieraType::run_pipeline(\n  pipeline = pipeline_io_protein\n  ,counts_matrix = multimat[,grep(\"_protein$\",colnames(multimat),value=TRUE)]\n  ,adjacency_matrix = protein_simgrph[rownames(multimat), rownames(multimat)]\n)\n\n\n\nCombining metadata\n\n### Combining metadata\n\n## Adding on multiomic celltype annotations\nppmulti &lt;- copy(multictobj$post_probs$l1)\nppmulti[,celltype_multi_major:=celltype_granular]\nppmulti[grepl(\"cd4\",celltype_multi_major),celltype_multi_major:=\"cd4_tcell\"]\nppmulti[grepl(\"cd8\",celltype_multi_major),celltype_multi_major:=\"cd8_tcell\"]\nppmulti[grepl(\"mono|macro\",celltype_multi_major),celltype_multi_major:=\"macrophage_monocyte\"]\nppmulti[,.N,by=.(celltype_multi_major, celltype_granular)]\n\n\n## Adding on RNA-only based  celltype annotations\nppmulti &lt;- merge(ppmulti, rnactobj$post_probs$l1[,.(cell_ID, celltype_granular)]\n                 ,by=\"cell_ID\", suffixes=c(\"_multi\", \"_rna\"))\n\nppmulti[,celltype_rna_major:=celltype_granular_rna]\nppmulti[grepl(\"cd4\",celltype_rna_major),celltype_rna_major:=\"cd4_tcell\"]\nppmulti[grepl(\"cd8\",celltype_rna_major),celltype_rna_major:=\"cd8_tcell\"]\nppmulti[grepl(\"mono|macro\",celltype_rna_major),celltype_rna_major:=\"macrophage_monocyte\"]\nppmulti[,.N,by=.(celltype_rna_major, celltype_granular_rna)]\n\n## Adding protein-only based celltype annotations\nppmulti &lt;- merge(ppmulti, proteinctobj$post_probs$l1[,.(cell_ID, celltype_granular)]\n                 ,by=\"cell_ID\", suffixes=c(\"_multi\", \"_protein\"))\nsetnames(ppmulti, c(\"celltype_granular\"), c(\"celltype_granular_protein\"))\nppmulti[,celltype_protein_major:=celltype_granular_protein]\nppmulti[grepl(\"cd4\",celltype_protein_major),celltype_protein_major:=\"cd4_tcell\"]\nppmulti[grepl(\"cd8\",celltype_protein_major),celltype_protein_major:=\"cd8_tcell\"]\nppmulti[grepl(\"mono|macro\",celltype_protein_major),celltype_protein_major:=\"macrophage_monocyte\"]\nppmulti[,.N,by=.(celltype_protein_major, celltype_granular_protein)]\n\n\n\nIntegrating unsupervised clusters with immune cell type labels\n\n### Annotating non-immune clusters with unsupervised labels, creating more granular annotations\n### \nppmulti &lt;- merge(ppmulti, data.table(sem_rna@meta.data)[,.(cell_ID, x_slide_mm, y_slide_mm, clusters_multi_unsup)], by = \"cell_ID\")\nppmulti[,celltype_multi_semi:=celltype_multi_major]\nppmulti[celltype_multi_semi %in% c(\"plasma\", \"endothelial\", \"epithelial\", \"fibroblast\", \"smooth_muscle\"),celltype_multi_semi:=clusters_multi_unsup]\nppmulti[,.N,by=.(clusters_multi_unsup, celltype_multi_major)]\nclass_other &lt;- ppmulti[,.N,by=.(clusters_multi_unsup, celltype_multi_major)][,prop:=N/sum(N),by=.(clusters_multi_unsup)][order(-prop)][\n  ,head(.SD,1),by=.(clusters_multi_unsup)]\nothers &lt;- class_other[!celltype_multi_major %in% c(\"plasma\", \"endothelial\", \"epithelial\", \"fibroblast\", \"smooth_muscle\")][[\"clusters_multi_unsup\"]]\nppmulti[celltype_multi_semi %in% others, celltype_multi_semi:=\"other\"]\n\n  \n\nxyp_multi_semisup &lt;- xyplot(\"celltype_multi_semi\", metadata = ppmulti, ptsize = 0.05) + coord_fixed()\n\nggsave(\"figures/xyp_multi_semisup.png\"\n       ,plot=xyp_multi_semisup\n       ,device = \"png\"\n       ,width = 1181 * sqrt(20)\n       ,height=689 * sqrt(20)\n       ,units = 'px'\n)\n\n\n\nARI quantifying agreement between cell type labels\n\n## ARI\nmclust::adjustedRandIndex(ppmulti$celltype_multi_major, ppmulti$celltype_protein_major)\nmclust::adjustedRandIndex(ppmulti$celltype_multi_major, ppmulti$celltype_rna_major)\nmclust::adjustedRandIndex(ppmulti$celltype_protein_major, ppmulti$celltype_rna_major)\n\n\n\nMaking ROC curves, computing and plotting area under the curve\n\n### Get the most important 'index markers' for each celltype (including proteins and RNAs)\nindex_markers &lt;- unlist(lapply(HieraType::markerslist_multiomic_immune, \"[[\", \"index_marker\"))\nindex_markers &lt;- rbindlist(lapply(names(HieraType::markerslist_multiomic_immune), function(ct){\n  markerdt &lt;- data.table(celltype = ct\n                         ,marker = HieraType::markerslist_multiomic_immune[[ct]][[\"index_marker\"]]\n                         ,typ = \"rna\"\n  )\n  markerdt[grepl(\"_protein$\", marker),typ:=\"protein\"]\n  markerdt[,marker:=gsub(\"_protein$\",\"\", marker)]\n  markerdt &lt;- markerdt[(typ==\"rna\" & marker %in% rownames(sem_rna)) | (typ==\"protein\" & marker %in% rownames(sem_protein))]\n  return(markerdt)\n}))\n\n### Combine macrophage and monocyte due to similarity\nindex_markers[celltype %in% c(\"macrophage\", \"monocyte\"),celltype:=\"macrophage_monocyte\"]\naucrocl &lt;- list()\nplotdata_markerl &lt;- list()\nrownames(pgamm) &lt;- gsub(\"_protein\", \"\", rownames(pgamm))\nfor(ii in 1:nrow(index_markers)){\n  print(ii)\n  res &lt;- index_markers[ii]\n  typ &lt;- res[[\"typ\"]]\n\n\n  marker &lt;- res[[\"marker\"]]\n  celltype &lt;- res[[\"celltype\"]] \n  if(typ==\"rna\"){\n    x &lt;- sem_rna[[\"RNA\"]]@counts[marker,ppmulti[[\"cell_ID\"]]]\n    tc &lt;- Matrix::colSums(sem_rna[[\"RNA\"]]@counts[,ppmulti[[\"cell_ID\"]]])\n    muhat &lt;- genefreq[marker] * tc \n    x &lt;- (x - muhat) / sqrt(muhat) ## normalized expression for marker (pearson residuals)\n  }  else {\n    x &lt;- pgamm[marker,ppmulti[[\"cell_ID\"]]]\n  }\n  \n  pdlbl &lt;- list() \n  for(labelname in c(\"celltype_multi_major\", \"celltype_rna_major\", \"celltype_protein_major\")){\n    print(labelname)\n    labels &lt;- ppmulti[[labelname]]\n    labels[grep(\"tcell\", labels)] &lt;- \"tcell\" \n    y &lt;- as.integer(labels==celltype)\n    if(sum(y) &gt; 0){\n      roc_obj &lt;- roc(y, x, quiet = TRUE)\n      res[,(labelname):=as.numeric(auc(roc_obj))]\n    }\n    pdlbl[[labelname]] &lt;- \n      data.table(spec=roc_obj$specificities, sens=roc_obj$sensitivities,marker=marker)[,label:=labelname][unique(c(seq(1,.N,10), .N))]\n  }\n  plotdata_markerl[[ii]] &lt;- rbindlist(pdlbl)[,`:=`(celltype = celltype, marker=marker, typ = typ)]\n  aucrocl[[ii]] &lt;- data.table::copy(res) #return(res)\n}\n\n\n\n7.0.0.1 Average AUC across markers and celltypes\n\naucroc[celltype!=\"mast\",lapply(.SD, mean),.SDcols=4:6]\n\n\n\n7.0.0.2 T cell ROC curves\n\n  methcls &lt;- c(\"#9D4EA3\", \"#377EB8\", \"#E41A1C\")\n  names(methcls) &lt;- c(\"multiomic typing\", \"rna-only cell typing\",\"protein-only cell typing\")\n\n  shw &lt;- rbindlist(plotdata_markerl)[marker %in% c(\"CD3\", \"CD3D\", \"CD2\")]\n  shw[,method:=factor(label, levels=c(\"celltype_multi_major\", \"celltype_rna_major\", \"celltype_protein_major\"), labels=c(\"multiomic typing\", \"rna-only cell typing\", \"protein-only cell typing\"))]\n  merge(shw, aucrocl)\n  data.table::setnames(shw, c(\"typ\"), c(\"analyte\"))\n  shw[,marker:=factor(marker, levels=c(\"CD3\", \"CD3D\", \"CD2\"))]\n  shw &lt;- shw[order(marker)]\n  aucroc[marker %in% shw$marker]\n  rocplot_tcell &lt;- \n    ggplot(shw, aes(x = (1-spec), y = sens,group = method,color=method)) + geom_line() + \n    facet_wrap(~marker + analyte, labeller=label_both) + \n    theme_bw() + \n    scale_x_continuous(breaks = seq(0,1,.2), labels = 1-seq(0,1,.2), name = \"specificity\") + \n    scale_y_continuous(breaks = seq(0,1,.2), name = \"sensitivity\") + \n    #scale_color_manual(values = brewer.pal(8,\"Set1\")[c(1:2,3)]\n    scale_color_manual(values = methcls\n    #scale_color_manual(values = brewer.pal(8,\"Dark2\")[c(1:3)]\n                       , guide=guide_legend(override.aes=list(lwd=2)))  + \n    theme(text=element_text(size=16)) + \n    theme(legend.position=\"bottom\") +  \n    labs(title = \"ROC curve with T cell RNA and protein markers:\\nMultimomic integrated celltyping outperforms\\neither RNA or protein alone when considering cell type markers measured on both analytes\")\n  \n  lbld &lt;- \n    aucroc[marker %in% shw$marker]\n  lbld &lt;- melt(lbld, id.vars=c(\"celltype\", \"marker\", \"typ\"),value.name=\"auc\", variable.name=\"label\")\n  lbld[,method:=factor(label\n                       ,levels=c(\"celltype_multi_major\", \"celltype_rna_major\", \"celltype_protein_major\")\n                       ,labels=c(\"multiomic typing\", \"rna-only cell typing\", \"protein-only cell typing\"))]\n  lbld[,marker:=factor(marker, levels=c(\"CD3\", \"CD3D\", \"CD2\"))]\n  lbld[,analyte:=typ]\n  lbld[,lbl:=paste0(method, \" auc=\", formatC(auc, digits=3))]\n  lbld[,spec:=0.7]\n  lbld[,sens:=0.1-as.numeric(lbld$method)*0.05]\n  rocplot_tcell_lbl &lt;- rocplot_tcell + geom_text(data=lbld, aes(label = lbl),show.legend=FALSE)\n  \n  ggsave(plot=rocplot_tcell_lbl\n         ,filename = \"figures/rocplot_tcell_lbl.png\"\n         ,width=1372*sqrt(18)\n         ,height=742*sqrt(18)\n         ,dpi = 400\n         ,units = 'px'\n  )\n\n\n\n7.0.0.3 AUC barplots\n\n  methcls &lt;- c(\"#9D4EA3\", \"#377EB8\", \"#E41A1C\")\n  names(methcls) &lt;- c(\"celltype_multi_major\", \"celltype_rna_major\",\"celltype_protein_major\")\n  mroc &lt;- melt(aucroc\n               ,id.vars=c(\"celltype\", \"marker\", \"typ\")\n               ,value.name=\"auc\"\n               ,variable.name=\"method\"\n               ,variable.factor = FALSE\n  )\n  mroc[,celltype:=factor(celltype, levels=c(\"tcell\", \"bcell\", \"macrophage_monocyte\", \"dendritic\", \"neutrophil\", \"nk\", \"mast\"))]\n  mroc[,marker_label:=paste0(marker, \" (\", typ, \")\")]\n  mroc[,marker_label:=factor(marker_label,levels=mroc[order(celltype,typ, -auc),unique(marker_label)])]\n  aucbar &lt;- \n    ggplot(mroc[celltype!=\"mast\"]\n           ,aes(y = marker_label, x = auc, fill=method)) + \n    geom_bar(stat='identity',position=position_dodge()) + \n    theme_bw() + \n    scale_fill_manual(values = methcls #brewer.pal(3,\"Set1\")#unname(pals::alphabet())\n                      , guide=guide_legend(reverse=TRUE)) + \n    facet_wrap(~celltype, labeller=label_both,scales=\"free\") + \n    labs(title = \"Agreement between celltype label and marker gene/protein as measured by area under the ROC curve\"\n        ,x = \"area under the ROC curve\")\n  \n  \n  ggsave(plot=aucbar\n         ,filename = \"figures/aucbarplot.png\"\n         ,width=1430*sqrt(9)\n         ,height=874*sqrt(9)\n         ,units = 'px'\n  )\n\n  aucbar_with_text &lt;-  \n  aucbar + geom_text(aes(label = formatC(auc, digits = 3)),position=position_dodge(width=0.8))  + \n    coord_cartesian(clip = \"off\")\n  \n  ggsave(plot=aucbar_with_text \n         ,filename = \"figures/aucbarplot_wtext.png\"\n         ,width=1430*sqrt(12)\n         ,height=874*1.3*sqrt(12)\n         ,dpi = 400\n         ,units = 'px'\n  )\n\n\n\n\n\n\n\n\n\nReferences\n\nRand, William M. 1971. “Objective Criteria for the Evaluation of Clustering Methods.” Journal of the American Statistical Association 66 (336): 846–50. https://doi.org/10.1080/01621459.1971.10482356."
  },
  {
    "objectID": "posts/napari-ome-tiff/cosmx-ome-tiff.html",
    "href": "posts/napari-ome-tiff/cosmx-ome-tiff.html",
    "title": "Exporting napari-cosmx Zarr stores to OME-TIFF",
    "section": "",
    "text": "Figure 1: A regressed germinal center within a lymph node sample visualized with the napari-cosmx plugin. Membrane = Grey; DAPI = blue, cell segementation = cyan."
  },
  {
    "objectID": "posts/napari-ome-tiff/cosmx-ome-tiff.html#installing-optional-dependency",
    "href": "posts/napari-ome-tiff/cosmx-ome-tiff.html#installing-optional-dependency",
    "title": "Exporting napari-cosmx Zarr stores to OME-TIFF",
    "section": "Installing optional dependency",
    "text": "Installing optional dependency\n\nMacOS/Unix InstallWindows\n\n\nFor macOS, I have had success with using brew following libvips’ recommendation.\nFor Linux, be sure that the appropriate libraries are installed for your distribution. Check out libvips’ github wiki for more tips.\n\n\nDownload and install vips-dev-w64-all-8.16.0.zip from here\nUnzip it and move its contents to your desired location. Add the folder to a convenient location and add the location of the binaries (e.g., C:\\vips-dev-8.16.0\\bin) to your Path. Restart your computer.\nWhen using the --libvips flag within the export-tiff package script, python will look for these binaries.\n\n\n\n\nRunning with --libvips\nRerunning the previous Lymph Node example with --libvips:\n# Terminal\n# TIME=\"%e %U %S\" time export-tiff -i ./napari -o output -s -c -b 5\nexport-tiff -i ./napari -o output -s -c -b 5 --libvips\n\n16894.29 16987.47 438.18 16905396\n\nor about 4.6 hours."
  },
  {
    "objectID": "posts/nanoU/index.html",
    "href": "posts/nanoU/index.html",
    "title": "New Features of AtoMx® SIP v1.3.2",
    "section": "",
    "text": "Cross posting for our colleagues at NanoU.\nCourse links to AtoMx® SIP v.1.3.2 release notes and a video discussing and demoing new features covering:\n\nImage Viewer and Data Plotting Improvements\nData Pipeline Orchestrator Improvements\nProtein Cell Segmentation\n\ncan be found here: https://university.nanostring.com/new-features-of-atomxtm-v132."
  },
  {
    "objectID": "posts/hybrid-reference-profiles/index.html",
    "href": "posts/hybrid-reference-profiles/index.html",
    "title": "Creating reference profiles for InSituType",
    "section": "",
    "text": "The InSituType cell typing algorithm relies on a “reference matrix” to perform supervised or semi-supervised cell typing. A reference matrix gives the expected gene expression profile of each cell type in a tissue; these are usually derived from previous scRNA-seq or spatial transcriptomics experiments."
  },
  {
    "objectID": "posts/hybrid-reference-profiles/index.html#background",
    "href": "posts/hybrid-reference-profiles/index.html#background",
    "title": "Creating reference profiles for InSituType",
    "section": "",
    "text": "The InSituType cell typing algorithm relies on a “reference matrix” to perform supervised or semi-supervised cell typing. A reference matrix gives the expected gene expression profile of each cell type in a tissue; these are usually derived from previous scRNA-seq or spatial transcriptomics experiments."
  },
  {
    "objectID": "posts/hybrid-reference-profiles/index.html#deriving-reference-profiles",
    "href": "posts/hybrid-reference-profiles/index.html#deriving-reference-profiles",
    "title": "Creating reference profiles for InSituType",
    "section": "Deriving reference profiles:",
    "text": "Deriving reference profiles:\nTo create reference profiles from a previous dataset, you can use InSituType::getRNAprofiles. When using this function, keep the following in mind:\n\nEnsure that your dataset is linear-scale (no log-transformations)\nRaw data is preferred, though normalized will work just fine\nIf you input data is scRNA-seq, which has essentially no background, just enter the negative control argument as neg = rep(0, length(clust)) (where clust is the vector you pass to the clust argument)."
  },
  {
    "objectID": "posts/hybrid-reference-profiles/index.html#creating-hybrid-reference-profiles",
    "href": "posts/hybrid-reference-profiles/index.html#creating-hybrid-reference-profiles",
    "title": "Creating reference profiles for InSituType",
    "section": "Creating hybrid reference profiles:",
    "text": "Creating hybrid reference profiles:\nFairly often, it’s convenient to create a hybrid reference matrix from two studies. In a typical example, you may want to cell type a solid tissue with autoimmune disease. There is likely a good scRNA-seq dataset available for the healthy cell types in your tissue, but this dataset probably has poor coverage of immune cells, as immune cells are rare in non-inflamed tissues, and most single cell datasets only sample some tens of thousands of cells.\n\nExample\nHere’s an example workflow for merging the HCA colon cell profiles (Kinchen et al 2018, original data here) with the InSituType immune cell profiles. The key steps are:\n\nAligning by shared genes\nRescaling (InSituType doesn’t care about the scaling of the columns in a reference matrix, but it’s convenient for descriptive analyses if they’re all comparably scaled.)\nRemoving redundant cell types\n\n\n# get immune cell profiles included in the InSituType library:\nlibrary(InSituType)\ndata(\"ioprofiles\")\nhead(ioprofiles)\n\n# load HCA profiles for colon:\nload(url(\"https://github.com/Nanostring-Biostats/CellProfileLibrary/raw/master/Human/Adult/Colon_HCA.RData\"))\ncolonprofiles &lt;- as.matrix(profile_matrix)\nhead(colonprofiles)\n\n# align genes:\nsharedgenes &lt;- intersect(rownames(ioprofiles), rownames(colonprofiles))\nioprofiles &lt;- ioprofiles[sharedgenes, ]\ncolonprofiles &lt;- colonprofiles[sharedgenes, ]\n\n# put on appproximately the same scale:\nioprofiles &lt;- ioprofiles / quantile(ioprofiles, 0.99) * 1000\ncolonprofiles &lt;- colonprofiles / quantile(colonprofiles, 0.99) * 1000\n\n# omit immune cells from colon profiles:\ncolnames(ioprofiles)\ncolnames(colonprofiles)\nomit_from_colon &lt;- c(\"plasma.cell\")\nomit_from_io &lt;- c(\"fibroblast\", \"endothelial\")\n\n# merge:\nref &lt;- cbind(ioprofiles[, setdiff(colnames(ioprofiles), omit_from_io)], \n             colonprofiles[, setdiff(colnames(colonprofiles), omit_from_colon)])\nhead(ref)\n\nOnce you obtain this merged reference profile, you can use it for cell typing with InSituType as you would any other reference matrix.\nFor deep-dives on other cell typing topics, see the InSituType FAQS."
  },
  {
    "objectID": "posts/seurat-cosmx-basics/index.html",
    "href": "posts/seurat-cosmx-basics/index.html",
    "title": "Introduction to visualizing CosMx SMI data in Seurat",
    "section": "",
    "text": "1 Introduction\nOne of the most exciting aspects of CosMx® Spatial Molecular Imager (SMI) data is the ability to directly observe gene expression in its spatial context at the single cell level. This is a great technological leap from previous single cell transcriptomics methods that lost spatial context while retrieving cells. For analysts looking to perform spatial data analysis, the Seurat R package has continually added features to support CosMx SMI data. Readers are encouraged to take a look at previous vignettes by the Seurat group (Spatial Vignette and Clustering Tutorial) as well as blog posts we’ve provided previously (scratch space). The blog post herein supplements these and provides you with some of the plotting configurations we find most helpful as you explore your CosMx SMI data. This vignette does not cover analysis of data in Seurat but rather tries to address frequently asked questions we’ve received from customers on getting started with their data in Seurat.\nFor this vignette, we use a Seurat object made from a mouse brain public data set. To download raw data for this dataset, go here. Two options to generate your own Seurat object from the AtoMx® Spatial Informatics Portal (SIP) are described below.\nLike other items in our CosMx Analysis Scratch Space, the usual caveats and license applies. This post will show you how to:\n\nSection 2 Load data into a Seurat object\nSection 3 Find important data in a Seurat object\nSection 4 Plot CosMx SMI data in space\nSection 5 Visualize dimension reduction data\nSection 6 Concluding thoughts\n\n\n\n2 Data Loading\n\n\n\n\n\n\nNote\n\n\n\nMany of the below functions require that you are working with Seurat v5 and may not work in earlier versions.\n\n\nFirst, load needed libraries:\n\nlibrary(Seurat)\nlibrary(ggplot2)\n\nAdjust globals option to avoid an error exceeding max allowed size. We’ve found this is necessary even with relatively small CosMx SMI datasets (30 - 40 FOVs).\n\noptions(future.globals.maxSize = 8000 * 1024^2)\n\nThere are two approaches to export CosMx SMI data from AtoMx SIP and load them into a Seurat object. Data can be exported from AtoMx SIP directly into a Seurat object. Alternatively, raw data can be exported as flat files and then loaded into a Seurat object. Both approaches are demonstrated below.\n\nExport Seurat objectExport flat files\n\n\nTo export CosMx SMI data from AtoMx SIP directly into a Seurat object, select “Export a Seurat Object” from the export module as shown in Figure 1. Be sure to export the Seurat object with transcript coordinates and polygon coordinates included to access all of the functionality below.\n\n\n\n\n\n\n\n\nFigure 1: Screenshot showing selection of Seurat object for export from AtoMx SIP.\n\n\n\n\n\nOnce export is complete, download the file using your SFTP application (e.g., cyberduck, FileZilla, WinSCP).\nYou can then load the Seurat object into R as follows. The Seurat object used for the demonstration here is available on Box.com here.\n\nseu.obj &lt;- readRDS(\"/path/to/file/seurat_object.Rds\")\n\n\n\nTo export CosMx SMI data from AtoMx SIP into flat files, select all five flat files from the export module as shown in Figure 2. For more information about the flat file formats, please see this post. When taking this approach, some tertiary analyses run in AtoMx SIP may not be included. For example, any PCA or UMAP dimension reductions performed in AtoMx SIP do not get exported in the flat files and so will not be present in the Seurat object when generated from flat files.\n\n\n\n\n\n\n\n\nFigure 2: Screenshot showing selection of flat files for export from AtoMx SIP.\n\n\n\n\n\nOnce export is complete, download the files using your SFTP application (e.g., cyberduck, FileZilla, WinSCP).\nLoad the flat files into a Seurat object using the LoadNanostring function from the Seurat package. Within the Seurat object, each slide is stored as a separate ‘image’ or ‘fov’. This is an unfortunate naming convention difference between CosMx SMI nomenclature and the Seurat package. What Seurat refers to as an ‘fov’ is what NanoString refers to as a slide. When you load flat files into a Seurat object, you need to name the Seurat fov / CosMx SMI slide with the argument fov =. This name must be a character, not a numeric. Here we use “slide1”, but more descriptive names are also possible. For an example of how to plot a single CosMx SMI FOV, see Section 4.\n\nseu.obj &lt;- LoadNanostring(\"/path/to/flatFileDirectory/\", fov = \"slide1\")\n\nThere are two main additions that we recommend making after generating this initial Seurat object. First, this initial Seurat object will not have many of the metadata columns included in the cell metadata flat file. Second, this Seurat object will store the expression of all probes, including negative probes and system controls, in one assay named “Nanostring”. We modify the Seurat object from both of these defaults here.\n\n# Add cell metadata\ncell_meta &lt;- read.csv(\"/path/to/flatFileDirectory/SlideName_metadata_file.csv\")\nrow.names(cell_meta) &lt;- paste0(cell_meta$cell_ID, \"_\", cell_meta$fov)\nseu.obj &lt;- AddMetaData(seu.obj, metadata = cell_meta)\n\n# Move control probes to separate assays\nif(length(grep(\"Neg\", rownames(seu.obj@assays$Nanostring))) &gt; 0){\n  # Extract neg probes to a separate assay\n  neg_probes &lt;- grep(\"Neg\", rownames(seu.obj@assays$Nanostring), value = T)\n  neg_matrix &lt;- seu.obj@assays$Nanostring$counts[neg_probes,]\n  neg_assay &lt;- CreateAssayObject(counts = neg_matrix)\n  \n  # Remove from original assay\n  seu.obj &lt;- subset(seu.obj, features = setdiff(rownames(seu.obj@assays$Nanostring), neg_probes))\n  \n  # Add to new assay\n  seu.obj[[\"NegProbes\"]] &lt;- neg_assay \n  \n}\n\nif(length(grep(\"SystemControl\", rownames(seu.obj@assays$Nanostring))) &gt; 0){\n  # Extract system control probes to a separate assay\n  sysctrl_probes &lt;- grep(\"SystemControl\", rownames(seu.obj@assays$Nanostring), value = T)\n  sysctrl_matrix &lt;- seu.obj@assays$Nanostring$counts[sysctrl_probes,]\n  sysctrl_assay &lt;- CreateAssayObject(counts = sysctrl_matrix)\n  \n  # Remove from original assay\n  seu.obj &lt;- subset(seu.obj, features = setdiff(rownames(seu.obj@assays$Nanostring), sysctrl_probes))\n  \n  # Add to new assay\n  seu.obj[[\"SystemControls\"]] &lt;- sysctrl_assay \n  \n}\n\nFor convenience, you may want to save this Seurat object for future use.\n\nsaveRDS(seu.obj, file = \"seurat_object.Rds\")\n\nIf you have data from multiple CosMx SMI slides, you can join them all into a single Seurat object with multiple images.\n\n# Make a list of multiple Seurat objects\nall_seurat_objects &lt;- list(\n  \"slide1\" = seu.obj_1,\n  \"slide2\" = seu.obj_2,\n  \"slide3\" = seu.obj_3\n)\n\n# Merge objects together, appending a slide identifier to each cell ID\njoined_seu.obj &lt;- merge(all_seurat_objects[[1]], \n                        y = all_seurat_objects[2:length(all_seurat_objects)], \n                        add.cell.ids = names(all_seurat_objects), \n                        project = \"CosMx\")\n\n\n\n\n\n\n3 Data Structure\nHere we’ll show where various key data are stored in the Seurat object.\n\n# Cell metadata\nhead(seu.obj@meta.data)\n\n\n\n                       orig.ident nCount_Nanostring nFeature_Nanostring cell_ID\nRun1000.S1.Half_1_1 SeuratProject               216                  95 c_2_1_1\nRun1000.S1.Half_2_1 SeuratProject               325                 118 c_2_1_2\nRun1000.S1.Half_3_1 SeuratProject               503                 284 c_2_1_3\nRun1000.S1.Half_4_1 SeuratProject              1085                 329 c_2_1_4\nRun1000.S1.Half_5_1 SeuratProject               935                 349 c_2_1_5\nRun1000.S1.Half_6_1 SeuratProject              1705                 487 c_2_1_6\n                    fov  Area AspectRatio Width Height Mean.Histone Max.Histone\nRun1000.S1.Half_1_1   1  6073        0.47    66    141         7095       42463\nRun1000.S1.Half_2_1   1  5675        0.72   101    140         9220       39045\nRun1000.S1.Half_3_1   1 12896        1.26   153    121        16993       45967\nRun1000.S1.Half_4_1   1  8234        0.51    81    160        12720       31967\nRun1000.S1.Half_5_1   1  9852        0.88   117    133        11177       38479\nRun1000.S1.Half_6_1   1 13372        0.90   171    191         6009       17648\n                    Mean.Blank Max.Blank Mean.rRNA Max.rRNA Mean.GFAP Max.GFAP\nRun1000.S1.Half_1_1         70      4044       376     2871        42     3313\nRun1000.S1.Half_2_1         82       296       642     1486        36      527\nRun1000.S1.Half_3_1         78      1652       109     1538        37     1797\nRun1000.S1.Half_4_1        121      3074       664     3284        71     3625\nRun1000.S1.Half_5_1         99      3173       444     2946        82     2957\nRun1000.S1.Half_6_1        215      2482       687     2429      2775    35102\n                    Mean.DAPI Max.DAPI Run_name Slide_name ISH.concentration\nRun1000.S1.Half_1_1        65      233  Run1000 Run1000_S1               1nM\nRun1000.S1.Half_2_1        88      287  Run1000 Run1000_S1               1nM\nRun1000.S1.Half_3_1        35      249  Run1000 Run1000_S1               1nM\nRun1000.S1.Half_4_1       219      540  Run1000 Run1000_S1               1nM\nRun1000.S1.Half_5_1       251      628  Run1000 Run1000_S1               1nM\nRun1000.S1.Half_6_1       255      702  Run1000 Run1000_S1               1nM\n                    Beta tissue slide_ID_numeric Run_Tissue_name\nRun1000.S1.Half_1_1   12   Half                2 Run1000_S1_Half\nRun1000.S1.Half_2_1   12   Half                2 Run1000_S1_Half\nRun1000.S1.Half_3_1   12   Half                2 Run1000_S1_Half\nRun1000.S1.Half_4_1   12   Half                2 Run1000_S1_Half\nRun1000.S1.Half_5_1   12   Half                2 Run1000_S1_Half\nRun1000.S1.Half_6_1   12   Half                2 Run1000_S1_Half\n                    log10totalcounts   IFcolor nb_clus leiden_clus\nRun1000.S1.Half_1_1         2.334454 #BC077CFF     PVM           2\nRun1000.S1.Half_2_1         2.511883 #FF06A1FF    VLMC           2\nRun1000.S1.Half_3_1         2.705008 #3706FFFF    OLPC          19\nRun1000.S1.Half_4_1         3.035430 #FF0CDEFF    VLMC           2\nRun1000.S1.Half_5_1         2.970347 #DE0DC3FF    VSMC           2\nRun1000.S1.Half_6_1         3.231470 #FFFF69FF     NGF           8\n                    nb_clus_final                  id\nRun1000.S1.Half_1_1          VLMC Run1000.S1.Half_1_1\nRun1000.S1.Half_2_1          VLMC Run1000.S1.Half_2_1\nRun1000.S1.Half_3_1          OLPC Run1000.S1.Half_3_1\nRun1000.S1.Half_4_1          VLMC Run1000.S1.Half_4_1\nRun1000.S1.Half_5_1          VSMC Run1000.S1.Half_5_1\nRun1000.S1.Half_6_1           NGF Run1000.S1.Half_6_1\n\n\n\n# Transcript counts. Here, transcript counts are in the 'Nanostring' assay but in other objects they may be stored in an 'RNA' assay.\nseu.obj@assays$Nanostring$counts[1:5, 1:5]\n\n\n\nLoading required namespace: Matrix\n\n\n5 x 5 sparse Matrix of class \"dgCMatrix\"\n       Run1000.S1.Half_1_1 Run1000.S1.Half_2_1 Run1000.S1.Half_3_1\nSlc6a1                   .                   .                   1\nCd109                    .                   .                   .\nLdha                     .                   .                   1\nAldoc                    .                   .                   2\nDrd1                     .                   .                   .\n       Run1000.S1.Half_4_1 Run1000.S1.Half_5_1\nSlc6a1                   1                   .\nCd109                    .                   .\nLdha                     1                   2\nAldoc                    .                   2\nDrd1                     .                   .\n\n\n\n# UMAP positions\nseu.obj@reductions$umap@cell.embeddings[1:10,]\n\n\n\n                        umap_1     umap_2\nRun1000.S1.Half_1_1  -6.179202 -22.688357\nRun1000.S1.Half_2_1  -6.470077 -23.498900\nRun1000.S1.Half_3_1  -7.297677   4.227824\nRun1000.S1.Half_4_1  -6.037831 -23.252535\nRun1000.S1.Half_5_1  -2.250786 -21.083180\nRun1000.S1.Half_6_1  14.308562  27.765420\nRun1000.S1.Half_7_1  -6.235466 -22.308980\nRun1000.S1.Half_8_1  -6.485635 -22.782622\nRun1000.S1.Half_9_1  -7.263406 -21.322018\nRun1000.S1.Half_10_1 -7.601895   4.258457\n\n\n\n# Image names. Each slide is stored as a separate image within the object.\nImages(seu.obj)\n\n\n\n[1] \"Run1000.S1.Half\"    \"Run5642.S3.Quarter\"\n\n\n\n# Positions in space, here shown for one image / slide\nseu.obj@images[[Images(seu.obj)[1]]]$centroids@coords[1:10,] # In this object, this is equivalent to: seu.obj@images$Run1000.S1.Half$centroids@coords[1:10,]\n\n\n\n              x     y\n [1,] -494161.3 10541\n [2,] -494201.3 10413\n [3,] -496227.3 10339\n [4,] -494275.3 10083\n [5,] -494221.3  9981\n [6,] -494216.3  9776\n [7,] -494375.3  9591\n [8,] -494697.3  9149\n [9,] -494748.3  8939\n[10,] -494669.3  8799\n\n\n\n\n4 Plot data in space\nAs noted above, within the Seurat object, each slide is stored as a separate ‘image’ or ‘fov’. This is an unfortunate naming convention difference between CosMx SMI nomenclature and the Seurat package. What Seurat refers to as an ‘fov’ is what NanoString refers to as a slide. When plotting cells in space, you need to specify the Seurat ‘fov’ to plot, and this is equivalent to choosing which CosMx SMI slide to plot.\nPlot all cells on one slide in space, coloring by cell type.\n\n# Get name of the first image\nimage1 &lt;- Images(seu.obj)[1]\n\n# Plot all cells.\n# We recommend setting the border color to 'NA' as the default 'white' often masks all cells when zoomed out, leading to a fully white plot.\nImageDimPlot(seu.obj, fov = image1, axes = TRUE, border.color = NA)\n\n\n\n\n\n\n\n\n\n\nPlot the location of individual transcripts with the ‘molecules’ option.\n\nImageDimPlot(seu.obj,\n             fov = Images(seu.obj)[1],\n             border.color = \"black\",\n             alpha = 0.5, # Reduce alpha of cell fills to better visualize the overlaying molcules\n             molecules = c(\"Slc17a7\", \"Gad1\", \"Plp1\"),\n             mols.size = 0.2,\n             nmols = 100000, # Set the total number of molecules to visualize\n             axes = FALSE)\n\n\n\n\n\n\n\n\n\n\nPlot one CosMx SMI FOV. To do this, we set the cells we’d like to plot to be all those in our target FOV. A similar strategy could be used to plot a subset of FOVs or a subset of cells of interest.\n\nImageDimPlot(seu.obj,\n             fov = Images(seu.obj)[1],\n             border.color = \"black\",\n             cells = row.names(seu.obj@meta.data)[which(seu.obj@meta.data$fov == 99)])\n\n\n\n\n\n\n\n\n\n\nBy default, cells are colored by the ‘Identity’ set in the Seurat object. We can change this by selecting another column to color by. Here we show coloring by leiden cluster, which we treat as a factor rather than an integer.\n\n# Check the default identities\nhead(Idents(seu.obj))\n\n# Plot by leiden cluster using the 'group.by' option\nImageDimPlot(seu.obj,\n             fov = Images(seu.obj)[1],\n             border.color = \"black\",\n             group.by = \"leiden_clus\",\n             cols = \"glasbey\", # Option to use a different palette for cell colors\n             cells = row.names(seu.obj@meta.data)[which(seu.obj@meta.data$fov == 99)])\n\n\n\n\n\n\n\n\n\n\nTo color cells by a continuous value, such as the log10totalcounts, or by the expression of a transcript of interest, such as Slc17a7, we use the function ‘ImageFeaturePlot’.\n\n# Color cells by log10totalcounts\nImageFeaturePlot(seu.obj,\n             fov = Images(seu.obj)[1],\n             border.color = NA,\n            features = \"log10totalcounts\")\n\n\n\n\n\n\n\n\n\n\n\n# Color cells by the expression of a gene of interest, Slc17a7\nImageFeaturePlot(seu.obj,\n             fov = Images(seu.obj)[1],\n             border.color = NA,\n            features = \"Slc17a7\")\n\n\n\n\n\n\n\n\n\n\nSeurat can plot cells with either cell shapes shown (‘segmentation’) or with a single point at the center of where they’re located (‘centroids’). Here we show the switch to plotting centroids for one FOV.\n\n# Check what the current default boundary is\nDefaultBoundary(seu.obj@images[[Images(seu.obj)[1]]])\n\n# Change the default boundaries for the first slide\nDefaultBoundary(seu.obj@images[[Images(seu.obj)[1]]]) &lt;- \"centroids\"\n\n# Plot one FOV from this slide. Note that cell shapes are no longer shown\nImageDimPlot(seu.obj,\n             fov = Images(seu.obj)[1],\n             size = 5,\n             shuffle.cols = TRUE, # Option to randomly shuffle colors within the palette\n             cells = row.names(seu.obj@meta.data)[which(seu.obj@meta.data$fov == 99)])\n\n\n\n\n\n\n\n\n\n\n\n\n5 Dimension reduction plots\nThe CosMx SMI Seurat object contains coordinates for each cell for UMAP dimensional reduction.\nHere, we color cells by cell type and overlay cell type labels.\n\nDimPlot(seu.obj, \n        group.by = \"nb_clus\",\n        label = TRUE) +\n  theme(legend.position = \"none\") # Suppress the legend since labels are plotted on top of UMAP\n\n\n\n\n\n\n\n\n\n\nHere, we color cells by a continuous value, using transcript expression for a transcript of interest.\n\nFeaturePlot(seu.obj, \n        features = \"Slc17a7\",\n        order = TRUE) # plots cells in order of expression\n\n\n\n\n\n\n\n\n\n\n\n\n6 Conclusions\nThis vignette serves as an introduction to exploring CosMx SMI data in Seurat, with a primary focus on visualization. Mix and match the functions and options from above to generate new customized visualizations with your data. Once you’re comfortable visualizing your spatial data, you may want to proceed to refining your cell typing, performing differential expression, finding spatially correlated genes, or countless other analysis paths."
  },
  {
    "objectID": "posts/segmentation-error/index.html",
    "href": "posts/segmentation-error/index.html",
    "title": "The impact of segmentation error on differential expression analyses",
    "section": "",
    "text": "Cell segmentation is always imperfect, leaving some cells’ expression profiles contaminated with transcripts properly belonging to other cells. For many analyses, this is a largely ignorable source of noise. But for differential expression (DE) analyses, it’s reliably confounding (both statistically and emotionally).\n\n\nFor an example, see the below cartoon, where a T-cell’s expression profile is contaminated with transcripts from the tumor cells surrounding it:\n\nNow say we want to compare T-cells in the tumor bed vs. T-cells in the stroma. We’ll find that T-cells in the tumor bed are enriched in genes expressed by cancer cells (e.g. keratins), and similarly, T-cells in the stroma will be enriched in genes expressed by stroma cells (e.g. collagens). In practice, spurious findings like these are often the most significant genes emerging from a DE analysis.\n\n\n\nSegmentation error can be considered a missing term in a differential expression model. Say you’re answering the above T-cell question by fitting the below model on T-cells:\nE(observed KRT9 expression) = B0 + B1  (in_tumor)*\nWhen you do this, you’re omitting an important term for contamination:\nE(observed KRT9 expression) = B0 + B1  (in_tumor) + (N_contaminating_transcripts)*\nYour model is underspecified, so its results are biased. As you measure more cells and gain statistical power, you only gain more confidence in your biased results.\n\n\n\nWe are preparing a manuscript detailing countermeasures to segmentation. Stay tuned for a link to it, or ask us for code if you can’t wait. For now, two pieces of advice:\n\nDon’t bother analyzing genes that are dominated by contamination. If you’re analyzing T-cells in tumors, then analyzing KRT9 is hopeless: T-cells barely express it, while the surrounding tumor cells will express it highly. Whatever expression you do see in T-cells will be dominated by contamination. A simple approach: if you’re e.g. analyzing T-cells, then compare each gene’s expression within T-cells to its expression in spatial neighbors of T-cells. The ratio between these numbers tells you how much of that gene’s expression in T-cells is real vs. contamination. Apply a reasonable threshold, and don’t even analyze genes with much higher expression around T-cells than inside T-cells.\nEstimate each cell’s contamination, and adjust for it in your models. Adding e.g. a term holding a gene’s expression in each cell’s neighbors achieves this well; more complex transformations of this term can be more optimal (see our upcoming paper). However, this only ameliorates, not solves, the bias from contamination. Because your estimated contamination term is a noisy approximation to true contamination, your models will estimate an attenuated effect size for the contamination term, and it won’t remove all the bias."
  },
  {
    "objectID": "posts/segmentation-error/index.html#the-problem",
    "href": "posts/segmentation-error/index.html#the-problem",
    "title": "The impact of segmentation error on differential expression analyses",
    "section": "",
    "text": "For an example, see the below cartoon, where a T-cell’s expression profile is contaminated with transcripts from the tumor cells surrounding it:\n\nNow say we want to compare T-cells in the tumor bed vs. T-cells in the stroma. We’ll find that T-cells in the tumor bed are enriched in genes expressed by cancer cells (e.g. keratins), and similarly, T-cells in the stroma will be enriched in genes expressed by stroma cells (e.g. collagens). In practice, spurious findings like these are often the most significant genes emerging from a DE analysis."
  },
  {
    "objectID": "posts/segmentation-error/index.html#how-to-think-about-segmentation-error",
    "href": "posts/segmentation-error/index.html#how-to-think-about-segmentation-error",
    "title": "The impact of segmentation error on differential expression analyses",
    "section": "",
    "text": "Segmentation error can be considered a missing term in a differential expression model. Say you’re answering the above T-cell question by fitting the below model on T-cells:\nE(observed KRT9 expression) = B0 + B1  (in_tumor)*\nWhen you do this, you’re omitting an important term for contamination:\nE(observed KRT9 expression) = B0 + B1  (in_tumor) + (N_contaminating_transcripts)*\nYour model is underspecified, so its results are biased. As you measure more cells and gain statistical power, you only gain more confidence in your biased results."
  },
  {
    "objectID": "posts/segmentation-error/index.html#countermeasures",
    "href": "posts/segmentation-error/index.html#countermeasures",
    "title": "The impact of segmentation error on differential expression analyses",
    "section": "",
    "text": "We are preparing a manuscript detailing countermeasures to segmentation. Stay tuned for a link to it, or ask us for code if you can’t wait. For now, two pieces of advice:\n\nDon’t bother analyzing genes that are dominated by contamination. If you’re analyzing T-cells in tumors, then analyzing KRT9 is hopeless: T-cells barely express it, while the surrounding tumor cells will express it highly. Whatever expression you do see in T-cells will be dominated by contamination. A simple approach: if you’re e.g. analyzing T-cells, then compare each gene’s expression within T-cells to its expression in spatial neighbors of T-cells. The ratio between these numbers tells you how much of that gene’s expression in T-cells is real vs. contamination. Apply a reasonable threshold, and don’t even analyze genes with much higher expression around T-cells than inside T-cells.\nEstimate each cell’s contamination, and adjust for it in your models. Adding e.g. a term holding a gene’s expression in each cell’s neighbors achieves this well; more complex transformations of this term can be more optimal (see our upcoming paper). However, this only ameliorates, not solves, the bias from contamination. Because your estimated contamination term is a noisy approximation to true contamination, your models will estimate an attenuated effect size for the contamination term, and it won’t remove all the bias."
  },
  {
    "objectID": "license.html",
    "href": "license.html",
    "title": "Blog",
    "section": "",
    "text": "Bruker Spatial Biology, Inc. Software License Agreement for Non-Commercial Use\nBy downloading, installing, accessing, modifying or otherwise making use of the Program (defined below), you agree to be bound by the terms and conditions of this Software License Agreement for Non-Commercial Use (this “License”).\n\nDEFINITIONS\n\n1.1. “Affiliate” means, with respect to an individual or entity, another individual or entity: (i) on whose behalf such individual or entity is acting, or (ii) that exercises control, is controlled by, or is under common control with such individual or entity. For the purposes of this definition, the term “control” means the right, whether by ownership, exercise of voting rights, contract, or otherwise, to direct the actions of an individual or entity.\n1.2. “Bruker” means Bruker Spatial Biology, Inc.\n1.3. “Distribute” means to distribute, share, make available, or otherwise provide the Program or Modified Program, as applicable, or access thereto (including via a computer network) to any third party.\n1.4. “Licensor” means the individual or entity licensing the rights granted in this License.\n1.5. “Licensee” or “you” means the individual or entity receiving or exercising the rights granted under this License, provided that the individual or entity is not a Competitor.\n1.6. “Non-Commercial Use” means any use where profit or other commercial benefit is not a direct or indirect motive or intended result.\n1.7. “Modified Program” means a derivative work of, or a work that is based on, uses or incorporates, the Program (whether or not in combination with other works, materials or content).\n1.8. “Competitor” means any individual or entity that directly or indirectly competes with Bruker or any of Bruker’s Affiliates or whose Affiliate directly or indirectly competes with Bruker or any of Bruker’s Affiliates.\n1.9. “Program” means the copyrightable work of authorship, program, code, or software licensed under this License.\n\nLICENSE\n\n2.1. Grant. Subject to the terms and conditions of this License, Licensor hereby grants to Licensee a worldwide, royalty-free, non-exclusive, revocable license to: (a) use, Distribute, and reproduce the Program, and (b) use, create, Distribute, and reproduce Modified Programs, in each case, solely for your internal, Non-Commercial Use. No rights are granted to Competitors.\n2.2. No Endorsement. Nothing in this License may be construed as permission to assert or imply that Licensor, Bruker, or other contributors to the Program sponsors, endorses, or is otherwise connected with the Licensee or the entity or institution that Licensee represents.\n2.3. Trademarks. Trademark rights are not licensed to you under this License.\n2.4. Grant of Patent License. Subject to the terms and conditions of this License, Bruker hereby grants to you a perpetual, worldwide, non-exclusive, no-charge, royalty-free, irrevocable (except as stated in this section) patent license to make, have made, use, import, and otherwise transfer the Program, where such license applies only to those patent claims licensable by Bruker that are necessarily infringed by Licensee alone or by combination of its modification(s) to the Program or Modified Program to which such modification(s) was submitted. If you institute patent litigation against any entity (including a cross-claim or counterclaim in a lawsuit) alleging that the Program, Modified Program, or a modification incorporated within the Program or a Modified Program constitutes direct or contributory patent infringement, then any patent licenses granted to you under this License for the Program or any such Modified Program shall terminate as of the date such litigation is filed.\n\nCONDITIONS TO THE RIGHT TO DISTRIBUTE\n\n3.1. Notices. If you Distribute the Program or a Modified Program in any form, you must also provide to the recipient:\n3.1.1. a copy of this License; and\n3.1.2. for Modified Programs, prominent notices identifying the portions of the Modified Program that have been modified, stating that you have modified the Program.\n3.2. Attribution. Except as otherwise expressly permitted under this License, you must keep intact, and you may not modify or remove, any notices, disclaimers, or attributions included in or provided with the Program. In addition, you must also include a prominent hypertext link back to Bruker’s website at www.nanostring.com.\n3.3. License. You may only Distribute the Program or the Modified Program under the terms of this License (or any later version, at your election). You may not offer or impose any additional or different terms or conditions that, or take any measures to, restrict the exercise of the rights granted under this License.\n\nNO REPRESENTATIONS OR WARRANTIES; LIMITATIONS OF LIABILITY\n\n4.1. Disclaimer. UNLESS OTHERWISE AGREED BY LICENSOR IN WRITING, TO THE FULLEST EXTENT PERMITTED BY APPLICABLE LAW, LICENSOR OFFERS THE PROGRAM AS-IS AND MAKES NO REPRESENTATIONS OR WARRANTIES OF ANY KIND WITH REGARD TO THE PROGRAM, WHETHER EXPRESS, IMPLIED, STATUTORY OR OTHERWISE, INCLUDING WITHOUT LIMITATION, WARRANTIES OF TITLE, MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND NONINFRINGEMENT. THE LICENSOR DOES NOT REPRESENT OR\nWARRANT THAT THE PROGRAM WILL BE ERROR FREE AND DOES NOT PROMISE THAT ANY SUCH ERRORS WILL BE CORRECTED.\nSOME JURISDICTIONS DO NOT ALLOW FOR THE EXCLUSION OF IMPLIED WARRANTIES, SO THE FOREGOING MAY NOT APPLY TO YOU.\n4.2. Limitation of Liability. TO THE FULLEST EXTENT PERMITTED BY APPLICABLE LAW, IN NO EVENT WILL THE LICENSOR OR BRUKER BE LIABLE TO YOU UNDER ANY LEGAL THEORY FOR ANY DAMAGES OF ANY KIND, INCLUDING ANY SPECIAL, INCIDENTAL, CONSEQUENTIAL, PUNITIVE OR EXEMPLARY DAMAGES ARISING OUT OF OR RELATED TO THE PROGRAM OR USE THEREOF, EVEN IF LICENSOR OR BRUKER HAS BEEN ADVISED OF THE POSSIBILITY OR LIKELIHOOD OF SUCH DAMAGES.\n\nMISCELLANEOUS\n\n5.1. Right to Enforce. Bruker is an express third-party beneficiary of this License and will be entitled to enforce the provisions of this License as if it were a party hereto.\n5.2. Waiver; Amendment. No term or provision hereof will be considered waived by the Licensor, and no breach excused by Licensor, unless such waiver or consent is in writing and signed by an authorized representative of Licensor. The waiver by Licensor of, or consent by Licensor to, a breach of any provision of this License by the Licensee, will not constitute, operate or be construed as a waiver of, consent to, or excuse of any other or subsequent breach by Licensee. This License may be amended or modified only by an agreement in writing signed by an authorized representative of each of Licensor and Licensee."
  },
  {
    "objectID": "license.html#license",
    "href": "license.html#license",
    "title": "Blog",
    "section": "",
    "text": "Bruker Spatial Biology, Inc. Software License Agreement for Non-Commercial Use\nBy downloading, installing, accessing, modifying or otherwise making use of the Program (defined below), you agree to be bound by the terms and conditions of this Software License Agreement for Non-Commercial Use (this “License”).\n\nDEFINITIONS\n\n1.1. “Affiliate” means, with respect to an individual or entity, another individual or entity: (i) on whose behalf such individual or entity is acting, or (ii) that exercises control, is controlled by, or is under common control with such individual or entity. For the purposes of this definition, the term “control” means the right, whether by ownership, exercise of voting rights, contract, or otherwise, to direct the actions of an individual or entity.\n1.2. “Bruker” means Bruker Spatial Biology, Inc.\n1.3. “Distribute” means to distribute, share, make available, or otherwise provide the Program or Modified Program, as applicable, or access thereto (including via a computer network) to any third party.\n1.4. “Licensor” means the individual or entity licensing the rights granted in this License.\n1.5. “Licensee” or “you” means the individual or entity receiving or exercising the rights granted under this License, provided that the individual or entity is not a Competitor.\n1.6. “Non-Commercial Use” means any use where profit or other commercial benefit is not a direct or indirect motive or intended result.\n1.7. “Modified Program” means a derivative work of, or a work that is based on, uses or incorporates, the Program (whether or not in combination with other works, materials or content).\n1.8. “Competitor” means any individual or entity that directly or indirectly competes with Bruker or any of Bruker’s Affiliates or whose Affiliate directly or indirectly competes with Bruker or any of Bruker’s Affiliates.\n1.9. “Program” means the copyrightable work of authorship, program, code, or software licensed under this License.\n\nLICENSE\n\n2.1. Grant. Subject to the terms and conditions of this License, Licensor hereby grants to Licensee a worldwide, royalty-free, non-exclusive, revocable license to: (a) use, Distribute, and reproduce the Program, and (b) use, create, Distribute, and reproduce Modified Programs, in each case, solely for your internal, Non-Commercial Use. No rights are granted to Competitors.\n2.2. No Endorsement. Nothing in this License may be construed as permission to assert or imply that Licensor, Bruker, or other contributors to the Program sponsors, endorses, or is otherwise connected with the Licensee or the entity or institution that Licensee represents.\n2.3. Trademarks. Trademark rights are not licensed to you under this License.\n2.4. Grant of Patent License. Subject to the terms and conditions of this License, Bruker hereby grants to you a perpetual, worldwide, non-exclusive, no-charge, royalty-free, irrevocable (except as stated in this section) patent license to make, have made, use, import, and otherwise transfer the Program, where such license applies only to those patent claims licensable by Bruker that are necessarily infringed by Licensee alone or by combination of its modification(s) to the Program or Modified Program to which such modification(s) was submitted. If you institute patent litigation against any entity (including a cross-claim or counterclaim in a lawsuit) alleging that the Program, Modified Program, or a modification incorporated within the Program or a Modified Program constitutes direct or contributory patent infringement, then any patent licenses granted to you under this License for the Program or any such Modified Program shall terminate as of the date such litigation is filed.\n\nCONDITIONS TO THE RIGHT TO DISTRIBUTE\n\n3.1. Notices. If you Distribute the Program or a Modified Program in any form, you must also provide to the recipient:\n3.1.1. a copy of this License; and\n3.1.2. for Modified Programs, prominent notices identifying the portions of the Modified Program that have been modified, stating that you have modified the Program.\n3.2. Attribution. Except as otherwise expressly permitted under this License, you must keep intact, and you may not modify or remove, any notices, disclaimers, or attributions included in or provided with the Program. In addition, you must also include a prominent hypertext link back to Bruker’s website at www.nanostring.com.\n3.3. License. You may only Distribute the Program or the Modified Program under the terms of this License (or any later version, at your election). You may not offer or impose any additional or different terms or conditions that, or take any measures to, restrict the exercise of the rights granted under this License.\n\nNO REPRESENTATIONS OR WARRANTIES; LIMITATIONS OF LIABILITY\n\n4.1. Disclaimer. UNLESS OTHERWISE AGREED BY LICENSOR IN WRITING, TO THE FULLEST EXTENT PERMITTED BY APPLICABLE LAW, LICENSOR OFFERS THE PROGRAM AS-IS AND MAKES NO REPRESENTATIONS OR WARRANTIES OF ANY KIND WITH REGARD TO THE PROGRAM, WHETHER EXPRESS, IMPLIED, STATUTORY OR OTHERWISE, INCLUDING WITHOUT LIMITATION, WARRANTIES OF TITLE, MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND NONINFRINGEMENT. THE LICENSOR DOES NOT REPRESENT OR\nWARRANT THAT THE PROGRAM WILL BE ERROR FREE AND DOES NOT PROMISE THAT ANY SUCH ERRORS WILL BE CORRECTED.\nSOME JURISDICTIONS DO NOT ALLOW FOR THE EXCLUSION OF IMPLIED WARRANTIES, SO THE FOREGOING MAY NOT APPLY TO YOU.\n4.2. Limitation of Liability. TO THE FULLEST EXTENT PERMITTED BY APPLICABLE LAW, IN NO EVENT WILL THE LICENSOR OR BRUKER BE LIABLE TO YOU UNDER ANY LEGAL THEORY FOR ANY DAMAGES OF ANY KIND, INCLUDING ANY SPECIAL, INCIDENTAL, CONSEQUENTIAL, PUNITIVE OR EXEMPLARY DAMAGES ARISING OUT OF OR RELATED TO THE PROGRAM OR USE THEREOF, EVEN IF LICENSOR OR BRUKER HAS BEEN ADVISED OF THE POSSIBILITY OR LIKELIHOOD OF SUCH DAMAGES.\n\nMISCELLANEOUS\n\n5.1. Right to Enforce. Bruker is an express third-party beneficiary of this License and will be entitled to enforce the provisions of this License as if it were a party hereto.\n5.2. Waiver; Amendment. No term or provision hereof will be considered waived by the Licensor, and no breach excused by Licensor, unless such waiver or consent is in writing and signed by an authorized representative of Licensor. The waiver by Licensor of, or consent by Licensor to, a breach of any provision of this License by the Licensee, will not constitute, operate or be construed as a waiver of, consent to, or excuse of any other or subsequent breach by Licensee. This License may be amended or modified only by an agreement in writing signed by an authorized representative of each of Licensor and Licensee."
  }
]